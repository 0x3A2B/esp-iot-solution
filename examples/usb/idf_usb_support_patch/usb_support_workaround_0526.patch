From 5ebbc17b9aee11d42bdfd0619f070a1373fb69ab Mon Sep 17 00:00:00 2001
From: baohongde <baohongde@espressif.com>
Date: Thu, 25 Mar 2021 17:28:35 +0800
Subject: [PATCH 01/43] components/bt: Set discoverable after create server

---
 .../bt_spp_acceptor/main/example_spp_acceptor_demo.c          | 4 ++--
 .../bt_spp_vfs_acceptor/main/example_spp_vfs_acceptor_demo.c  | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/examples/bluetooth/bluedroid/classic_bt/bt_spp_acceptor/main/example_spp_acceptor_demo.c b/examples/bluetooth/bluedroid/classic_bt/bt_spp_acceptor/main/example_spp_acceptor_demo.c
index ef4540ab67..f68ceb2540 100644
--- a/examples/bluetooth/bluedroid/classic_bt/bt_spp_acceptor/main/example_spp_acceptor_demo.c
+++ b/examples/bluetooth/bluedroid/classic_bt/bt_spp_acceptor/main/example_spp_acceptor_demo.c
@@ -56,8 +56,6 @@ static void esp_spp_cb(esp_spp_cb_event_t event, esp_spp_cb_param_t *param)
     switch (event) {
     case ESP_SPP_INIT_EVT:
         ESP_LOGI(SPP_TAG, "ESP_SPP_INIT_EVT");
-        esp_bt_dev_set_device_name(EXAMPLE_DEVICE_NAME);
-        esp_bt_gap_set_scan_mode(ESP_BT_CONNECTABLE, ESP_BT_GENERAL_DISCOVERABLE);
         esp_spp_start_srv(sec_mask,role_slave, 0, SPP_SERVER_NAME);
         break;
     case ESP_SPP_DISCOVERY_COMP_EVT:
@@ -71,6 +69,8 @@ static void esp_spp_cb(esp_spp_cb_event_t event, esp_spp_cb_param_t *param)
         break;
     case ESP_SPP_START_EVT:
         ESP_LOGI(SPP_TAG, "ESP_SPP_START_EVT");
+        esp_bt_dev_set_device_name(EXAMPLE_DEVICE_NAME);
+        esp_bt_gap_set_scan_mode(ESP_BT_CONNECTABLE, ESP_BT_GENERAL_DISCOVERABLE);
         break;
     case ESP_SPP_CL_INIT_EVT:
         ESP_LOGI(SPP_TAG, "ESP_SPP_CL_INIT_EVT");
diff --git a/examples/bluetooth/bluedroid/classic_bt/bt_spp_vfs_acceptor/main/example_spp_vfs_acceptor_demo.c b/examples/bluetooth/bluedroid/classic_bt/bt_spp_vfs_acceptor/main/example_spp_vfs_acceptor_demo.c
index 4b0acdf3b5..db608a36ee 100644
--- a/examples/bluetooth/bluedroid/classic_bt/bt_spp_vfs_acceptor/main/example_spp_vfs_acceptor_demo.c
+++ b/examples/bluetooth/bluedroid/classic_bt/bt_spp_vfs_acceptor/main/example_spp_vfs_acceptor_demo.c
@@ -80,8 +80,6 @@ static void esp_spp_cb(uint16_t e, void *p)
         ESP_LOGI(SPP_TAG, "ESP_SPP_INIT_EVT status=%d", param->init.status);
         if (param->init.status == ESP_SPP_SUCCESS) {
             esp_spp_vfs_register();
-            esp_bt_dev_set_device_name(EXAMPLE_DEVICE_NAME);
-            esp_bt_gap_set_scan_mode(ESP_BT_CONNECTABLE, ESP_BT_GENERAL_DISCOVERABLE);
             esp_spp_start_srv(sec_mask, role_slave, 0, SPP_SERVER_NAME);
         }
         break;
@@ -96,6 +94,8 @@ static void esp_spp_cb(uint16_t e, void *p)
         break;
     case ESP_SPP_START_EVT:
         ESP_LOGI(SPP_TAG, "ESP_SPP_START_EVT");
+        esp_bt_dev_set_device_name(EXAMPLE_DEVICE_NAME);
+        esp_bt_gap_set_scan_mode(ESP_BT_CONNECTABLE, ESP_BT_GENERAL_DISCOVERABLE);
         break;
     case ESP_SPP_CL_INIT_EVT:
         ESP_LOGI(SPP_TAG, "ESP_SPP_CL_INIT_EVT");
-- 
2.25.1


From a2686dc4eb7f2fa3a7a1b59308413ee4e351dd82 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jan=20Brudn=C3=BD?= <jan.brudny@espressif.com>
Date: Mon, 10 May 2021 04:56:51 +0200
Subject: [PATCH 02/43] bootloader: update copyright notice

---
 .../include/bootloader_clock.h                 | 18 +++++-------------
 .../include/bootloader_common.h                | 18 +++++-------------
 .../include/bootloader_flash.h                 | 18 +++++-------------
 .../include/bootloader_flash_config.h          | 18 +++++-------------
 .../include/bootloader_mem.h                   | 18 +++++-------------
 .../include/bootloader_random.h                | 18 +++++-------------
 .../include/bootloader_util.h                  | 18 +++++-------------
 .../include/esp_app_format.h                   | 18 +++++-------------
 .../include/esp_flash_data_types.h             |  5 +++++
 .../include/esp_flash_encrypt.h                | 18 +++++-------------
 .../include/esp_flash_partitions.h             | 18 +++++-------------
 .../include/esp_image_format.h                 | 18 +++++-------------
 .../include/esp_secure_boot.h                  | 18 +++++-------------
 .../include_bootloader/bootloader_config.h     | 18 +++++-------------
 .../include_bootloader/bootloader_console.h    | 18 +++++-------------
 .../include_bootloader/bootloader_flash_priv.h | 18 +++++-------------
 .../include_bootloader/bootloader_init.h       | 18 +++++-------------
 .../include_bootloader/bootloader_sha.h        | 18 +++++-------------
 .../include_bootloader/bootloader_utility.h    | 18 +++++-------------
 .../include_bootloader/flash_qio_mode.h        | 18 +++++-------------
 .../src/esp32/bootloader_esp32.c               | 18 +++++-------------
 .../src/esp32/bootloader_sha.c                 | 18 +++++-------------
 .../src/esp32/flash_encrypt.c                  | 18 +++++-------------
 .../bootloader_support/src/esp32/secure_boot.c | 18 +++++-------------
 .../src/esp32c3/bootloader_esp32c3.c           | 18 +++++-------------
 .../src/esp32c3/bootloader_sha.c               | 18 +++++-------------
 .../src/esp32c3/flash_encrypt.c                | 18 +++++-------------
 .../src/esp32c3/secure_boot.c                  | 18 +++++-------------
 .../src/esp32s2/bootloader_esp32s2.c           | 18 +++++-------------
 .../src/esp32s2/bootloader_sha.c               | 18 +++++-------------
 .../src/esp32s2/flash_encrypt.c                | 18 +++++-------------
 .../src/esp32s2/secure_boot.c                  | 18 +++++-------------
 .../src/esp32s3/bootloader_esp32s3.c           | 18 +++++-------------
 .../src/esp32s3/bootloader_sha.c               | 18 +++++-------------
 .../src/esp32s3/flash_encrypt.c                | 18 +++++-------------
 .../src/esp32s3/secure_boot.c                  | 18 +++++-------------
 .../src/idf/bootloader_sha.c                   | 18 +++++-------------
 .../secure_boot_signatures_app.c               | 18 +++++-------------
 .../secure_boot_signatures_bootloader.c        | 18 +++++-------------
 .../secure_boot_signatures_app.c               | 18 +++++-------------
 .../secure_boot_signatures_bootloader.c        | 18 +++++-------------
 .../test/test_verify_image.c                   |  5 +++++
 42 files changed, 210 insertions(+), 520 deletions(-)

diff --git a/components/bootloader_support/include/bootloader_clock.h b/components/bootloader_support/include/bootloader_clock.h
index 98546e8290..6b71f68f38 100644
--- a/components/bootloader_support/include/bootloader_clock.h
+++ b/components/bootloader_support/include/bootloader_clock.h
@@ -1,16 +1,8 @@
-// Copyright 2017 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2017-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #pragma once
 
diff --git a/components/bootloader_support/include/bootloader_common.h b/components/bootloader_support/include/bootloader_common.h
index 0723d19512..4d50649e01 100644
--- a/components/bootloader_support/include/bootloader_common.h
+++ b/components/bootloader_support/include/bootloader_common.h
@@ -1,16 +1,8 @@
-// Copyright 2018 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2018-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #pragma once
 #include "esp_flash_partitions.h"
diff --git a/components/bootloader_support/include/bootloader_flash.h b/components/bootloader_support/include/bootloader_flash.h
index 8bf7485252..73aa48923d 100644
--- a/components/bootloader_support/include/bootloader_flash.h
+++ b/components/bootloader_support/include/bootloader_flash.h
@@ -1,16 +1,8 @@
-// Copyright 2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2020-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #pragma once
 
 #include <esp_err.h>
diff --git a/components/bootloader_support/include/bootloader_flash_config.h b/components/bootloader_support/include/bootloader_flash_config.h
index 6074faca2b..8b80221132 100644
--- a/components/bootloader_support/include/bootloader_flash_config.h
+++ b/components/bootloader_support/include/bootloader_flash_config.h
@@ -1,16 +1,8 @@
-// Copyright 2018 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2018-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #pragma once
 
diff --git a/components/bootloader_support/include/bootloader_mem.h b/components/bootloader_support/include/bootloader_mem.h
index bc54833ff3..21c7114ce4 100644
--- a/components/bootloader_support/include/bootloader_mem.h
+++ b/components/bootloader_support/include/bootloader_mem.h
@@ -1,16 +1,8 @@
-// Copyright 2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2020-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #pragma once
 
 #ifdef __cplusplus
diff --git a/components/bootloader_support/include/bootloader_random.h b/components/bootloader_support/include/bootloader_random.h
index 98a7712f33..f88f5a4899 100644
--- a/components/bootloader_support/include/bootloader_random.h
+++ b/components/bootloader_support/include/bootloader_random.h
@@ -1,16 +1,8 @@
-// Copyright 2010-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2010-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #pragma once
 
diff --git a/components/bootloader_support/include/bootloader_util.h b/components/bootloader_support/include/bootloader_util.h
index a1b8d89c95..c44c80619c 100644
--- a/components/bootloader_support/include/bootloader_util.h
+++ b/components/bootloader_support/include/bootloader_util.h
@@ -1,16 +1,8 @@
-// Copyright 2018 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2018-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #pragma once
 
diff --git a/components/bootloader_support/include/esp_app_format.h b/components/bootloader_support/include/esp_app_format.h
index 20237728da..9be8784d3b 100644
--- a/components/bootloader_support/include/esp_app_format.h
+++ b/components/bootloader_support/include/esp_app_format.h
@@ -1,16 +1,8 @@
-// Copyright 2015-2019 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #pragma once
 
 #include <inttypes.h>
diff --git a/components/bootloader_support/include/esp_flash_data_types.h b/components/bootloader_support/include/esp_flash_data_types.h
index fda6d5c645..7b4171fdd3 100644
--- a/components/bootloader_support/include/esp_flash_data_types.h
+++ b/components/bootloader_support/include/esp_flash_data_types.h
@@ -1,2 +1,7 @@
+/*
+ * SPDX-FileCopyrightText: 2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #warning esp_flash_data_types.h has been merged into esp_flash_partitions.h, please include esp_flash_partitions.h instead
 #include "esp_flash_partitions.h"
diff --git a/components/bootloader_support/include/esp_flash_encrypt.h b/components/bootloader_support/include/esp_flash_encrypt.h
index 33e6aabed2..1fecd33bc7 100644
--- a/components/bootloader_support/include/esp_flash_encrypt.h
+++ b/components/bootloader_support/include/esp_flash_encrypt.h
@@ -1,16 +1,8 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #pragma once
 
 #include <stdbool.h>
diff --git a/components/bootloader_support/include/esp_flash_partitions.h b/components/bootloader_support/include/esp_flash_partitions.h
index 1fc9d4f6c1..6582409823 100644
--- a/components/bootloader_support/include/esp_flash_partitions.h
+++ b/components/bootloader_support/include/esp_flash_partitions.h
@@ -1,16 +1,8 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #pragma once
 
 #include "esp_err.h"
diff --git a/components/bootloader_support/include/esp_image_format.h b/components/bootloader_support/include/esp_image_format.h
index 7e7e6a28e1..1db6244253 100644
--- a/components/bootloader_support/include/esp_image_format.h
+++ b/components/bootloader_support/include/esp_image_format.h
@@ -1,16 +1,8 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #pragma once
 
 #include <stdbool.h>
diff --git a/components/bootloader_support/include/esp_secure_boot.h b/components/bootloader_support/include/esp_secure_boot.h
index 94118c327c..b9436a4344 100644
--- a/components/bootloader_support/include/esp_secure_boot.h
+++ b/components/bootloader_support/include/esp_secure_boot.h
@@ -1,16 +1,8 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #pragma once
 
 #include <stdbool.h>
diff --git a/components/bootloader_support/include_bootloader/bootloader_config.h b/components/bootloader_support/include_bootloader/bootloader_config.h
index 1d69195f0c..ef283b13bf 100644
--- a/components/bootloader_support/include_bootloader/bootloader_config.h
+++ b/components/bootloader_support/include_bootloader/bootloader_config.h
@@ -1,16 +1,8 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #ifndef __BOOT_CONFIG_H__
 #define __BOOT_CONFIG_H__
 
diff --git a/components/bootloader_support/include_bootloader/bootloader_console.h b/components/bootloader_support/include_bootloader/bootloader_console.h
index 1c168c9a02..64dd5f8404 100644
--- a/components/bootloader_support/include_bootloader/bootloader_console.h
+++ b/components/bootloader_support/include_bootloader/bootloader_console.h
@@ -1,16 +1,8 @@
-// Copyright 2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2020-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #pragma once
 
diff --git a/components/bootloader_support/include_bootloader/bootloader_flash_priv.h b/components/bootloader_support/include_bootloader/bootloader_flash_priv.h
index 39aae454fc..7d703b84fa 100644
--- a/components/bootloader_support/include_bootloader/bootloader_flash_priv.h
+++ b/components/bootloader_support/include_bootloader/bootloader_flash_priv.h
@@ -1,16 +1,8 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #ifndef __BOOTLOADER_FLASH_H
 #define __BOOTLOADER_FLASH_H
 
diff --git a/components/bootloader_support/include_bootloader/bootloader_init.h b/components/bootloader_support/include_bootloader/bootloader_init.h
index 0d5c95f3a2..bbbfe42d29 100644
--- a/components/bootloader_support/include_bootloader/bootloader_init.h
+++ b/components/bootloader_support/include_bootloader/bootloader_init.h
@@ -1,16 +1,8 @@
-// Copyright 2018 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2018-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #pragma once
 
 #include "esp_err.h"
diff --git a/components/bootloader_support/include_bootloader/bootloader_sha.h b/components/bootloader_support/include_bootloader/bootloader_sha.h
index 99db64b999..99079faa04 100644
--- a/components/bootloader_support/include_bootloader/bootloader_sha.h
+++ b/components/bootloader_support/include_bootloader/bootloader_sha.h
@@ -1,16 +1,8 @@
-// Copyright 2017 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2017-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #pragma once
 
 /* Provide a SHA256 API for bootloader_support code,
diff --git a/components/bootloader_support/include_bootloader/bootloader_utility.h b/components/bootloader_support/include_bootloader/bootloader_utility.h
index 8e534756c6..e1abc04f44 100644
--- a/components/bootloader_support/include_bootloader/bootloader_utility.h
+++ b/components/bootloader_support/include_bootloader/bootloader_utility.h
@@ -1,16 +1,8 @@
-// Copyright 2018 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2018-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #pragma once
 
 #include "bootloader_config.h"
diff --git a/components/bootloader_support/include_bootloader/flash_qio_mode.h b/components/bootloader_support/include_bootloader/flash_qio_mode.h
index 7f70d5bb08..05954b25de 100644
--- a/components/bootloader_support/include_bootloader/flash_qio_mode.h
+++ b/components/bootloader_support/include_bootloader/flash_qio_mode.h
@@ -1,16 +1,8 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #pragma once
 
 #ifdef __cplusplus
diff --git a/components/bootloader_support/src/esp32/bootloader_esp32.c b/components/bootloader_support/src/esp32/bootloader_esp32.c
index b385b17b5c..87fb262882 100644
--- a/components/bootloader_support/src/esp32/bootloader_esp32.c
+++ b/components/bootloader_support/src/esp32/bootloader_esp32.c
@@ -1,16 +1,8 @@
-// Copyright 2019 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2019-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include <stdint.h>
 #include "sdkconfig.h"
 #include "esp_attr.h"
diff --git a/components/bootloader_support/src/esp32/bootloader_sha.c b/components/bootloader_support/src/esp32/bootloader_sha.c
index 7be1108a54..8d81d165a1 100644
--- a/components/bootloader_support/src/esp32/bootloader_sha.c
+++ b/components/bootloader_support/src/esp32/bootloader_sha.c
@@ -1,16 +1,8 @@
-// Copyright 2017 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2017-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include "bootloader_sha.h"
 #include <stdbool.h>
 #include <string.h>
diff --git a/components/bootloader_support/src/esp32/flash_encrypt.c b/components/bootloader_support/src/esp32/flash_encrypt.c
index ebbf598ea2..7302e0a1c8 100644
--- a/components/bootloader_support/src/esp32/flash_encrypt.c
+++ b/components/bootloader_support/src/esp32/flash_encrypt.c
@@ -1,16 +1,8 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #include <strings.h>
 
diff --git a/components/bootloader_support/src/esp32/secure_boot.c b/components/bootloader_support/src/esp32/secure_boot.c
index bb293ccb06..1d48068520 100644
--- a/components/bootloader_support/src/esp32/secure_boot.c
+++ b/components/bootloader_support/src/esp32/secure_boot.c
@@ -1,16 +1,8 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #include <string.h>
 
diff --git a/components/bootloader_support/src/esp32c3/bootloader_esp32c3.c b/components/bootloader_support/src/esp32c3/bootloader_esp32c3.c
index 2af91fd135..69d12ca2fc 100644
--- a/components/bootloader_support/src/esp32c3/bootloader_esp32c3.c
+++ b/components/bootloader_support/src/esp32c3/bootloader_esp32c3.c
@@ -1,16 +1,8 @@
-// Copyright 2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2020-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include <stdint.h>
 #include "sdkconfig.h"
 #include "esp_attr.h"
diff --git a/components/bootloader_support/src/esp32c3/bootloader_sha.c b/components/bootloader_support/src/esp32c3/bootloader_sha.c
index 9388626e89..2dc321b021 100644
--- a/components/bootloader_support/src/esp32c3/bootloader_sha.c
+++ b/components/bootloader_support/src/esp32c3/bootloader_sha.c
@@ -1,16 +1,8 @@
-// Copyright 2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2020-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include "bootloader_sha.h"
 #include <stdbool.h>
 #include <string.h>
diff --git a/components/bootloader_support/src/esp32c3/flash_encrypt.c b/components/bootloader_support/src/esp32c3/flash_encrypt.c
index 8c553cd253..10bfed3f1c 100644
--- a/components/bootloader_support/src/esp32c3/flash_encrypt.c
+++ b/components/bootloader_support/src/esp32c3/flash_encrypt.c
@@ -1,16 +1,8 @@
-// Copyright 2015-2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #include <strings.h>
 #include "bootloader_flash_priv.h"
diff --git a/components/bootloader_support/src/esp32c3/secure_boot.c b/components/bootloader_support/src/esp32c3/secure_boot.c
index cdc89f8b80..47eca92561 100644
--- a/components/bootloader_support/src/esp32c3/secure_boot.c
+++ b/components/bootloader_support/src/esp32c3/secure_boot.c
@@ -1,16 +1,8 @@
-// Copyright 2015-2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include <string.h>
 
 #include "esp_log.h"
diff --git a/components/bootloader_support/src/esp32s2/bootloader_esp32s2.c b/components/bootloader_support/src/esp32s2/bootloader_esp32s2.c
index aa089531c3..07fe2ac690 100644
--- a/components/bootloader_support/src/esp32s2/bootloader_esp32s2.c
+++ b/components/bootloader_support/src/esp32s2/bootloader_esp32s2.c
@@ -1,16 +1,8 @@
-// Copyright 2019 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2019-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include <stdint.h>
 #include "sdkconfig.h"
 #include "bootloader_common.h"
diff --git a/components/bootloader_support/src/esp32s2/bootloader_sha.c b/components/bootloader_support/src/esp32s2/bootloader_sha.c
index e7dc5b0edc..99cc8a2631 100644
--- a/components/bootloader_support/src/esp32s2/bootloader_sha.c
+++ b/components/bootloader_support/src/esp32s2/bootloader_sha.c
@@ -1,16 +1,8 @@
-// Copyright 2017 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2017-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include "bootloader_sha.h"
 #include <stdbool.h>
 #include <string.h>
diff --git a/components/bootloader_support/src/esp32s2/flash_encrypt.c b/components/bootloader_support/src/esp32s2/flash_encrypt.c
index ad383ee296..e4c3de8885 100644
--- a/components/bootloader_support/src/esp32s2/flash_encrypt.c
+++ b/components/bootloader_support/src/esp32s2/flash_encrypt.c
@@ -1,16 +1,8 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #include <strings.h>
 
diff --git a/components/bootloader_support/src/esp32s2/secure_boot.c b/components/bootloader_support/src/esp32s2/secure_boot.c
index c79203ed84..ab8e914a98 100644
--- a/components/bootloader_support/src/esp32s2/secure_boot.c
+++ b/components/bootloader_support/src/esp32s2/secure_boot.c
@@ -1,16 +1,8 @@
-// Copyright 2015-2018 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include <string.h>
 
 #include "esp_log.h"
diff --git a/components/bootloader_support/src/esp32s3/bootloader_esp32s3.c b/components/bootloader_support/src/esp32s3/bootloader_esp32s3.c
index 6d5baf8c6e..160eb0a57b 100644
--- a/components/bootloader_support/src/esp32s3/bootloader_esp32s3.c
+++ b/components/bootloader_support/src/esp32s3/bootloader_esp32s3.c
@@ -1,16 +1,8 @@
-// Copyright 2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2020-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include <stdint.h>
 #include "sdkconfig.h"
 #include "esp_attr.h"
diff --git a/components/bootloader_support/src/esp32s3/bootloader_sha.c b/components/bootloader_support/src/esp32s3/bootloader_sha.c
index b0d5b9b124..10fd2588f5 100644
--- a/components/bootloader_support/src/esp32s3/bootloader_sha.c
+++ b/components/bootloader_support/src/esp32s3/bootloader_sha.c
@@ -1,16 +1,8 @@
-// Copyright 2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2020-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include "bootloader_sha.h"
 #include <stdbool.h>
 #include <string.h>
diff --git a/components/bootloader_support/src/esp32s3/flash_encrypt.c b/components/bootloader_support/src/esp32s3/flash_encrypt.c
index 99ba1e41fe..283bd3910c 100644
--- a/components/bootloader_support/src/esp32s3/flash_encrypt.c
+++ b/components/bootloader_support/src/esp32s3/flash_encrypt.c
@@ -1,16 +1,8 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #include <strings.h>
 
diff --git a/components/bootloader_support/src/esp32s3/secure_boot.c b/components/bootloader_support/src/esp32s3/secure_boot.c
index e501cc7d08..bba27635c0 100644
--- a/components/bootloader_support/src/esp32s3/secure_boot.c
+++ b/components/bootloader_support/src/esp32s3/secure_boot.c
@@ -1,16 +1,8 @@
-// Copyright 2015-2018 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include <string.h>
 
 #include "esp_log.h"
diff --git a/components/bootloader_support/src/idf/bootloader_sha.c b/components/bootloader_support/src/idf/bootloader_sha.c
index 1aaa6708ef..f6347e44e6 100644
--- a/components/bootloader_support/src/idf/bootloader_sha.c
+++ b/components/bootloader_support/src/idf/bootloader_sha.c
@@ -1,16 +1,8 @@
-// Copyright 2017 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2017-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include "bootloader_sha.h"
 #include "bootloader_flash_priv.h"
 #include <stdbool.h>
diff --git a/components/bootloader_support/src/secure_boot_v1/secure_boot_signatures_app.c b/components/bootloader_support/src/secure_boot_v1/secure_boot_signatures_app.c
index ce40ff5861..a0eaa39af2 100644
--- a/components/bootloader_support/src/secure_boot_v1/secure_boot_signatures_app.c
+++ b/components/bootloader_support/src/secure_boot_v1/secure_boot_signatures_app.c
@@ -1,16 +1,8 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include "sdkconfig.h"
 
 #include "bootloader_flash_priv.h"
diff --git a/components/bootloader_support/src/secure_boot_v1/secure_boot_signatures_bootloader.c b/components/bootloader_support/src/secure_boot_v1/secure_boot_signatures_bootloader.c
index 71e3558c3e..ae197dc613 100644
--- a/components/bootloader_support/src/secure_boot_v1/secure_boot_signatures_bootloader.c
+++ b/components/bootloader_support/src/secure_boot_v1/secure_boot_signatures_bootloader.c
@@ -1,16 +1,8 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include "sdkconfig.h"
 
 #include "bootloader_flash_priv.h"
diff --git a/components/bootloader_support/src/secure_boot_v2/secure_boot_signatures_app.c b/components/bootloader_support/src/secure_boot_v2/secure_boot_signatures_app.c
index 6fecadc251..2002a5ef31 100644
--- a/components/bootloader_support/src/secure_boot_v2/secure_boot_signatures_app.c
+++ b/components/bootloader_support/src/secure_boot_v2/secure_boot_signatures_app.c
@@ -1,16 +1,8 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include "sdkconfig.h"
 
 #include "bootloader_flash_priv.h"
diff --git a/components/bootloader_support/src/secure_boot_v2/secure_boot_signatures_bootloader.c b/components/bootloader_support/src/secure_boot_v2/secure_boot_signatures_bootloader.c
index 09e167b057..5ff79eea18 100644
--- a/components/bootloader_support/src/secure_boot_v2/secure_boot_signatures_bootloader.c
+++ b/components/bootloader_support/src/secure_boot_v2/secure_boot_signatures_bootloader.c
@@ -1,16 +1,8 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include "sdkconfig.h"
 
 #include <string.h>
diff --git a/components/bootloader_support/test/test_verify_image.c b/components/bootloader_support/test/test_verify_image.c
index 15dc037cdf..7675abb718 100644
--- a/components/bootloader_support/test/test_verify_image.c
+++ b/components/bootloader_support/test/test_verify_image.c
@@ -1,3 +1,8 @@
+/*
+ * SPDX-FileCopyrightText: 2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 /*
  * Tests for bootloader_support esp_load(ESP_IMAGE_VERIFY, ...)
  */
-- 
2.25.1


From bd3a6dda87453694edf2df846787954d8c367822 Mon Sep 17 00:00:00 2001
From: Ivan Grokhotkov <ivan@espressif.com>
Date: Mon, 4 Jan 2021 20:30:02 +0100
Subject: [PATCH 03/43] soc: esp32s2: remove SDMMC header files

no SDMMC peripheral in this chip
---
 .../soc/esp32s2/include/soc/sdmmc_reg.h       |  96 -----
 .../soc/esp32s2/include/soc/sdmmc_struct.h    | 377 ------------------
 2 files changed, 473 deletions(-)
 delete mode 100644 components/soc/esp32s2/include/soc/sdmmc_reg.h
 delete mode 100644 components/soc/esp32s2/include/soc/sdmmc_struct.h

diff --git a/components/soc/esp32s2/include/soc/sdmmc_reg.h b/components/soc/esp32s2/include/soc/sdmmc_reg.h
deleted file mode 100644
index 2f9c68f80b..0000000000
--- a/components/soc/esp32s2/include/soc/sdmmc_reg.h
+++ /dev/null
@@ -1,96 +0,0 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-#ifndef _SOC_SDMMC_REG_H_
-#define _SOC_SDMMC_REG_H_
-#include "soc.h"
-
-#define SDMMC_CTRL_REG          (DR_REG_SDMMC_BASE + 0x00)
-#define SDMMC_PWREN_REG         (DR_REG_SDMMC_BASE + 0x04)
-#define SDMMC_CLKDIV_REG        (DR_REG_SDMMC_BASE + 0x08)
-#define SDMMC_CLKSRC_REG        (DR_REG_SDMMC_BASE + 0x0c)
-#define SDMMC_CLKENA_REG        (DR_REG_SDMMC_BASE + 0x10)
-#define SDMMC_TMOUT_REG         (DR_REG_SDMMC_BASE + 0x14)
-#define SDMMC_CTYPE_REG         (DR_REG_SDMMC_BASE + 0x18)
-#define SDMMC_BLKSIZ_REG        (DR_REG_SDMMC_BASE + 0x1c)
-#define SDMMC_BYTCNT_REG        (DR_REG_SDMMC_BASE + 0x20)
-#define SDMMC_INTMASK_REG       (DR_REG_SDMMC_BASE + 0x24)
-#define SDMMC_CMDARG_REG        (DR_REG_SDMMC_BASE + 0x28)
-#define SDMMC_CMD_REG           (DR_REG_SDMMC_BASE + 0x2c)
-#define SDMMC_RESP0_REG         (DR_REG_SDMMC_BASE + 0x30)
-#define SDMMC_RESP1_REG         (DR_REG_SDMMC_BASE + 0x34)
-#define SDMMC_RESP2_REG         (DR_REG_SDMMC_BASE + 0x38)
-#define SDMMC_RESP3_REG         (DR_REG_SDMMC_BASE + 0x3c)
-
-#define SDMMC_MINTSTS_REG       (DR_REG_SDMMC_BASE + 0x40)
-#define SDMMC_RINTSTS_REG       (DR_REG_SDMMC_BASE + 0x44)
-#define SDMMC_STATUS_REG        (DR_REG_SDMMC_BASE + 0x48)
-#define SDMMC_FIFOTH_REG        (DR_REG_SDMMC_BASE + 0x4c)
-#define SDMMC_CDETECT_REG       (DR_REG_SDMMC_BASE + 0x50)
-#define SDMMC_WRTPRT_REG        (DR_REG_SDMMC_BASE + 0x54)
-#define SDMMC_GPIO_REG          (DR_REG_SDMMC_BASE + 0x58)
-#define SDMMC_TCBCNT_REG        (DR_REG_SDMMC_BASE + 0x5c)
-#define SDMMC_TBBCNT_REG        (DR_REG_SDMMC_BASE + 0x60)
-#define SDMMC_DEBNCE_REG        (DR_REG_SDMMC_BASE + 0x64)
-#define SDMMC_USRID_REG         (DR_REG_SDMMC_BASE + 0x68)
-#define SDMMC_VERID_REG         (DR_REG_SDMMC_BASE + 0x6c)
-#define SDMMC_HCON_REG          (DR_REG_SDMMC_BASE + 0x70)
-#define SDMMC_UHS_REG_REG       (DR_REG_SDMMC_BASE + 0x74)
-#define SDMMC_RST_N_REG         (DR_REG_SDMMC_BASE + 0x78)
-#define SDMMC_BMOD_REG          (DR_REG_SDMMC_BASE + 0x80)
-#define SDMMC_PLDMND_REG        (DR_REG_SDMMC_BASE + 0x84)
-#define SDMMC_DBADDR_REG        (DR_REG_SDMMC_BASE + 0x88)
-#define SDMMC_DBADDRU_REG       (DR_REG_SDMMC_BASE + 0x8c)
-#define SDMMC_IDSTS_REG         (DR_REG_SDMMC_BASE + 0x8c)
-#define SDMMC_IDINTEN_REG       (DR_REG_SDMMC_BASE + 0x90)
-#define SDMMC_DSCADDR_REG       (DR_REG_SDMMC_BASE + 0x94)
-#define SDMMC_DSCADDRL_REG      (DR_REG_SDMMC_BASE + 0x98)
-#define SDMMC_DSCADDRU_REG      (DR_REG_SDMMC_BASE + 0x9c)
-#define SDMMC_BUFADDRL_REG      (DR_REG_SDMMC_BASE + 0xa0)
-#define SDMMC_BUFADDRU_REG      (DR_REG_SDMMC_BASE + 0xa4)
-#define SDMMC_CARDTHRCTL_REG    (DR_REG_SDMMC_BASE + 0x100)
-#define SDMMC_BACK_END_POWER_REG    (DR_REG_SDMMC_BASE + 0x104)
-#define SDMMC_UHS_REG_EXT_REG   (DR_REG_SDMMC_BASE + 0x108)
-#define SDMMC_EMMC_DDR_REG_REG  (DR_REG_SDMMC_BASE + 0x10c)
-#define SDMMC_ENABLE_SHIFT_REG  (DR_REG_SDMMC_BASE + 0x110)
-
-#define SDMMC_CLOCK_REG         (DR_REG_SDMMC_BASE + 0x800)
-
-#define SDMMC_INTMASK_IO_SLOT1  BIT(17)
-#define SDMMC_INTMASK_IO_SLOT0  BIT(16)
-#define SDMMC_INTMASK_EBE       BIT(15)
-#define SDMMC_INTMASK_ACD       BIT(14)
-#define SDMMC_INTMASK_SBE       BIT(13)
-#define SDMMC_INTMASK_HLE       BIT(12)
-#define SDMMC_INTMASK_FRUN      BIT(11)
-#define SDMMC_INTMASK_HTO       BIT(10)
-#define SDMMC_INTMASK_DTO       BIT(9)
-#define SDMMC_INTMASK_RTO       BIT(8)
-#define SDMMC_INTMASK_DCRC      BIT(7)
-#define SDMMC_INTMASK_RCRC      BIT(6)
-#define SDMMC_INTMASK_RXDR      BIT(5)
-#define SDMMC_INTMASK_TXDR      BIT(4)
-#define SDMMC_INTMASK_DATA_OVER BIT(3)
-#define SDMMC_INTMASK_CMD_DONE  BIT(2)
-#define SDMMC_INTMASK_RESP_ERR  BIT(1)
-#define SDMMC_INTMASK_CD        BIT(0)
-
-#define SDMMC_IDMAC_INTMASK_AI  BIT(9)
-#define SDMMC_IDMAC_INTMASK_NI  BIT(8)
-#define SDMMC_IDMAC_INTMASK_CES BIT(5)
-#define SDMMC_IDMAC_INTMASK_DU  BIT(4)
-#define SDMMC_IDMAC_INTMASK_FBE BIT(2)
-#define SDMMC_IDMAC_INTMASK_RI  BIT(1)
-#define SDMMC_IDMAC_INTMASK_TI  BIT(0)
-
-#endif /* _SOC_SDMMC_REG_H_  */
diff --git a/components/soc/esp32s2/include/soc/sdmmc_struct.h b/components/soc/esp32s2/include/soc/sdmmc_struct.h
deleted file mode 100644
index 7e3c6912eb..0000000000
--- a/components/soc/esp32s2/include/soc/sdmmc_struct.h
+++ /dev/null
@@ -1,377 +0,0 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-#ifndef _SOC_SDMMC_STRUCT_H_
-#define _SOC_SDMMC_STRUCT_H_
-
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct {
-    uint32_t reserved1: 1;
-    uint32_t disable_int_on_completion: 1;
-    uint32_t last_descriptor: 1;
-    uint32_t first_descriptor: 1;
-    uint32_t second_address_chained: 1;
-    uint32_t end_of_ring: 1;
-    uint32_t reserved2: 24;
-    uint32_t card_error_summary: 1;
-    uint32_t owned_by_idmac: 1;
-    uint32_t buffer1_size: 13;
-    uint32_t buffer2_size: 13;
-    uint32_t reserved3: 6;
-    void* buffer1_ptr;
-    union {
-        void* buffer2_ptr;
-        void* next_desc_ptr;
-    };
-} sdmmc_desc_t;
-
-#define SDMMC_DMA_MAX_BUF_LEN 4096
-
-_Static_assert(sizeof(sdmmc_desc_t) == 16, "invalid size of sdmmc_desc_t structure");
-
-
-typedef struct {
-    uint32_t cmd_index: 6;          ///< Command index
-    uint32_t response_expect: 1;    ///< set if response is expected
-    uint32_t response_long: 1;      ///< 0: short response expected, 1: long response expected
-    uint32_t check_response_crc: 1; ///< set if controller should check response CRC
-    uint32_t data_expected: 1;      ///< 0: no data expected, 1: data expected
-    uint32_t rw: 1;                 ///< 0: read from card, 1: write to card (don't care if no data expected)
-    uint32_t stream_mode: 1;        ///< 0: block transfer, 1: stream transfer (don't care if no data expected)
-    uint32_t send_auto_stop: 1;     ///< set to send stop at the end of the transfer
-    uint32_t wait_complete: 1;      ///< 0: send command at once, 1: wait for previous command to complete
-    uint32_t stop_abort_cmd: 1;     ///< set if this is a stop or abort command intended to stop current transfer
-    uint32_t send_init: 1;          ///< set to send init sequence (80 clocks of 1)
-    uint32_t card_num: 5;           ///< card number
-    uint32_t update_clk_reg: 1;     ///< 0: normal command, 1: don't send command, just update clock registers
-    uint32_t read_ceata: 1;         ///< set if performing read from CE-ATA device
-    uint32_t ccs_expected: 1;       ///< set if CCS is expected from CE-ATA device
-    uint32_t enable_boot: 1;        ///< set for mandatory boot mode
-    uint32_t expect_boot_ack: 1;    ///< when set along with enable_boot, controller expects boot ack pattern
-    uint32_t disable_boot: 1;       ///< set to terminate boot operation (don't set along with enable_boot)
-    uint32_t boot_mode: 1;          ///< 0: mandatory boot operation, 1: alternate boot operation
-    uint32_t volt_switch: 1;        ///< set to enable voltage switching (for CMD11 only)
-    uint32_t use_hold_reg: 1;       ///< clear to bypass HOLD register
-    uint32_t reserved: 1;
-    uint32_t start_command: 1;      ///< Start command; once command is sent to the card, bit is cleared.
-} sdmmc_hw_cmd_t;  ///< command format used in cmd register; this structure is defined to make it easier to build command values
-
-_Static_assert(sizeof(sdmmc_hw_cmd_t) == 4, "invalid size of sdmmc_cmd_t structure");
-
-
-typedef volatile struct {
-    union {
-        struct {
-            uint32_t controller_reset: 1;
-            uint32_t fifo_reset: 1;
-            uint32_t dma_reset: 1;
-            uint32_t reserved1: 1;
-            uint32_t int_enable: 1;
-            uint32_t dma_enable: 1;
-            uint32_t read_wait: 1;
-            uint32_t send_irq_response: 1;
-            uint32_t abort_read_data: 1;
-            uint32_t send_ccsd: 1;
-            uint32_t send_auto_stop_ccsd: 1;
-            uint32_t ceata_device_interrupt_status: 1;
-            uint32_t reserved2: 4;
-            uint32_t card_voltage_a: 4;
-            uint32_t card_voltage_b: 4;
-            uint32_t enable_od_pullup: 1;
-            uint32_t use_internal_dma: 1;
-            uint32_t reserved3: 6;
-        };
-        uint32_t val;
-    } ctrl;
-
-    uint32_t pwren;             ///< 1: enable power to card, 0: disable power to card
-
-    union {
-        struct {
-            uint32_t div0: 8;   ///< 0: bypass, 1-255: divide clock by (2*div0).
-            uint32_t div1: 8;   ///< 0: bypass, 1-255: divide clock by (2*div0).
-            uint32_t div2: 8;   ///< 0: bypass, 1-255: divide clock by (2*div0).
-            uint32_t div3: 8;   ///< 0: bypass, 1-255: divide clock by (2*div0).
-        };
-        uint32_t val;
-    } clkdiv;
-
-    union {
-        struct {
-            uint32_t card0: 2;            ///< 0-3: select clock divider for card 0 among div0-div3
-            uint32_t card1: 2;            ///< 0-3: select clock divider for card 1 among div0-div3
-            uint32_t reserved: 28;
-        };
-        uint32_t val;
-    } clksrc;
-
-    union {
-        struct {
-            uint32_t cclk_enable: 16;       ///< 1: enable clock to card, 0: disable clock
-            uint32_t cclk_low_power: 16;    ///< 1: enable clock gating when card is idle, 0: disable clock gating
-        };
-        uint32_t val;
-    } clkena;
-
-    union {
-        struct {
-            uint32_t response: 8;       ///< response timeout, in card output clock cycles
-            uint32_t data: 24;          ///< data read timeout, in card output clock cycles
-        };
-        uint32_t val;
-    } tmout;
-
-    union {
-        struct {
-            uint32_t card_width: 16;    ///< one bit for each card: 0: 1-bit mode, 1: 4-bit mode
-            uint32_t card_width_8: 16;  ///< one bit for each card: 0: not 8-bit mode (corresponding card_width bit is used), 1: 8-bit mode (card_width bit is ignored)
-        };
-        uint32_t val;
-    } ctype;
-
-    uint32_t blksiz: 16;        ///< block size, default 0x200
-    uint32_t : 16;
-
-    uint32_t bytcnt;            ///< number of bytes to be transferred
-
-    union {
-        struct {
-            uint32_t cd: 1;             ///< Card detect interrupt enable
-            uint32_t re: 1;             ///< Response error interrupt enable
-            uint32_t cmd_done: 1;       ///< Command done interrupt enable
-            uint32_t dto: 1;            ///< Data transfer over interrupt enable
-            uint32_t txdr: 1;           ///< Transmit FIFO data request interrupt enable
-            uint32_t rxdr: 1;           ///< Receive FIFO data request interrupt enable
-            uint32_t rcrc: 1;           ///< Response CRC error interrupt enable
-            uint32_t dcrc: 1;           ///< Data CRC error interrupt enable
-            uint32_t rto: 1;            ///< Response timeout interrupt enable
-            uint32_t drto: 1;           ///< Data read timeout interrupt enable
-            uint32_t hto: 1;            ///< Data starvation-by-host timeout interrupt enable
-            uint32_t frun: 1;           ///< FIFO underrun/overrun error interrupt enable
-            uint32_t hle: 1;            ///< Hardware locked write error interrupt enable
-            uint32_t sbi_bci: 1;        ///< Start bit error / busy clear interrupt enable
-            uint32_t acd: 1;            ///< Auto command done interrupt enable
-            uint32_t ebe: 1;            ///< End bit error / write no CRC interrupt enable
-            uint32_t sdio: 16;          ///< SDIO interrupt enable
-        };
-        uint32_t val;
-    } intmask;
-
-    uint32_t cmdarg;        ///< Command argument to be passed to card
-
-    sdmmc_hw_cmd_t cmd;
-
-    uint32_t resp[4];           ///< Response from card
-
-    union {
-        struct {
-            uint32_t cd: 1;             ///< Card detect interrupt masked status
-            uint32_t re: 1;             ///< Response error interrupt masked status
-            uint32_t cmd_done: 1;       ///< Command done interrupt masked status
-            uint32_t dto: 1;            ///< Data transfer over interrupt masked status
-            uint32_t txdr: 1;           ///< Transmit FIFO data request interrupt masked status
-            uint32_t rxdr: 1;           ///< Receive FIFO data request interrupt masked status
-            uint32_t rcrc: 1;           ///< Response CRC error interrupt masked status
-            uint32_t dcrc: 1;           ///< Data CRC error interrupt masked status
-            uint32_t rto: 1;            ///< Response timeout interrupt masked status
-            uint32_t drto: 1;           ///< Data read timeout interrupt masked status
-            uint32_t hto: 1;            ///< Data starvation-by-host timeout interrupt masked status
-            uint32_t frun: 1;           ///< FIFO underrun/overrun error interrupt masked status
-            uint32_t hle: 1;            ///< Hardware locked write error interrupt masked status
-            uint32_t sbi_bci: 1;        ///< Start bit error / busy clear interrupt masked status
-            uint32_t acd: 1;            ///< Auto command done interrupt masked status
-            uint32_t ebe: 1;            ///< End bit error / write no CRC interrupt masked status
-            uint32_t sdio: 16;          ///< SDIO interrupt masked status
-        };
-        uint32_t val;
-    } mintsts;
-
-    union {
-        struct {
-            uint32_t cd: 1;             ///< Card detect raw interrupt status
-            uint32_t re: 1;             ///< Response error raw interrupt status
-            uint32_t cmd_done: 1;       ///< Command done raw interrupt status
-            uint32_t dto: 1;            ///< Data transfer over raw interrupt status
-            uint32_t txdr: 1;           ///< Transmit FIFO data request raw interrupt status
-            uint32_t rxdr: 1;           ///< Receive FIFO data request raw interrupt status
-            uint32_t rcrc: 1;           ///< Response CRC error raw interrupt status
-            uint32_t dcrc: 1;           ///< Data CRC error raw interrupt status
-            uint32_t rto: 1;            ///< Response timeout raw interrupt status
-            uint32_t drto: 1;           ///< Data read timeout raw interrupt status
-            uint32_t hto: 1;            ///< Data starvation-by-host timeout raw interrupt status
-            uint32_t frun: 1;           ///< FIFO underrun/overrun error raw interrupt status
-            uint32_t hle: 1;            ///< Hardware locked write error raw interrupt status
-            uint32_t sbi_bci: 1;        ///< Start bit error / busy clear raw interrupt status
-            uint32_t acd: 1;            ///< Auto command done raw interrupt status
-            uint32_t ebe: 1;            ///< End bit error / write no CRC raw interrupt status
-            uint32_t sdio: 16;          ///< SDIO raw interrupt status
-        };
-        uint32_t val;
-    } rintsts;                          ///< interrupts can be cleared by writing this register
-
-    union {
-        struct {
-            uint32_t fifo_rx_watermark: 1;  ///< FIFO reached receive watermark level
-            uint32_t fifo_tx_watermark: 1;  ///< FIFO reached transmit watermark level
-            uint32_t fifo_empty: 1;         ///< FIFO is empty
-            uint32_t fifo_full: 1;          ///< FIFO is full
-            uint32_t cmd_fsm_state: 4;      ///< command FSM state
-            uint32_t data3_status: 1;       ///< this bit reads 1 if card is present
-            uint32_t data_busy: 1;          ///< this bit reads 1 if card is busy
-            uint32_t data_fsm_busy: 1;      ///< this bit reads 1 if transmit/receive FSM is busy
-            uint32_t response_index: 6;     ///< index of the previous response
-            uint32_t fifo_count: 13;        ///< number of filled locations in the FIFO
-            uint32_t dma_ack: 1;            ///< DMA acknowledge signal
-            uint32_t dma_req: 1;            ///< DMA request signal
-        };
-        uint32_t val;
-    } status;
-
-    union {
-        struct {
-            uint32_t tx_watermark: 12;      ///< FIFO TX watermark level
-            uint32_t reserved1: 4;
-            uint32_t rx_watermark: 12;      ///< FIFO RX watermark level
-            uint32_t dw_dma_mts: 3;
-            uint32_t reserved2: 1;
-        };
-        uint32_t val;
-    } fifoth;
-
-    union {
-        struct {
-            uint32_t cards: 2;              ///< bit N reads 0 if card N is present
-            uint32_t reserved: 30;
-        };
-        uint32_t val;
-    } cdetect;
-
-    union {
-        struct {
-            uint32_t cards: 2;              ///< bit N reads 1 if card N is write protected
-            uint32_t reserved: 30;
-        };
-        uint32_t val;
-    } wrtprt;
-
-    uint32_t gpio;      ///< unused
-    uint32_t tcbcnt;    ///< transferred (to card) byte count
-    uint32_t tbbcnt;    ///< transferred from host to FIFO byte count
-
-    union {
-        struct {
-            uint32_t debounce_count: 24;    ///< number of host cycles used by debounce filter, typical time should be 5-25ms
-            uint32_t reserved: 8;
-        };
-    } debnce;
-
-    uint32_t usrid;     ///< user ID
-    uint32_t verid;     ///< IP block version
-    uint32_t hcon;      ///< compile-time IP configuration
-    uint32_t uhs;       ///< TBD
-
-    union {
-        struct {
-            uint32_t cards: 2;          ///< bit N resets card N, active low
-            uint32_t reserved: 30;
-        };
-    } rst_n;
-
-    uint32_t reserved_7c;
-
-    union {
-        struct {
-            uint32_t sw_reset: 1;       ///< set to reset DMA controller
-            uint32_t fb: 1;             ///< set if AHB master performs fixed burst transfers
-            uint32_t dsl: 5;            ///< descriptor skip length: number of words to skip between two unchained descriptors
-            uint32_t enable: 1;         ///< set to enable IDMAC
-            uint32_t pbl: 3;            ///< programmable burst length
-            uint32_t reserved: 21;
-        };
-        uint32_t val;
-    } bmod;
-
-    uint32_t pldmnd;                    ///< set any bit to resume IDMAC FSM from suspended state
-    sdmmc_desc_t* dbaddr;        ///< descriptor list base
-
-    union {
-        struct {
-            uint32_t ti: 1;         ///< transmit interrupt status
-            uint32_t ri: 1;         ///< receive interrupt status
-            uint32_t fbe: 1;        ///< fatal bus error
-            uint32_t reserved1: 1;
-            uint32_t du: 1;         ///< descriptor unavailable
-            uint32_t ces: 1;        ///< card error summary
-            uint32_t reserved2: 2;
-            uint32_t nis: 1;        ///< normal interrupt summary
-            uint32_t fbe_code: 3;   ///< code of fatal bus error
-            uint32_t fsm: 4;        ///< DMAC FSM state
-            uint32_t reserved3: 15;
-        };
-        uint32_t val;
-    } idsts;
-
-    union {
-        struct {
-            uint32_t ti: 1;         ///< transmit interrupt enable
-            uint32_t ri: 1;         ///< receive interrupt enable
-            uint32_t fbe: 1;        ///< fatal bus error interrupt enable
-            uint32_t reserved1: 1;
-            uint32_t du: 1;         ///< descriptor unavailable interrupt enable
-            uint32_t ces: 1;        ///< card error interrupt enable
-            uint32_t reserved2: 2;
-            uint32_t ni: 1;         ///< normal interrupt interrupt enable
-            uint32_t ai: 1;         ///< abnormal interrupt enable
-            uint32_t reserved3: 22;
-        };
-        uint32_t val;
-    } idinten;
-
-    uint32_t dscaddr;       ///< current host descriptor address
-    uint32_t dscaddrl;      ///< unused
-    uint32_t dscaddru;      ///< unused
-    uint32_t bufaddrl;      ///< unused
-    uint32_t bufaddru;      ///< unused
-    uint32_t reserved_a8[22];
-    uint32_t cardthrctl;
-    uint32_t back_end_power;
-    uint32_t uhs_reg_ext;
-    uint32_t emmc_ddr_reg;
-    uint32_t enable_shift;
-    uint32_t reserved_114[443];
-    union {
-        struct {
-            uint32_t phase_dout: 3;         ///< phase of data output clock (0x0: 0, 0x1: 90, 0x4: 180, 0x6: 270)
-            uint32_t phase_din: 3;          ///< phase of data input clock
-            uint32_t phase_core: 3;         ///< phase of the clock to SDMMC peripheral
-            uint32_t div_factor_p: 4;       ///< controls clock period; it will be (div_factor_p + 1) / 160MHz
-            uint32_t div_factor_h: 4;       ///< controls length of high pulse; it will be (div_factor_h + 1) / 160MHz
-            uint32_t div_factor_m: 4;       ///< should be equal to div_factor_p
-        };
-        uint32_t val;
-    } clock;
-} sdmmc_dev_t;
-extern sdmmc_dev_t SDMMC;
-
-_Static_assert(sizeof(sdmmc_dev_t) == 0x804, "invalid size of sdmmc_dev_t structure");
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif //_SOC_SDMMC_STRUCT_H_
-- 
2.25.1


From 17c65dad272885c5cc03db56525dcd0bcc82b609 Mon Sep 17 00:00:00 2001
From: Ivan Grokhotkov <ivan@espressif.com>
Date: Mon, 4 Jan 2021 20:34:31 +0100
Subject: [PATCH 04/43] soc: add esp32s3 sdmmc support

* sync the latest struct header file from ESP32
* add soc_caps.h macros to distinguish between IO MUX and GPIO Matrix
  support in SDMMC on different chips.
* store GPIO matrix signal numbers in sdmmc_slot_info_t
---
 components/esp32s3/ld/esp32s3.peripherals.ld  |  1 +
 components/soc/esp32/include/soc/soc_caps.h   |  8 +++
 components/soc/esp32/sdmmc_periph.c           | 53 +++++++++--------
 .../soc/esp32s3/include/soc/sdmmc_pins.h      | 22 +------
 .../soc/esp32s3/include/soc/sdmmc_struct.h    | 34 ++++++++---
 components/soc/esp32s3/include/soc/soc_caps.h | 11 ++++
 components/soc/esp32s3/sdmmc_periph.c         | 53 +++++++++--------
 components/soc/include/soc/sdmmc_periph.h     | 58 ++++++++++++++-----
 8 files changed, 150 insertions(+), 90 deletions(-)

diff --git a/components/esp32s3/ld/esp32s3.peripherals.ld b/components/esp32s3/ld/esp32s3.peripherals.ld
index 5e0188ee9a..4df638a025 100644
--- a/components/esp32s3/ld/esp32s3.peripherals.ld
+++ b/components/esp32s3/ld/esp32s3.peripherals.ld
@@ -28,6 +28,7 @@ PROVIDE ( GPSPI2  = 0x60024000 );
 PROVIDE ( GPSPI3  = 0x60025000 );
 PROVIDE ( SYSCON = 0x60026000 );
 PROVIDE ( I2C1 = 0x60027000 );
+PROVIDE ( SDMMC = 0x60028000 );
 PROVIDE ( TWAI = 0x6002B000 );
 PROVIDE ( GPSPI4 = 0x60037000 );
 PROVIDE ( GDMA = 0x6003F000 );
diff --git a/components/soc/esp32/include/soc/soc_caps.h b/components/soc/esp32/include/soc/soc_caps.h
index 4fd8632706..2031df36ee 100644
--- a/components/soc/esp32/include/soc/soc_caps.h
+++ b/components/soc/esp32/include/soc/soc_caps.h
@@ -282,3 +282,11 @@
 #  define CAN_BRP_DIV_SUPPORTED             SOC_TWAI_BRP_DIV_SUPPORTED
 #  define CAN_BRP_DIV_THRESH                SOC_TWAI_BRP_DIV_THRESH
 #endif
+
+/*-------------------------- SDMMC CAPS -----------------------------------------*/
+
+/* On ESP32, clock/cmd/data pins use IO MUX.
+ * Card detect, write protect, interrupt use GPIO Matrix on all chips.
+ */
+#define SOC_SDMMC_USE_IOMUX  1
+#define SOC_SDMMC_NUM_SLOTS  2
diff --git a/components/soc/esp32/sdmmc_periph.c b/components/soc/esp32/sdmmc_periph.c
index db3af78203..9b98bffcbb 100644
--- a/components/soc/esp32/sdmmc_periph.c
+++ b/components/soc/esp32/sdmmc_periph.c
@@ -14,37 +14,44 @@
 
 #include "soc/sdmmc_periph.h"
 
-const sdmmc_slot_info_t sdmmc_slot_info[2]  = {
+const sdmmc_slot_info_t sdmmc_slot_info[SOC_SDMMC_NUM_SLOTS] = {
     {
-        .clk_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_CLK,
-        .cmd_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_CMD,
-        .d0_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_D0,
-        .d1_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_D1,
-        .d2_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_D2,
-        .d3_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_D3,
-        .d4_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_D4,
-        .d5_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_D5,
-        .d6_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_D6,
-        .d7_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_D7,
+        .width = 8,
         .card_detect = HOST_CARD_DETECT_N_1_IDX,
         .write_protect = HOST_CARD_WRITE_PRT_1_IDX,
         .card_int = HOST_CARD_INT_N_1_IDX,
-        .width = 8
     },
     {
-        .clk_gpio = SDMMC_SLOT1_IOMUX_PIN_NUM_CLK,
-        .cmd_gpio = SDMMC_SLOT1_IOMUX_PIN_NUM_CMD,
-        .d0_gpio = SDMMC_SLOT1_IOMUX_PIN_NUM_D0,
-        .d1_gpio = SDMMC_SLOT1_IOMUX_PIN_NUM_D1,
-        .d2_gpio = SDMMC_SLOT1_IOMUX_PIN_NUM_D2,
-        .d3_gpio = SDMMC_SLOT1_IOMUX_PIN_NUM_D3,
-        .d4_gpio = -1,  //slot1 has no D4-7
-        .d5_gpio = -1,
-        .d6_gpio = -1,
-        .d7_gpio = -1,
+        .width = 4,
         .card_detect = HOST_CARD_DETECT_N_2_IDX,
         .write_protect = HOST_CARD_WRITE_PRT_2_IDX,
         .card_int = HOST_CARD_INT_N_2_IDX,
-        .width = 4
+    }
+};
+
+const sdmmc_slot_io_info_t sdmmc_slot_gpio_num[SOC_SDMMC_NUM_SLOTS] = {
+    {
+        .clk = SDMMC_SLOT0_IOMUX_PIN_NUM_CLK,
+        .cmd = SDMMC_SLOT0_IOMUX_PIN_NUM_CMD,
+        .d0 = SDMMC_SLOT0_IOMUX_PIN_NUM_D0,
+        .d1 = SDMMC_SLOT0_IOMUX_PIN_NUM_D1,
+        .d2 = SDMMC_SLOT0_IOMUX_PIN_NUM_D2,
+        .d3 = SDMMC_SLOT0_IOMUX_PIN_NUM_D3,
+        .d4 = SDMMC_SLOT0_IOMUX_PIN_NUM_D4,
+        .d5 = SDMMC_SLOT0_IOMUX_PIN_NUM_D5,
+        .d6 = SDMMC_SLOT0_IOMUX_PIN_NUM_D6,
+        .d7 = SDMMC_SLOT0_IOMUX_PIN_NUM_D7,
+    },
+    {
+        .clk = SDMMC_SLOT1_IOMUX_PIN_NUM_CLK,
+        .cmd = SDMMC_SLOT1_IOMUX_PIN_NUM_CMD,
+        .d0 = SDMMC_SLOT1_IOMUX_PIN_NUM_D0,
+        .d1 = SDMMC_SLOT1_IOMUX_PIN_NUM_D1,
+        .d2 = SDMMC_SLOT1_IOMUX_PIN_NUM_D2,
+        .d3 = SDMMC_SLOT1_IOMUX_PIN_NUM_D3,
+        .d4 = -1,  //slot1 has no D4-7
+        .d5 = -1,
+        .d6 = -1,
+        .d7 = -1,
     }
 };
diff --git a/components/soc/esp32s3/include/soc/sdmmc_pins.h b/components/soc/esp32s3/include/soc/sdmmc_pins.h
index b279793b6d..107bbf94ad 100644
--- a/components/soc/esp32s3/include/soc/sdmmc_pins.h
+++ b/components/soc/esp32s3/include/soc/sdmmc_pins.h
@@ -14,22 +14,6 @@
 
 #pragma once
 
-#define SDMMC_SLOT0_IOMUX_PIN_NUM_CLK  6
-#define SDMMC_SLOT0_IOMUX_PIN_NUM_CMD  11
-#define SDMMC_SLOT0_IOMUX_PIN_NUM_D0   7
-#define SDMMC_SLOT0_IOMUX_PIN_NUM_D1   8
-#define SDMMC_SLOT0_IOMUX_PIN_NUM_D2   9
-#define SDMMC_SLOT0_IOMUX_PIN_NUM_D3   10
-#define SDMMC_SLOT0_IOMUX_PIN_NUM_D4   16
-#define SDMMC_SLOT0_IOMUX_PIN_NUM_D5   17
-#define SDMMC_SLOT0_IOMUX_PIN_NUM_D6   5
-#define SDMMC_SLOT0_IOMUX_PIN_NUM_D7   18
-#define SDMMC_SLOT0_FUNC               0
-
-#define SDMMC_SLOT1_IOMUX_PIN_NUM_CLK  14
-#define SDMMC_SLOT1_IOMUX_PIN_NUM_CMD  15
-#define SDMMC_SLOT1_IOMUX_PIN_NUM_D0   2
-#define SDMMC_SLOT1_IOMUX_PIN_NUM_D1   4
-#define SDMMC_SLOT1_IOMUX_PIN_NUM_D2   12
-#define SDMMC_SLOT1_IOMUX_PIN_NUM_D3   13
-#define SDMMC_SLOT1_FUNC               4
+/* SDMMC pins on ESP32-S3 are configurable through GPIO matrix.
+ * This file is kept for compatibility only.
+ */
diff --git a/components/soc/esp32s3/include/soc/sdmmc_struct.h b/components/soc/esp32s3/include/soc/sdmmc_struct.h
index dc4e65df0c..6f5eef66ec 100644
--- a/components/soc/esp32s3/include/soc/sdmmc_struct.h
+++ b/components/soc/esp32s3/include/soc/sdmmc_struct.h
@@ -19,7 +19,7 @@
 extern "C" {
 #endif
 
-typedef struct {
+typedef struct sdmmc_desc_s {
     uint32_t reserved1: 1;
     uint32_t disable_int_on_completion: 1;
     uint32_t last_descriptor: 1;
@@ -32,10 +32,10 @@ typedef struct {
     uint32_t buffer1_size: 13;
     uint32_t buffer2_size: 13;
     uint32_t reserved3: 6;
-    void *buffer1_ptr;
+    void* buffer1_ptr;
     union {
-        void *buffer2_ptr;
-        void *next_desc_ptr;
+        void* buffer2_ptr;
+        void* next_desc_ptr;
     };
 } sdmmc_desc_t;
 
@@ -44,7 +44,7 @@ typedef struct {
 _Static_assert(sizeof(sdmmc_desc_t) == 16, "invalid size of sdmmc_desc_t structure");
 
 
-typedef struct {
+typedef struct sdmmc_hw_cmd_s {
     uint32_t cmd_index: 6;          ///< Command index
     uint32_t response_expect: 1;    ///< set if response is expected
     uint32_t response_long: 1;      ///< 0: short response expected, 1: long response expected
@@ -73,7 +73,7 @@ typedef struct {
 _Static_assert(sizeof(sdmmc_hw_cmd_t) == 4, "invalid size of sdmmc_cmd_t structure");
 
 
-typedef volatile struct {
+typedef volatile struct sdmmc_dev_s {
     union {
         struct {
             uint32_t controller_reset: 1;
@@ -282,7 +282,12 @@ typedef volatile struct {
     uint32_t usrid;     ///< user ID
     uint32_t verid;     ///< IP block version
     uint32_t hcon;      ///< compile-time IP configuration
-    uint32_t uhs;       ///< TBD
+    union {
+        struct {
+            uint32_t voltage: 16;           ///< voltage control for slots; no-op on ESP32.
+            uint32_t ddr: 16;                ///< bit N enables DDR mode for card N
+        };
+    } uhs;              ///< UHS related settings
 
     union {
         struct {
@@ -306,7 +311,7 @@ typedef volatile struct {
     } bmod;
 
     uint32_t pldmnd;                    ///< set any bit to resume IDMAC FSM from suspended state
-    sdmmc_desc_t *dbaddr;        ///< descriptor list base
+    sdmmc_desc_t* dbaddr;        ///< descriptor list base
 
     union {
         struct {
@@ -347,7 +352,16 @@ typedef volatile struct {
     uint32_t bufaddrl;      ///< unused
     uint32_t bufaddru;      ///< unused
     uint32_t reserved_a8[22];
-    uint32_t cardthrctl;
+    union {
+        struct {
+            uint32_t read_thr_en : 1;       ///< initiate transfer only if FIFO has more space than the read threshold
+            uint32_t busy_clr_int_en : 1;   ///< enable generation of busy clear interrupts
+            uint32_t write_thr_en : 1;      ///< equivalent of read_thr_en for writes
+            uint32_t reserved1 : 13;
+            uint32_t card_threshold : 12;   ///< threshold value for reads/writes, in bytes
+        };
+        uint32_t val;
+    } cardthrctl;
     uint32_t back_end_power;
     uint32_t uhs_reg_ext;
     uint32_t emmc_ddr_reg;
@@ -361,6 +375,8 @@ typedef volatile struct {
             uint32_t div_factor_p: 4;       ///< controls clock period; it will be (div_factor_p + 1) / 160MHz
             uint32_t div_factor_h: 4;       ///< controls length of high pulse; it will be (div_factor_h + 1) / 160MHz
             uint32_t div_factor_m: 4;       ///< should be equal to div_factor_p
+            uint32_t reserved1 : 2;
+            uint32_t clk_sel : 1;           ///< clock source select (0: XTAL, 1: 160 MHz from PLL)
         };
         uint32_t val;
     } clock;
diff --git a/components/soc/esp32s3/include/soc/soc_caps.h b/components/soc/esp32s3/include/soc/soc_caps.h
index 231057f879..307e960c18 100644
--- a/components/soc/esp32s3/include/soc/soc_caps.h
+++ b/components/soc/esp32s3/include/soc/soc_caps.h
@@ -21,6 +21,7 @@
 #define SOC_HMAC_SUPPORTED              1
 #define SOC_ASYNC_MEMCPY_SUPPORTED      1
 #define SOC_EFUSE_SECURE_BOOT_KEY_DIGESTS 3
+#define SOC_SDMMC_HOST_SUPPORTED        1
 
 
 /*-------------------------- ADC CAPS ----------------------------------------*/
@@ -214,3 +215,13 @@
 #define SOC_SPI_MEM_SUPPORT_SW_SUSPEND                    (1)
 /*-------------------------- COEXISTENCE HARDWARE PTI CAPS -------------------------------*/
 #define SOC_COEX_HW_PTI                 (1)
+
+/*-------------------------- SDMMC CAPS -----------------------------------------*/
+
+/* Card detect, write protect, interrupt use GPIO Matrix on all chips.
+ * On ESP32-S3, clock/cmd/data pins use GPIO Matrix as well.
+ */
+#define SOC_SDMMC_USE_GPIO_MATRIX  1
+#define SOC_SDMMC_NUM_SLOTS        2
+/* Indicates that there is an option to use XTAL clock instead of PLL for SDMMC */
+#define SOC_SDMMC_SUPPORT_XTAL_CLOCK    1
diff --git a/components/soc/esp32s3/sdmmc_periph.c b/components/soc/esp32s3/sdmmc_periph.c
index 4bf7c14db8..0d9d9621ff 100644
--- a/components/soc/esp32s3/sdmmc_periph.c
+++ b/components/soc/esp32s3/sdmmc_periph.c
@@ -14,37 +14,44 @@
 
 #include "soc/sdmmc_periph.h"
 
-const sdmmc_slot_info_t sdmmc_slot_info[2]  = {
+const sdmmc_slot_info_t sdmmc_slot_info[SOC_SDMMC_NUM_SLOTS] = {
     {
-        .clk_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_CLK,
-        .cmd_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_CMD,
-        .d0_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_D0,
-        .d1_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_D1,
-        .d2_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_D2,
-        .d3_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_D3,
-        .d4_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_D4,
-        .d5_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_D5,
-        .d6_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_D6,
-        .d7_gpio = SDMMC_SLOT0_IOMUX_PIN_NUM_D7,
+        .width = 8,
         .card_detect = SDHOST_CARD_DETECT_N_1_IDX,
         .write_protect = SDHOST_CARD_WRITE_PRT_1_IDX,
         .card_int = SDHOST_CARD_INT_N_1_IDX,
-        .width = 8
     },
     {
-        .clk_gpio = SDMMC_SLOT1_IOMUX_PIN_NUM_CLK,
-        .cmd_gpio = SDMMC_SLOT1_IOMUX_PIN_NUM_CMD,
-        .d0_gpio = SDMMC_SLOT1_IOMUX_PIN_NUM_D0,
-        .d1_gpio = SDMMC_SLOT1_IOMUX_PIN_NUM_D1,
-        .d2_gpio = SDMMC_SLOT1_IOMUX_PIN_NUM_D2,
-        .d3_gpio = SDMMC_SLOT1_IOMUX_PIN_NUM_D3,
-        .d4_gpio = -1,  //slot1 has no D4-7
-        .d5_gpio = -1,
-        .d6_gpio = -1,
-        .d7_gpio = -1,
+        .width = 8,
         .card_detect = SDHOST_CARD_DETECT_N_2_IDX,
         .write_protect = SDHOST_CARD_WRITE_PRT_2_IDX,
         .card_int = SDHOST_CARD_INT_N_2_IDX,
-        .width = 4
+    }
+};
+
+const sdmmc_slot_io_info_t sdmmc_slot_gpio_sig[SOC_SDMMC_NUM_SLOTS] = {
+    {
+        .clk = SDHOST_CCLK_OUT_1_IDX,
+        .cmd = SDHOST_CCMD_OUT_1_IDX,
+        .d0 = SDHOST_CDATA_OUT_10_IDX,
+        .d1 = SDHOST_CDATA_OUT_11_IDX,
+        .d2 = SDHOST_CDATA_OUT_12_IDX,
+        .d3 = SDHOST_CDATA_OUT_13_IDX,
+        .d4 = SDHOST_CDATA_OUT_14_IDX,
+        .d5 = SDHOST_CDATA_OUT_15_IDX,
+        .d6 = SDHOST_CDATA_OUT_16_IDX,
+        .d7 = SDHOST_CDATA_OUT_17_IDX,
+    },
+    {
+        .clk = SDHOST_CCLK_OUT_2_IDX,
+        .cmd = SDHOST_CCMD_OUT_2_IDX,
+        .d0 = SDHOST_CDATA_OUT_20_IDX,
+        .d1 = SDHOST_CDATA_OUT_21_IDX,
+        .d2 = SDHOST_CDATA_OUT_22_IDX,
+        .d3 = SDHOST_CDATA_OUT_23_IDX,
+        .d4 = SDHOST_CDATA_OUT_24_IDX,
+        .d5 = SDHOST_CDATA_OUT_25_IDX,
+        .d6 = SDHOST_CDATA_OUT_26_IDX,
+        .d7 = SDHOST_CDATA_OUT_27_IDX,
     }
 };
diff --git a/components/soc/include/soc/sdmmc_periph.h b/components/soc/include/soc/sdmmc_periph.h
index 7a64f4c5fe..c1d38fa29b 100644
--- a/components/soc/include/soc/sdmmc_periph.h
+++ b/components/soc/include/soc/sdmmc_periph.h
@@ -15,6 +15,7 @@
 #pragma once
 #include <stdint.h>
 //include soc related (generated) definitions
+#include "soc/soc_caps.h"
 #include "soc/soc_pins.h"
 #include "soc/sdmmc_reg.h"
 #include "soc/sdmmc_struct.h"
@@ -24,25 +25,50 @@
 extern "C" {
 #endif
 
+/**
+ * Common SDMMC slot info, doesn't depend on SOC_SDMMC_USE_{IOMUX,GPIO_MATRIX}
+ */
 typedef struct {
-    uint8_t clk_gpio;
-    uint8_t cmd_gpio;
-    uint8_t d0_gpio;
-    uint8_t d1_gpio;
-    uint8_t d2_gpio;
-    uint8_t d3_gpio;
-    uint8_t d4_gpio;
-    uint8_t d5_gpio;
-    uint8_t d6_gpio;
-    uint8_t d7_gpio;
-    uint8_t card_detect;
-    uint8_t write_protect;
-    uint8_t card_int;
-    uint8_t width;
+    uint8_t width;          /*!< Maximum supported slot width (1, 4, 8) */
+    uint8_t card_detect;    /*!< Card detect signal in GPIO Matrix */
+    uint8_t write_protect;  /*!< Write protect signal in GPIO Matrix */
+    uint8_t card_int;       /*!< Card interrupt signal in GPIO Matrix */
 } sdmmc_slot_info_t;
 
-/** pin and signal information of each slot */
-extern const sdmmc_slot_info_t sdmmc_slot_info[];
+/** Width and GPIO matrix signal numbers for auxillary SD host signals, one structure per slot */
+extern const sdmmc_slot_info_t sdmmc_slot_info[SOC_SDMMC_NUM_SLOTS];
+
+/**
+ * This structure lists pin numbers (if SOC_SDMMC_USE_IOMUX is set)
+ * or GPIO Matrix signal numbers (if SOC_SDMMC_USE_GPIO_MATRIX is set)
+ * for the SD bus signals. Field names match SD bus signal names.
+ */
+typedef struct {
+    uint8_t clk;
+    uint8_t cmd;
+    uint8_t d0;
+    uint8_t d1;
+    uint8_t d2;
+    uint8_t d3;
+    uint8_t d4;
+    uint8_t d5;
+    uint8_t d6;
+    uint8_t d7;
+} sdmmc_slot_io_info_t;
+
+/* Note: it is in theory possible to have both IOMUX and GPIO Matrix supported
+ * in the same SoC. However this is not used on any SoC at this point, and would
+ * complicate the driver. Hence only one of these options is supported at a time.
+ */
+#if SOC_SDMMC_USE_IOMUX
+/** GPIO pin numbers of SD bus signals, one structure per slot */
+extern const sdmmc_slot_io_info_t sdmmc_slot_gpio_num[SOC_SDMMC_NUM_SLOTS];
+
+#elif SOC_SDMMC_USE_GPIO_MATRIX
+/** GPIO matrix signal numbers of SD bus signals, one structure per slot */
+extern const sdmmc_slot_io_info_t sdmmc_slot_gpio_sig[SOC_SDMMC_NUM_SLOTS];
+
+#endif // SOC_SDMMC_USE_{IOMUX,GPIO_MATRIX}
 
 #ifdef __cplusplus
 }
-- 
2.25.1


From 2c8f413059a143a303ee2ff66e47df13ec38cd37 Mon Sep 17 00:00:00 2001
From: Ivan Grokhotkov <ivan@espressif.com>
Date: Mon, 4 Jan 2021 21:05:27 +0100
Subject: [PATCH 05/43] driver: sdmmc: add esp32s3 support

* Extend sdmmc_slot_config_t with GPIO pin numbers for all SD bus
  signals. These new fields are available if SOC_SDMMC_USE_GPIO_MATRIX
  is set.
* Add shorter "sd" and "wp" aliases for "gpio_sd" and "gpio_wp" field
  names in sdmmc_slot_config_t.
* Deprecate sdmmc_host_pullup_en, prefer to enable this feature using
  SDMMC_SLOT_FLAG_INTERNAL_PULLUP instead.
---
 components/driver/CMakeLists.txt              |   2 +
 components/driver/include/driver/sdmmc_host.h |  59 +++++-
 components/driver/sdmmc_host.c                | 186 +++++++++++++-----
 3 files changed, 192 insertions(+), 55 deletions(-)

diff --git a/components/driver/CMakeLists.txt b/components/driver/CMakeLists.txt
index a39965b633..fcac19fe12 100644
--- a/components/driver/CMakeLists.txt
+++ b/components/driver/CMakeLists.txt
@@ -57,6 +57,8 @@ if(${target} STREQUAL "esp32s3")
     list(APPEND srcs "adc_common.c"
                      "dedic_gpio.c"
                      "gdma.c"
+                     "sdmmc_host.c"
+                     "sdmmc_transaction.c"
                      "spi_slave_hd.c"
                      "touch_sensor_common.c"
                     )
diff --git a/components/driver/include/driver/sdmmc_host.h b/components/driver/include/driver/sdmmc_host.h
index e9da4ae190..e381d4337c 100644
--- a/components/driver/include/driver/sdmmc_host.h
+++ b/components/driver/include/driver/sdmmc_host.h
@@ -59,8 +59,26 @@ extern "C" {
  * Extra configuration for SDMMC peripheral slot
  */
 typedef struct {
-    gpio_num_t gpio_cd;     ///< GPIO number of card detect signal
-    gpio_num_t gpio_wp;     ///< GPIO number of write protect signal
+#ifdef SOC_SDMMC_USE_GPIO_MATRIX
+    gpio_num_t clk;         ///< GPIO number of CLK signal.
+    gpio_num_t cmd;         ///< GPIO number of CMD signal.
+    gpio_num_t d0;          ///< GPIO number of D0 signal.
+    gpio_num_t d1;          ///< GPIO number of D1 signal.
+    gpio_num_t d2;          ///< GPIO number of D2 signal.
+    gpio_num_t d3;          ///< GPIO number of D3 signal.
+    gpio_num_t d4;          ///< GPIO number of D4 signal. Ignored in 1- or 4- line mode.
+    gpio_num_t d5;          ///< GPIO number of D5 signal. Ignored in 1- or 4- line mode.
+    gpio_num_t d6;          ///< GPIO number of D6 signal. Ignored in 1- or 4- line mode.
+    gpio_num_t d7;          ///< GPIO number of D7 signal. Ignored in 1- or 4- line mode.
+#endif // SOC_SDMMC_USE_GPIO_MATRIX
+    union {
+        gpio_num_t gpio_cd;     ///< GPIO number of card detect signal
+        gpio_num_t cd;          ///< GPIO number of card detect signal; shorter name.
+    };
+    union {
+        gpio_num_t gpio_wp;     ///< GPIO number of write protect signal
+        gpio_num_t wp;          ///< GPIO number of write protect signal; shorter name.
+    };
     uint8_t width;          ///< Bus width used by the slot (might be less than the max width supported)
     uint32_t flags;         ///< Features used by this slot
 #define SDMMC_SLOT_FLAG_INTERNAL_PULLUP  BIT(0)
@@ -72,18 +90,44 @@ typedef struct {
 
 #define SDMMC_SLOT_NO_CD      GPIO_NUM_NC     ///< indicates that card detect line is not used
 #define SDMMC_SLOT_NO_WP      GPIO_NUM_NC     ///< indicates that write protect line is not used
-#define SDMMC_SLOT_WIDTH_DEFAULT 0 ///< use the default width for the slot (8 for slot 0, 4 for slot 1)
+#define SDMMC_SLOT_WIDTH_DEFAULT 0 ///< use the maximum possible width for the slot
+
+#ifdef SOC_SDMMC_USE_GPIO_MATRIX
+
+/**
+ * Macro defining default configuration of SDMMC host slot
+ */
+#define SDMMC_SLOT_CONFIG_DEFAULT() {\
+    .clk = GPIO_NUM_14, \
+    .cmd = GPIO_NUM_15, \
+    .d0 = GPIO_NUM_2, \
+    .d1 = GPIO_NUM_4, \
+    .d2 = GPIO_NUM_12, \
+    .d3 = GPIO_NUM_13, \
+    .d4 = GPIO_NUM_33, \
+    .d5 = GPIO_NUM_34, \
+    .d6 = GPIO_NUM_35, \
+    .d7 = GPIO_NUM_36, \
+    .cd = SDMMC_SLOT_NO_CD, \
+    .wp = SDMMC_SLOT_NO_WP, \
+    .width   = SDMMC_SLOT_WIDTH_DEFAULT, \
+    .flags = 0, \
+}
+
+#else // SOC_SDMMC_USE_GPIO_MATRIX
 
 /**
  * Macro defining default configuration of SDMMC host slot
  */
 #define SDMMC_SLOT_CONFIG_DEFAULT() {\
-    .gpio_cd = SDMMC_SLOT_NO_CD, \
-    .gpio_wp = SDMMC_SLOT_NO_WP, \
+    .cd = SDMMC_SLOT_NO_CD, \
+    .wp = SDMMC_SLOT_NO_WP, \
     .width   = SDMMC_SLOT_WIDTH_DEFAULT, \
     .flags = 0, \
 }
 
+#endif // SOC_SDMMC_USE_GPIO_MATRIX
+
 /**
  * @brief Initialize SDMMC host peripheral
  *
@@ -226,6 +270,9 @@ esp_err_t sdmmc_host_deinit(void);
 /**
  * @brief Enable the pull-ups of sd pins.
  *
+ * This function is deprecated. Please set SDMMC_SLOT_FLAG_INTERNAL_PULLUP flag in
+ * sdmmc_slot_config_t::flags instead.
+ *
  * @note You should always place actual pullups on the lines instead of using
  * this function. Internal pullup resistance are high and not sufficient, may
  * cause instability in products. This is for debug or examples only.
@@ -238,7 +285,7 @@ esp_err_t sdmmc_host_deinit(void);
  *      - ESP_ERR_INVALID_ARG: if configured width larger than maximum the slot can
  *              support
  */
-esp_err_t sdmmc_host_pullup_en(int slot, int width);
+esp_err_t sdmmc_host_pullup_en(int slot, int width) __attribute__((deprecated));
 
 #ifdef __cplusplus
 }
diff --git a/components/driver/sdmmc_host.c b/components/driver/sdmmc_host.c
index 30b5bdd22e..d20a4ce156 100644
--- a/components/driver/sdmmc_host.c
+++ b/components/driver/sdmmc_host.c
@@ -37,13 +37,44 @@
 static void sdmmc_isr(void* arg);
 static void sdmmc_host_dma_init(void);
 
-
 static const char* TAG = "sdmmc_periph";
 static intr_handle_t s_intr_handle;
 static QueueHandle_t s_event_queue;
 static SemaphoreHandle_t s_io_intr_event;
 
-size_t s_slot_width[2] = {1,1};
+static size_t s_slot_width[2] = {1, 1};
+
+/* The following definitions are used to simplify GPIO configuration in the driver,
+ * whether IOMUX or GPIO Matrix is used by the chip.
+ * Two simple "APIs" are provided to the driver code:
+ * - configure_pin(name, slot, mode): Configures signal "name" for the given slot and mode.
+ * - GPIO_NUM(slot, name): Returns the GPIO number of signal "name" for the given slot.
+ *
+ * To make this work, configure_pin is defined as a macro that picks the parameters required
+ * for configuring GPIO matrix or IOMUX from relevant arrays, and passes them to either of
+ * configure_pin_gpio_matrix, configure_pin_iomux functions.
+ * Likewise, GPIO_NUM is a macro that picks the pin number from one of the two structures.
+ *
+ * Macros are used rather than inline functions to look up members of different structures
+ * with same names. E.g. the number of pin d3 is obtained either from .d3 member of
+ * sdmmc_slot_gpio_num array (for IOMUX) or from .d3 member of s_sdmmc_slot_gpio_num array
+ * (for GPIO matrix).
+ */
+#ifdef SOC_SDMMC_USE_GPIO_MATRIX
+static void configure_pin_gpio_matrix(uint8_t gpio_num, uint8_t gpio_matrix_sig, gpio_mode_t mode, const char* name);
+#define configure_pin(name, slot, mode) \
+    configure_pin_gpio_matrix(s_sdmmc_slot_gpio_num[slot].name, sdmmc_slot_gpio_sig[slot].name, mode, #name)
+static sdmmc_slot_io_info_t s_sdmmc_slot_gpio_num[SOC_SDMMC_NUM_SLOTS];
+#define GPIO_NUM(slot, name) s_sdmmc_slot_gpio_num[slot].name
+
+#elif SOC_SDMMC_USE_IOMUX
+static void configure_pin_iomux(uint8_t gpio_num);
+#define configure_pin(name, slot, mode) configure_pin_iomux(sdmmc_slot_gpio_num[slot].name)
+#define GPIO_NUM(slot, name) sdmmc_slot_gpio_num[slot].name
+
+#endif // SOC_SDMMC_USE_GPIO_MATRIX
+
+static esp_err_t sdmmc_host_pullup_en_internal(int slot, int width);
 
 void sdmmc_host_reset(void)
 {
@@ -94,9 +125,21 @@ static void sdmmc_host_set_clk_div(int div)
     SDMMC.clock.div_factor_p = p;
     SDMMC.clock.div_factor_h = h;
     SDMMC.clock.div_factor_m = p;
+
+    // Make sure 160 MHz source clock is used
+#if SOC_SDMMC_SUPPORT_XTAL_CLOCK
+    SDMMC.clock.clk_sel = 1;
+#endif
+#if SOC_SDMMC_USE_GPIO_MATRIX
+    // 90 degree phase on input and output clocks
+    const int inout_clock_phase = 1;
+#else
+    // 180 degree phase on input and output clocks
+    const int inout_clock_phase = 4;
+#endif
     // Set phases for in/out clocks
-    SDMMC.clock.phase_dout = 4;     // 180 degree phase on the output clock
-    SDMMC.clock.phase_din = 4;      // 180 degree phase on the input clock
+    SDMMC.clock.phase_dout = inout_clock_phase;
+    SDMMC.clock.phase_din = inout_clock_phase;
     SDMMC.clock.phase_core = 0;
     // Wait for the clock to propagate
     esp_rom_delay_us(10);
@@ -294,20 +337,41 @@ esp_err_t sdmmc_host_init(void)
     return ESP_OK;
 }
 
-static void configure_pin(int pin)
+#ifdef SOC_SDMMC_USE_IOMUX
+
+static void configure_pin_iomux(uint8_t gpio_num)
 {
     const int sdmmc_func = 3;
     const int drive_strength = 3;
-    assert(pin!=GPIO_NUM_NC);
-    gpio_pulldown_dis(pin);
+    assert(gpio_num != (uint8_t) GPIO_NUM_NC);
+    gpio_pulldown_dis(gpio_num);
 
-    uint32_t reg = GPIO_PIN_MUX_REG[pin];
+    uint32_t reg = GPIO_PIN_MUX_REG[gpio_num];
     assert(reg != UINT32_MAX);
     PIN_INPUT_ENABLE(reg);
     gpio_hal_iomux_func_sel(reg, sdmmc_func);
     PIN_SET_DRV(reg, drive_strength);
 }
 
+#elif SOC_SDMMC_USE_GPIO_MATRIX
+
+static void configure_pin_gpio_matrix(uint8_t gpio_num, uint8_t gpio_matrix_sig, gpio_mode_t mode, const char* name)
+{
+    assert (gpio_num != (uint8_t) GPIO_NUM_NC);
+    ESP_LOGD(TAG, "using GPIO%d as %s pin", gpio_num, name);
+    gpio_reset_pin(gpio_num);
+    gpio_set_direction(gpio_num, mode);
+    gpio_pulldown_dis(gpio_num);
+    if (mode == GPIO_MODE_INPUT || mode == GPIO_MODE_INPUT_OUTPUT) {
+        esp_rom_gpio_connect_in_signal(gpio_num, gpio_matrix_sig, false);
+    }
+    if (mode == GPIO_MODE_OUTPUT || mode == GPIO_MODE_INPUT_OUTPUT) {
+        esp_rom_gpio_connect_out_signal(gpio_num, gpio_matrix_sig, false, false);
+    }
+}
+
+#endif // SOC_SDMMC_USE_{IOMUX,GPIO_MATRIX}
+
 esp_err_t sdmmc_host_init_slot(int slot, const sdmmc_slot_config_t* slot_config)
 {
     if (!s_intr_handle) {
@@ -319,54 +383,75 @@ esp_err_t sdmmc_host_init_slot(int slot, const sdmmc_slot_config_t* slot_config)
     if (slot_config == NULL) {
         return ESP_ERR_INVALID_ARG;
     }
-    bool pullup = slot_config->flags & SDMMC_SLOT_FLAG_INTERNAL_PULLUP;
-    if (pullup) {
-        sdmmc_host_pullup_en(slot, slot_config->width);
-    }
-    int gpio_cd = slot_config->gpio_cd;
-    int gpio_wp = slot_config->gpio_wp;
+    int gpio_cd = slot_config->cd;
+    int gpio_wp = slot_config->wp;
     uint8_t slot_width = slot_config->width;
 
     // Configure pins
-    const sdmmc_slot_info_t* pslot = &sdmmc_slot_info[slot];
+    const sdmmc_slot_info_t* slot_info = &sdmmc_slot_info[slot];
 
     if (slot_width == SDMMC_SLOT_WIDTH_DEFAULT) {
-        slot_width = pslot->width;
+        slot_width = slot_info->width;
     }
-    else if (slot_width > pslot->width) {
+    else if (slot_width > slot_info->width) {
         return ESP_ERR_INVALID_ARG;
     }
     s_slot_width[slot] = slot_width;
 
-    configure_pin(pslot->clk_gpio);
-    configure_pin(pslot->cmd_gpio);
-    configure_pin(pslot->d0_gpio);
+#if SOC_SDMMC_USE_GPIO_MATRIX
+    /* Save pin configuration for this slot */
+    s_sdmmc_slot_gpio_num[slot].clk = slot_config->clk;
+    s_sdmmc_slot_gpio_num[slot].cmd = slot_config->cmd;
+    s_sdmmc_slot_gpio_num[slot].d0 = slot_config->d0;
+    /* Save d1 even in 1-line mode, it might be needed for SDIO INT line */
+    s_sdmmc_slot_gpio_num[slot].d1 = slot_config->d1;
+    if (slot_width >= 4) {
+        s_sdmmc_slot_gpio_num[slot].d2 = slot_config->d2;
+    }
+    /* Save d3 even for 1-line mode, as it needs to be set high */
+    s_sdmmc_slot_gpio_num[slot].d3 = slot_config->d3;
+    if (slot_width >= 8) {
+        s_sdmmc_slot_gpio_num[slot].d4 = slot_config->d4;
+        s_sdmmc_slot_gpio_num[slot].d5 = slot_config->d5;
+        s_sdmmc_slot_gpio_num[slot].d6 = slot_config->d6;
+        s_sdmmc_slot_gpio_num[slot].d7 = slot_config->d7;
+    }
+#endif
+
+    bool pullup = slot_config->flags & SDMMC_SLOT_FLAG_INTERNAL_PULLUP;
+    if (pullup) {
+        sdmmc_host_pullup_en_internal(slot, slot_config->width);
+    }
+
+    configure_pin(clk, slot, GPIO_MODE_OUTPUT);
+    configure_pin(cmd, slot, GPIO_MODE_INPUT_OUTPUT);
+    configure_pin(d0, slot, GPIO_MODE_INPUT_OUTPUT);
 
     if (slot_width >= 4) {
-        configure_pin(pslot->d1_gpio);
-        configure_pin(pslot->d2_gpio);
+        configure_pin(d1, slot, GPIO_MODE_INPUT_OUTPUT);
+        configure_pin(d2, slot, GPIO_MODE_INPUT_OUTPUT);
         // Force D3 high to make slave enter SD mode.
         // Connect to peripheral after width configuration.
         gpio_config_t gpio_conf = {
-            .pin_bit_mask = BIT64(pslot->d3_gpio),
-            .mode = GPIO_MODE_OUTPUT ,
+            .pin_bit_mask = BIT64(GPIO_NUM(slot, d3)),
+            .mode = GPIO_MODE_OUTPUT,
             .pull_up_en = 0,
             .pull_down_en = 0,
             .intr_type = GPIO_INTR_DISABLE,
         };
         gpio_config(&gpio_conf);
-        gpio_set_level(pslot->d3_gpio, 1);
-        if (slot_width == 8) {
-            configure_pin(pslot->d4_gpio);
-            configure_pin(pslot->d5_gpio);
-            configure_pin(pslot->d6_gpio);
-            configure_pin(pslot->d7_gpio);
-        }
+        gpio_set_level(GPIO_NUM(slot, d3), 1);
+    }
+    if (slot_width == 8) {
+        configure_pin(d4, slot, GPIO_MODE_INPUT_OUTPUT);
+        configure_pin(d5, slot, GPIO_MODE_INPUT_OUTPUT);
+        configure_pin(d6, slot, GPIO_MODE_INPUT_OUTPUT);
+        configure_pin(d7, slot, GPIO_MODE_INPUT_OUTPUT);
     }
 
     // SDIO slave interrupt is edge sensitive to ~(int_n | card_int | card_detect)
     // set this and card_detect to high to enable sdio interrupt
-    esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ONE_INPUT, pslot->card_int, false);
+    esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ONE_INPUT, slot_info->card_int, false);
 
     // Set up Card Detect input
     int matrix_in_cd;
@@ -379,7 +464,7 @@ esp_err_t sdmmc_host_init_slot(int slot, const sdmmc_slot_config_t* slot_config)
         // if not set, default to CD low (card present)
         matrix_in_cd = GPIO_MATRIX_CONST_ZERO_INPUT;
     }
-    esp_rom_gpio_connect_in_signal(matrix_in_cd, pslot->card_detect, false);
+    esp_rom_gpio_connect_in_signal(matrix_in_cd, slot_info->card_detect, false);
 
     // Set up Write Protect input
     int matrix_in_wp;
@@ -394,7 +479,7 @@ esp_err_t sdmmc_host_init_slot(int slot, const sdmmc_slot_config_t* slot_config)
     }
     // WP signal is normally active low, but hardware expects
     // an active-high signal, so invert it in GPIO matrix
-    esp_rom_gpio_connect_in_signal(matrix_in_wp, pslot->write_protect, true);
+    esp_rom_gpio_connect_in_signal(matrix_in_wp, slot_info->write_protect, true);
 
     // By default, set probing frequency (400kHz) and 1-bit bus
     esp_err_t ret = sdmmc_host_set_card_clk(slot, 400);
@@ -456,11 +541,11 @@ esp_err_t sdmmc_host_set_bus_width(int slot, size_t width)
         SDMMC.ctype.card_width_8 &= ~mask;
         SDMMC.ctype.card_width |= mask;
         // D3 was set to GPIO high to force slave into SD mode, until 4-bit mode is set
-        configure_pin(sdmmc_slot_info[slot].d3_gpio);
+        configure_pin(d3, slot, GPIO_MODE_INPUT_OUTPUT);
     } else if (width == 8) {
         SDMMC.ctype.card_width_8 |= mask;
         // D3 was set to GPIO high to force slave into SD mode, until 4-bit mode is set
-        configure_pin(sdmmc_slot_info[slot].d3_gpio);
+        configure_pin(d3, slot, GPIO_MODE_INPUT_OUTPUT);
     } else {
         return ESP_ERR_INVALID_ARG;
     }
@@ -542,7 +627,7 @@ bool sdmmc_host_card_busy(void)
 
 esp_err_t sdmmc_host_io_int_enable(int slot)
 {
-    configure_pin(sdmmc_slot_info[slot].d1_gpio);
+    configure_pin(d1, slot, GPIO_MODE_INPUT_OUTPUT);
     return ESP_OK;
 }
 
@@ -558,7 +643,7 @@ esp_err_t sdmmc_host_io_int_wait(int slot, TickType_t timeout_ticks)
 
     SDMMC.intmask.sdio &= ~BIT(slot);   /* Disable SDIO interrupt */
     SDMMC.rintsts.sdio = BIT(slot);
-    if (gpio_get_level(sdmmc_slot_info[slot].d1_gpio) == 0) {
+    if (gpio_get_level(GPIO_NUM(slot, d1)) == 0) {
         return ESP_OK;
     }
     /* Otherwise, need to wait for an interrupt. Since D1 was high,
@@ -619,25 +704,28 @@ static void sdmmc_isr(void* arg) {
     }
 }
 
-esp_err_t sdmmc_host_pullup_en(int slot, int width)
+static esp_err_t sdmmc_host_pullup_en_internal(int slot, int width)
 {
     if (width > sdmmc_slot_info[slot].width) {
         //in esp32 we only support 8 bit in slot 0, note this is occupied by the flash by default
         return ESP_ERR_INVALID_ARG;
     }
-    //according to the spec, the host control the clk, we don't to pull it up here
-    gpio_pullup_en(sdmmc_slot_info[slot].cmd_gpio);
-    gpio_pullup_en(sdmmc_slot_info[slot].d0_gpio);
+    // according to the spec, the host controls the clk, we don't to pull it up here
+    gpio_pullup_en(GPIO_NUM(slot, cmd));
+    gpio_pullup_en(GPIO_NUM(slot, d0));
     if (width >= 4) {
-        gpio_pullup_en(sdmmc_slot_info[slot].d1_gpio);
-        gpio_pullup_en(sdmmc_slot_info[slot].d2_gpio);
-        gpio_pullup_en(sdmmc_slot_info[slot].d3_gpio);
+        gpio_pullup_en(GPIO_NUM(slot, d1));
+        gpio_pullup_en(GPIO_NUM(slot, d2));
+        gpio_pullup_en(GPIO_NUM(slot, d3));
     }
     if (width == 8) {
-        gpio_pullup_en(sdmmc_slot_info[slot].d4_gpio);
-        gpio_pullup_en(sdmmc_slot_info[slot].d5_gpio);
-        gpio_pullup_en(sdmmc_slot_info[slot].d6_gpio);
-        gpio_pullup_en(sdmmc_slot_info[slot].d7_gpio);
+        gpio_pullup_en(GPIO_NUM(slot, d4));
+        gpio_pullup_en(GPIO_NUM(slot, d5));
+        gpio_pullup_en(GPIO_NUM(slot, d6));
+        gpio_pullup_en(GPIO_NUM(slot, d7));
     }
     return ESP_OK;
 }
+
+/* Deprecared public function */
+esp_err_t sdmmc_host_pullup_en(int slot, int width) __attribute__((alias("sdmmc_host_pullup_en_internal")));
-- 
2.25.1


From 47685f901d5bec29a7438633f7a90725e6c28122 Mon Sep 17 00:00:00 2001
From: Ivan Grokhotkov <ivan@espressif.com>
Date: Thu, 6 May 2021 08:48:21 +0200
Subject: [PATCH 06/43] examples: sdmmc: set slot width and pins explicitly

... and prefer SDMMC_SLOT_FLAG_INTERNAL_PULLUP over explicitly setting
pullups on pins.
---
 .../sd_card/sdmmc/main/sd_card_example_main.c | 29 ++++++++++++-------
 1 file changed, 18 insertions(+), 11 deletions(-)

diff --git a/examples/storage/sd_card/sdmmc/main/sd_card_example_main.c b/examples/storage/sd_card/sdmmc/main/sd_card_example_main.c
index 7386d154e4..6146b16538 100644
--- a/examples/storage/sd_card/sdmmc/main/sd_card_example_main.c
+++ b/examples/storage/sd_card/sdmmc/main/sd_card_example_main.c
@@ -52,17 +52,24 @@ void app_main(void)
     // Modify slot_config.gpio_cd and slot_config.gpio_wp if your board has these signals.
     sdmmc_slot_config_t slot_config = SDMMC_SLOT_CONFIG_DEFAULT();
 
-    // To use 1-line SD mode, uncomment the following line:
-    // slot_config.width = 1;
-
-    // GPIOs 15, 2, 4, 12, 13 should have external 10k pull-ups.
-    // Internal pull-ups are not sufficient. However, enabling internal pull-ups
-    // does make a difference some boards, so we do that here.
-    gpio_set_pull_mode(15, GPIO_PULLUP_ONLY);   // CMD, needed in 4- and 1- line modes
-    gpio_set_pull_mode(2, GPIO_PULLUP_ONLY);    // D0, needed in 4- and 1-line modes
-    gpio_set_pull_mode(4, GPIO_PULLUP_ONLY);    // D1, needed in 4-line mode only
-    gpio_set_pull_mode(12, GPIO_PULLUP_ONLY);   // D2, needed in 4-line mode only
-    gpio_set_pull_mode(13, GPIO_PULLUP_ONLY);   // D3, needed in 4- and 1-line modes
+    // To use 1-line SD mode, change this to 1:
+    slot_config.width = 4;
+
+    // On chips where the GPIOs used for SD card can be configured, set them in
+    // the slot_config structure:
+#ifdef SOC_SDMMC_USE_GPIO_MATRIX
+    slot_config.clk = GPIO_NUM_14;
+    slot_config.cmd = GPIO_NUM_15;
+    slot_config.d0 = GPIO_NUM_2;
+    slot_config.d1 = GPIO_NUM_4;
+    slot_config.d2 = GPIO_NUM_12;
+    slot_config.d3 = GPIO_NUM_13;
+#endif
+
+    // Enable internal pullups on enabled pins. The internal pullups
+    // are insufficient however, please make sure 10k external pullups are
+    // connected on the bus. This is for debug / example purpose only.
+    slot_config.flags |= SDMMC_SLOT_FLAG_INTERNAL_PULLUP;
 
     ret = esp_vfs_fat_sdmmc_mount(mount_point, &host, &slot_config, &mount_config, &card);
 
-- 
2.25.1


From 7bb91f912c672b34ff6b23fecdd6f86368c63a8d Mon Sep 17 00:00:00 2001
From: Dmitry <Dmitry.Yakovlev@espressif.com>
Date: Thu, 15 Apr 2021 10:52:09 +0300
Subject: [PATCH 07/43] gdbstub component

---
 components/driver/uart.c                      |   3 +
 components/esp_gdbstub/CMakeLists.txt         |  21 +-
 components/esp_gdbstub/esp32/gdbstub_esp32.c  |  38 ---
 .../esp_gdbstub/esp32s2/gdbstub_esp32s2.c     |  38 ---
 .../esp_gdbstub/esp32s3/gdbstub_esp32s3.c     |  37 ---
 .../esp_gdbstub/esp_common/gdbstub_common.c   | 129 +++++++++
 components/esp_gdbstub/include/esp_gdbstub.h  |   4 +-
 .../private_include/esp_gdbstub_common.h      |  19 +-
 components/esp_gdbstub/src/gdbstub.c          | 268 ++++++++++++++++--
 components/esp_gdbstub/src/packet.c           |   6 +-
 components/esp_gdbstub/xtensa/gdbstub-entry.S |  44 +++
 .../esp_gdbstub/xtensa/gdbstub_xtensa.c       |   1 -
 components/esp_system/Kconfig                 |  10 +-
 docs/en/api-guides/tools/idf-monitor.rst      |  12 +-
 .../hello_world/main/CMakeLists.txt           |   2 +-
 examples/system/gdbstub/CMakeLists.txt        |   6 +
 examples/system/gdbstub/Makefile              |   9 +
 examples/system/gdbstub/README.md             | 127 +++++++++
 examples/system/gdbstub/main/CMakeLists.txt   |   2 +
 examples/system/gdbstub/main/component.mk     |   5 +
 examples/system/gdbstub/main/gdbstub_main.c   |  39 +++
 examples/system/gdbstub/sdkconfig.defaults    |  22 ++
 22 files changed, 681 insertions(+), 161 deletions(-)
 create mode 100644 components/esp_gdbstub/esp_common/gdbstub_common.c
 create mode 100644 components/esp_gdbstub/xtensa/gdbstub-entry.S
 create mode 100644 examples/system/gdbstub/CMakeLists.txt
 create mode 100644 examples/system/gdbstub/Makefile
 create mode 100644 examples/system/gdbstub/README.md
 create mode 100644 examples/system/gdbstub/main/CMakeLists.txt
 create mode 100644 examples/system/gdbstub/main/component.mk
 create mode 100644 examples/system/gdbstub/main/gdbstub_main.c
 create mode 100644 examples/system/gdbstub/sdkconfig.defaults

diff --git a/components/driver/uart.c b/components/driver/uart.c
index bf21ac3f80..a8f37eb3a3 100644
--- a/components/driver/uart.c
+++ b/components/driver/uart.c
@@ -1319,6 +1319,9 @@ esp_err_t uart_flush_input(uart_port_t uart_num)
 esp_err_t uart_driver_install(uart_port_t uart_num, int rx_buffer_size, int tx_buffer_size, int queue_size, QueueHandle_t *uart_queue, int intr_alloc_flags)
 {
     esp_err_t r;
+#ifdef CONFIG_ESP_GDBSTUB_ENABLED
+    UART_CHECK((uart_num != CONFIG_ESP_CONSOLE_UART_NUM), "UART used by GDB-stubs! Please disable GDB in menuconfig.", ESP_FAIL);
+#endif // CONFIG_ESP_GDBSTUB_ENABLED
     UART_CHECK((uart_num < UART_NUM_MAX), "uart_num error", ESP_FAIL);
     UART_CHECK((rx_buffer_size > SOC_UART_FIFO_LEN), "uart rx buffer length error", ESP_FAIL);
     UART_CHECK((tx_buffer_size > SOC_UART_FIFO_LEN) || (tx_buffer_size == 0), "uart tx buffer length error", ESP_FAIL);
diff --git a/components/esp_gdbstub/CMakeLists.txt b/components/esp_gdbstub/CMakeLists.txt
index 0d64fc4465..cb799481b3 100644
--- a/components/esp_gdbstub/CMakeLists.txt
+++ b/components/esp_gdbstub/CMakeLists.txt
@@ -1,16 +1,15 @@
 idf_build_get_property(target IDF_TARGET)
 
-idf_component_register(SRCS "src/gdbstub.c" "src/packet.c"
+set(esp_gdbstub_srcs "src/gdbstub.c"
+                     "src/packet.c"
+                     "esp_common/gdbstub_common.c"
+                     "${target}/gdbstub_${target}.c"
+                     "xtensa/gdbstub-entry.S"
+                     "xtensa/gdbstub_xtensa.c")
+
+idf_component_register(SRCS "${esp_gdbstub_srcs}"
                        INCLUDE_DIRS "include"
-                       PRIV_INCLUDE_DIRS "private_include"
+                       PRIV_INCLUDE_DIRS "private_include" "${target}" "xtensa"
                        LDFRAGMENTS "linker.lf"
                        REQUIRES "freertos"
-                       PRIV_REQUIRES "soc" "esp_rom")
-
-if(CONFIG_IDF_TARGET_ARCH_XTENSA)
-    target_include_directories(${COMPONENT_LIB} PUBLIC "xtensa" "${target}")
-    target_sources(${COMPONENT_LIB} PRIVATE "xtensa/gdbstub_xtensa.c" "${target}/gdbstub_${target}.c")
-elseif(CONFIG_IDF_TARGET_ARCH_RISCV)
-    target_include_directories(${COMPONENT_LIB} PUBLIC "riscv" "${target}")
-    target_sources(${COMPONENT_LIB} PRIVATE "riscv/gdbstub_riscv.c" "${target}/gdbstub_${target}.c")
-endif()
+                       PRIV_REQUIRES "soc" "xtensa" "esp_rom")
diff --git a/components/esp_gdbstub/esp32/gdbstub_esp32.c b/components/esp_gdbstub/esp32/gdbstub_esp32.c
index 2397a3940e..39fde0a6c7 100644
--- a/components/esp_gdbstub/esp32/gdbstub_esp32.c
+++ b/components/esp_gdbstub/esp32/gdbstub_esp32.c
@@ -16,41 +16,3 @@
 #include "soc/gpio_periph.h"
 #include "esp_gdbstub_common.h"
 #include "sdkconfig.h"
-
-#define UART_NUM CONFIG_ESP_CONSOLE_UART_NUM
-
-void esp_gdbstub_target_init(void)
-{
-}
-
-int esp_gdbstub_getchar(void)
-{
-    while (REG_GET_FIELD(UART_STATUS_REG(UART_NUM), UART_RXFIFO_CNT) == 0) {
-        ;
-    }
-    return REG_READ(UART_FIFO_REG(UART_NUM));
-}
-
-void esp_gdbstub_putchar(int c)
-{
-    while (REG_GET_FIELD(UART_STATUS_REG(UART_NUM), UART_TXFIFO_CNT) >= 126) {
-        ;
-    }
-    REG_WRITE(UART_FIFO_REG(UART_NUM), c);
-}
-
-void esp_gdbstub_flush()
-{
-    //not needed for uart
-}
-
-int esp_gdbstub_readmem(intptr_t addr)
-{
-    if (addr < 0x20000000 || addr >= 0x80000000) {
-        /* see esp_cpu_configure_region_protection */
-        return -1;
-    }
-    uint32_t val_aligned = *(uint32_t *)(addr & (~3));
-    uint32_t shift = (addr & 3) * 8;
-    return (val_aligned >> shift) & 0xff;
-}
diff --git a/components/esp_gdbstub/esp32s2/gdbstub_esp32s2.c b/components/esp_gdbstub/esp32s2/gdbstub_esp32s2.c
index 8ac52d4083..39fde0a6c7 100644
--- a/components/esp_gdbstub/esp32s2/gdbstub_esp32s2.c
+++ b/components/esp_gdbstub/esp32s2/gdbstub_esp32s2.c
@@ -16,41 +16,3 @@
 #include "soc/gpio_periph.h"
 #include "esp_gdbstub_common.h"
 #include "sdkconfig.h"
-
-#define UART_NUM CONFIG_ESP_CONSOLE_UART_NUM
-
-void esp_gdbstub_target_init()
-{
-}
-
-int esp_gdbstub_getchar()
-{
-    while (REG_GET_FIELD(UART_STATUS_REG(UART_NUM), UART_RXFIFO_CNT) == 0) {
-        ;
-    }
-    return REG_READ(UART_FIFO_AHB_REG(UART_NUM));
-}
-
-void esp_gdbstub_putchar(int c)
-{
-    while (REG_GET_FIELD(UART_STATUS_REG(UART_NUM), UART_TXFIFO_CNT) >= 126) {
-        ;
-    }
-    REG_WRITE(UART_FIFO_AHB_REG(UART_NUM), c);
-}
-
-void esp_gdbstub_flush()
-{
-    //not needed for uart
-}
-
-int esp_gdbstub_readmem(intptr_t addr)
-{
-    if (addr < 0x20000000 || addr >= 0x80000000) {
-        /* see esp_cpu_configure_region_protection */
-        return -1;
-    }
-    uint32_t val_aligned = *(uint32_t *)(addr & (~3));
-    uint32_t shift = (addr & 3) * 8;
-    return (val_aligned >> shift) & 0xff;
-}
diff --git a/components/esp_gdbstub/esp32s3/gdbstub_esp32s3.c b/components/esp_gdbstub/esp32s3/gdbstub_esp32s3.c
index 6c2eb40717..1e02fec0d0 100644
--- a/components/esp_gdbstub/esp32s3/gdbstub_esp32s3.c
+++ b/components/esp_gdbstub/esp32s3/gdbstub_esp32s3.c
@@ -17,40 +17,3 @@
 #include "soc/gpio_periph.h"
 #include "esp_gdbstub_common.h"
 
-#define UART_NUM CONFIG_ESP_CONSOLE_UART_NUM
-
-void esp_gdbstub_target_init()
-{
-}
-
-int esp_gdbstub_getchar()
-{
-    while (REG_GET_FIELD(UART_STATUS_REG(UART_NUM), UART_RXFIFO_CNT) == 0) {
-        ;
-    }
-    return REG_READ(UART_FIFO_AHB_REG(UART_NUM));
-}
-
-void esp_gdbstub_putchar(int c)
-{
-    while (REG_GET_FIELD(UART_STATUS_REG(UART_NUM), UART_TXFIFO_CNT) >= 126) {
-        ;
-    }
-    REG_WRITE(UART_FIFO_AHB_REG(UART_NUM), c);
-}
-
-void esp_gdbstub_flush()
-{
-    //not needed for uart
-}
-
-int esp_gdbstub_readmem(intptr_t addr)
-{
-    if (addr < 0x20000000 || addr >= 0x80000000) {
-        /* see cpu_configure_region_protection */
-        return -1;
-    }
-    uint32_t val_aligned = *(uint32_t *)(addr & (~3));
-    uint32_t shift = (addr & 3) * 8;
-    return (val_aligned >> shift) & 0xff;
-}
diff --git a/components/esp_gdbstub/esp_common/gdbstub_common.c b/components/esp_gdbstub/esp_common/gdbstub_common.c
new file mode 100644
index 0000000000..23ff278a2c
--- /dev/null
+++ b/components/esp_gdbstub/esp_common/gdbstub_common.c
@@ -0,0 +1,129 @@
+// Copyright 2015-2019 Espressif Systems (Shanghai) PTE LTD
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "soc/uart_periph.h"
+#include "soc/gpio_periph.h"
+#include "esp_gdbstub_common.h"
+#include "sdkconfig.h"
+#include "hal/uart_ll.h"
+
+#define UART_NUM CONFIG_ESP_CONSOLE_UART_NUM
+
+static uart_dev_t *gdb_uart = NULL;
+
+
+void esp_gdbstub_target_init(void)
+{
+    switch (UART_NUM) {
+    case 0:
+        gdb_uart = &UART0;
+        break;
+    case 1:
+        gdb_uart = &UART1;
+        break;
+    case 2:
+        gdb_uart = &UART2;
+        break;
+    default:
+        gdb_uart = &UART0;
+        break;
+    }
+}
+
+int esp_gdbstub_getchar(void)
+{
+    if (gdb_uart == NULL) {
+        esp_gdbstub_target_init();
+    }
+    unsigned char data;
+    while (uart_ll_get_rxfifo_len(gdb_uart) == 0) {
+
+    }
+    uart_ll_read_rxfifo(gdb_uart, &data, 1);
+    return data;
+}
+
+void esp_gdbstub_putchar(int c)
+{
+    if (gdb_uart == NULL) {
+        esp_gdbstub_target_init();
+    }
+    while (uart_ll_get_txfifo_len(gdb_uart) <= 126) {
+    }
+    uart_ll_write_txfifo(gdb_uart, (uint8_t *)&c, 1);
+}
+
+void esp_gdbstub_flush()
+{
+    //not needed for uart
+}
+
+int esp_gdbstub_getfifo()
+{
+    if (gdb_uart == NULL) {
+        esp_gdbstub_target_init();
+    }
+    int doDebug = 0;
+
+    int fifolen = uart_ll_get_rxfifo_len(gdb_uart);
+    while (fifolen != 0) {
+        unsigned char data;
+        uart_ll_read_rxfifo(gdb_uart, &data, 1);
+        if (data == 0x3) {
+            doDebug = 1; //Check if any of the chars is Ctrl+C. Throw away rest.
+        }
+        if (data == '+') {
+            doDebug = 1; //Check if any of the chars is '+'. Throw away rest.
+        }
+        fifolen--;
+    }
+    uart_ll_clr_intsts_mask(gdb_uart, UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);
+    return doDebug;
+}
+
+int esp_gdbstub_readmem(intptr_t addr)
+{
+    if (addr < 0x20000000 || addr >= 0x80000000) {
+        /* see cpu_configure_region_protection */
+        return -1;
+    }
+    uint32_t val_aligned = *(uint32_t *)(addr & (~3));
+    uint32_t shift = (addr & 3) * 8;
+    return (val_aligned >> shift) & 0xff;
+}
+
+int esp_gdbstub_writemem(unsigned int addr, unsigned char data)
+{
+    if (addr < 0x20000000 || addr >= 0x80000000) {
+        /* see cpu_configure_region_protection */
+        return -1;
+    }
+
+    int *i = (int *)(addr & (~3));
+    if ((addr & 3) == 0) {
+        *i = (*i & 0xffffff00) | (data << 0);
+    }
+    if ((addr & 3) == 1) {
+        *i = (*i & 0xffff00ff) | (data << 8);
+    }
+    if ((addr & 3) == 2) {
+        *i = (*i & 0xff00ffff) | (data << 16);
+    }
+    if ((addr & 3) == 3) {
+        *i = (*i & 0x00ffffff) | (data << 24);
+    }
+    asm volatile("ISYNC\nISYNC\n");
+
+    return 0;
+}
\ No newline at end of file
diff --git a/components/esp_gdbstub/include/esp_gdbstub.h b/components/esp_gdbstub/include/esp_gdbstub.h
index 02fda63e58..d896e77ffc 100644
--- a/components/esp_gdbstub/include/esp_gdbstub.h
+++ b/components/esp_gdbstub/include/esp_gdbstub.h
@@ -14,13 +14,11 @@
 
 #pragma once
 
-#include "esp_gdbstub_arch.h"
-
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-void esp_gdbstub_panic_handler(esp_gdbstub_frame_t *frame) __attribute__((noreturn));
+void esp_gdbstub_init(void);
 
 #ifdef __cplusplus
 }
diff --git a/components/esp_gdbstub/private_include/esp_gdbstub_common.h b/components/esp_gdbstub/private_include/esp_gdbstub_common.h
index 666e75aedb..cb3d341c32 100644
--- a/components/esp_gdbstub/private_include/esp_gdbstub_common.h
+++ b/components/esp_gdbstub/private_include/esp_gdbstub_common.h
@@ -18,7 +18,7 @@
 #include <stddef.h>
 #include <stdbool.h>
 
-#include "esp_gdbstub.h"
+#include "esp_gdbstub_arch.h"
 #include "sdkconfig.h"
 
 #ifdef CONFIG_ESP_GDBSTUB_SUPPORT_TASKS
@@ -30,6 +30,7 @@
 #define GDBSTUB_ST_ENDPACKET -1
 #define GDBSTUB_ST_ERR -2
 #define GDBSTUB_ST_OK -3
+#define GDBSTUB_ST_CONT -4
 
 /* Special task index values */
 #define GDBSTUB_CUR_TASK_INDEX_UNKNOWN -1
@@ -125,6 +126,20 @@ int esp_gdbstub_readmem(intptr_t addr);
  */
 void esp_gdbstub_flush(void);
 
+/**
+ * Write a byte to target memory
+ * @param addr  address
+ * @param data  data byte
+ * @return 0 in case of success, -1 in case of error
+ */
+int esp_gdbstub_writemem(unsigned int addr, unsigned char data);
+
+/**
+ * Read a data from fifo and detect start symbol
+ * @return  1 if break symbol was detected, or 0 if not
+ */
+int esp_gdbstub_getfifo(void);
+
 /**** GDB packet related functions ****/
 
 /** Begin a packet */
@@ -143,7 +158,7 @@ void esp_gdbstub_send_hex(int val, int bits);
 void esp_gdbstub_send_end(void);
 
 /** Send a packet with a string as content */
-void esp_gdbstub_send_str_packet(const char* str);
+void esp_gdbstub_send_str_packet(const char *str);
 
 /** Get a hex value from the gdb packet */
 uint32_t esp_gdbstub_gethex(const unsigned char **ptr, int bits);
diff --git a/components/esp_gdbstub/src/gdbstub.c b/components/esp_gdbstub/src/gdbstub.c
index 6e0a800069..b58fec135e 100644
--- a/components/esp_gdbstub/src/gdbstub.c
+++ b/components/esp_gdbstub/src/gdbstub.c
@@ -17,6 +17,15 @@
 #include "esp_gdbstub_common.h"
 #include "sdkconfig.h"
 
+#include "soc/uart_reg.h"
+#include "soc/periph_defs.h"
+#include "esp_attr.h"
+#include "esp_intr_alloc.h"
+#include "hal/wdt_hal.h"
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+//#include "esp_task_wdt.h"
+
 
 #ifdef CONFIG_ESP_GDBSTUB_SUPPORT_TASKS
 static inline int gdb_tid_to_task_index(int tid);
@@ -25,14 +34,17 @@ static void init_task_info(void);
 static void find_paniced_task_index(void);
 static void set_active_task(size_t index);
 static int handle_task_commands(unsigned char *cmd, int len);
+static void esp_gdbstub_send_str_as_hex(const char *str);
 #endif
 
 static void send_reason(void);
 
-
 static esp_gdbstub_scratch_t s_scratch;
+static esp_gdbstub_gdb_regfile_t *gdb_local_regfile = &s_scratch.regfile;
 
-
+/**
+ * @breef panic handler
+*/
 void esp_gdbstub_panic_handler(esp_gdbstub_frame_t *frame)
 {
 #ifndef CONFIG_ESP_GDBSTUB_SUPPORT_TASKS
@@ -80,7 +92,9 @@ void esp_gdbstub_panic_handler(esp_gdbstub_frame_t *frame)
     }
 }
 
-
+/**
+ * Set interrupt reason to GDB
+*/
 static void send_reason(void)
 {
     esp_gdbstub_send_start();
@@ -89,13 +103,159 @@ static void send_reason(void)
     esp_gdbstub_send_end();
 }
 
+/**
+ * Swap bytes in word
+*/
 static uint32_t gdbstub_hton(uint32_t i)
 {
     return __builtin_bswap32(i);
 }
 
+static wdt_hal_context_t rtc_wdt_ctx = {.inst = WDT_RWDT, .rwdt_dev = &RTCCNTL};
+static wdt_hal_context_t wdt0_context = {.inst = WDT_MWDT0, .mwdt_dev = &TIMERG0};
+static wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1};
+
+static bool wdt0_context_enabled = false;
+static bool wdt1_context_enabled = false;
+static bool rtc_wdt_ctx_enabled = false;
+/**
+ * Disable all enabled WDTs
+ */
+static inline void disable_all_wdts(void)
+{
+    wdt0_context_enabled = wdt_hal_is_enabled(&wdt0_context);
+    wdt1_context_enabled = wdt_hal_is_enabled(&wdt1_context);
+    rtc_wdt_ctx_enabled = wdt_hal_is_enabled(&rtc_wdt_ctx);
+
+    //Task WDT is the Main Watchdog Timer of Timer Group 0
+    if (true == wdt0_context_enabled) {
+        wdt_hal_write_protect_disable(&wdt0_context);
+        wdt_hal_disable(&wdt0_context);
+        wdt_hal_feed(&wdt0_context);
+        wdt_hal_write_protect_enable(&wdt0_context);
+    }
+
+    //Interupt WDT is the Main Watchdog Timer of Timer Group 1
+    if (true == wdt1_context_enabled) {
+        wdt_hal_write_protect_disable(&wdt1_context);
+        wdt_hal_disable(&wdt1_context);
+        wdt_hal_feed(&wdt1_context);
+        wdt_hal_write_protect_enable(&wdt1_context);
+    }
+    if (true == rtc_wdt_ctx_enabled) {
+        wdt_hal_write_protect_disable(&rtc_wdt_ctx);
+        wdt_hal_disable(&rtc_wdt_ctx);
+        wdt_hal_feed(&rtc_wdt_ctx);
+        wdt_hal_write_protect_enable(&rtc_wdt_ctx);
+    }
+}
+
+/**
+ * Enable all enabled WDTs
+ */
+static inline void enable_all_wdts(void)
+{
+    //Task WDT is the Main Watchdog Timer of Timer Group 0
+    if (false == wdt0_context_enabled) {
+        wdt_hal_write_protect_disable(&wdt0_context);
+        wdt_hal_enable(&wdt0_context);
+        wdt_hal_write_protect_enable(&wdt0_context);
+    }
+    // Interupt WDT is the Main Watchdog Timer of Timer Group 1
+    if (false == wdt1_context_enabled) {
+        wdt_hal_write_protect_disable(&wdt1_context);
+        wdt_hal_enable(&wdt1_context);
+        wdt_hal_write_protect_enable(&wdt1_context);
+    }
+
+    if (false == rtc_wdt_ctx_enabled) {
+        wdt_hal_write_protect_disable(&rtc_wdt_ctx);
+        wdt_hal_enable(&rtc_wdt_ctx);
+        wdt_hal_write_protect_enable(&rtc_wdt_ctx);
+    }
+}
+
+/**
+ * @breef Handle UART interrupt
+ *
+ * Handle UART interrupt for gdbstub. The function disable WDT.
+ * If Ctrl+C combination detected (0x03), then application will start to process incoming GDB messages.
+ * The gdbstub will stay in this interrupt until continue command will be received ($c#63).
+ *
+ * @param curr_regs - actual registers frame
+ *
+*/
+void gdbstub_handle_uart_int(XtExcFrame *regs_frame)
+{
+    // Disable all enabled WDT on enter
+    disable_all_wdts();
+
+    int doDebug = esp_gdbstub_getfifo();
+    s_scratch.signal = esp_gdbstub_get_signal(regs_frame);
+
+    if (doDebug) {
+#ifdef CONFIG_ESP_GDBSTUB_SUPPORT_TASKS
+        init_task_info();
+#endif// CONFIG_ESP_GDBSTUB_SUPPORT_TASKS
+        esp_gdbstub_frame_to_regfile(regs_frame, gdb_local_regfile);
+        send_reason();
+        while (true) {
+            unsigned char *cmd;
+            size_t size;
+
+            int res = esp_gdbstub_read_command(&cmd, &size);
+            if (res == '-') {
+                send_reason();
+                continue;
+            }
+            if (res > 0) {
+                /* character received instead of a command */
+                continue;
+            }
+            if (res == -2) {
+                esp_gdbstub_send_str_packet("E01");
+                continue;
+            }
+            res = esp_gdbstub_handle_command(cmd, size);
+            if (res == -2) {
+                esp_gdbstub_send_str_packet(NULL);
+            }
+#ifdef CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME
+            if (res == GDBSTUB_ST_CONT) {
+                break;
+            }
+#endif // CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME
+        }
+    }
+}
+
+intr_handle_t intr_handle_;
+extern void _xt_gdbstub_int(void * );
+
+#ifdef CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME
+/** @breef Init gdbstub
+ * Init uart interrupt for gdbstub
+ * */
+void esp_gdbstub_init(void)
+{
+    esp_intr_alloc(ETS_UART0_INTR_SOURCE, 0, _xt_gdbstub_int, NULL, &intr_handle_);
+}
+#endif // CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME
+
+#ifdef CONFIG_ESP_GDBSTUB_SUPPORT_TASKS
+
+/** Send string as a het to uart */
+static void esp_gdbstub_send_str_as_hex(const char *str)
+{
+    while (*str) {
+        esp_gdbstub_send_hex(*str, 8);
+        str++;
+    }
+}
+#endif
+
 /** Send all registers to gdb */
-static void handle_g_command(const unsigned char* cmd, int len)
+static void handle_g_command(const unsigned char *cmd, int len)
 {
     uint32_t *p = (uint32_t *) &s_scratch.regfile;
     esp_gdbstub_send_start();
@@ -106,7 +266,7 @@ static void handle_g_command(const unsigned char* cmd, int len)
 }
 
 /** Receive register values from gdb */
-static void handle_G_command(const unsigned char* cmd, int len)
+static void handle_G_command(const unsigned char *cmd, int len)
 {
     uint32_t *p = (uint32_t *) &s_scratch.regfile;
     for (int i = 0; i < sizeof(s_scratch.regfile) / sizeof(*p); ++i) {
@@ -116,7 +276,7 @@ static void handle_G_command(const unsigned char* cmd, int len)
 }
 
 /** Read memory to gdb */
-static void handle_m_command(const unsigned char* cmd, int len)
+static void handle_m_command(const unsigned char *cmd, int len)
 {
     intptr_t addr = (intptr_t) esp_gdbstub_gethex(&cmd, -1);
     cmd++;
@@ -135,12 +295,32 @@ static void handle_m_command(const unsigned char* cmd, int len)
     esp_gdbstub_send_end();
 }
 
+/** Write memory from gdb */
+static void handle_M_command(const unsigned char *cmd, int len)
+{
+    intptr_t addr = (intptr_t) esp_gdbstub_gethex(&cmd, -1);
+    cmd++; // skip '.'
+    uint32_t size = esp_gdbstub_gethex(&cmd, -1);
+    cmd++; // skip ':'
+
+    if (esp_gdbstub_readmem(addr) < 0 || esp_gdbstub_readmem(addr + size - 1) < 0) {
+        esp_gdbstub_send_str_packet("E01");
+        return;
+    }
+    for (int k = 0; k < size; k++) {
+        esp_gdbstub_writemem(addr, esp_gdbstub_gethex(&cmd, 8));
+        addr++;
+    }
+    esp_gdbstub_send_start();
+    esp_gdbstub_send_str_packet("OK");
+    esp_gdbstub_send_end();
+}
+
 /** Handle a command received from gdb */
 int esp_gdbstub_handle_command(unsigned char *cmd, int len)
 {
     unsigned char *data = cmd + 1;
-    if (cmd[0] == 'g')
-    {
+    if (cmd[0] == 'g') {
         handle_g_command(data, len - 1);
     } else if (cmd[0] == 'G') {
         /* receive content for all registers from gdb */
@@ -148,6 +328,9 @@ int esp_gdbstub_handle_command(unsigned char *cmd, int len)
     } else if (cmd[0] == 'm') {
         /* read memory to gdb */
         handle_m_command(data, len - 1);
+    } else if (cmd[0] == 'M') {
+        /* write to memory from GDB */
+        handle_M_command(data, len - 1);
     } else if (cmd[0] == '?') {
         /* Reply with stop reason */
         send_reason();
@@ -155,6 +338,8 @@ int esp_gdbstub_handle_command(unsigned char *cmd, int len)
     } else if (s_scratch.state != GDBSTUB_TASK_SUPPORT_DISABLED) {
         return handle_task_commands(cmd, len);
 #endif // CONFIG_ESP_GDBSTUB_SUPPORT_TASKS
+    } else if (strncmp((char *)cmd, "vCont;c", 7) == 0 || cmd[0] == 'c') { //continue execution
+        return GDBSTUB_ST_CONT;
     } else {
         /* Unrecognized command */
         return GDBSTUB_ST_ERR;
@@ -209,10 +394,22 @@ static bool get_task_handle(size_t index, TaskHandle_t *handle)
     return true;
 }
 
+static eTaskState get_task_state(size_t index)
+{
+    return eSuspended;
+//    return s_scratch.tasks[index].eCurrentState;
+}
+
+static int get_task_cpu_id(size_t index)
+{
+    return 0;
+    // return s_scratch.tasks[index].xCoreID;
+}
+
 /** Get the index of the task running on the current CPU, and save the result */
 static void find_paniced_task_index(void)
 {
-    TaskHandle_t cur_handle = xTaskGetCurrentTaskHandleForCPU(xPortGetCoreID());
+    TaskHandle_t cur_handle = (TaskHandle_t)xTaskGetCurrentTaskHandleForCPU(xPortGetCoreID());
     TaskHandle_t handle;
     for (int i = 0; i < s_scratch.task_count; i++) {
         if (get_task_handle(i, &handle) && cur_handle == handle) {
@@ -244,7 +441,7 @@ static void set_active_task(size_t index)
 }
 
 /** H command sets the "current task" for the purpose of further commands */
-static void handle_H_command(const unsigned char* cmd, int len)
+static void handle_H_command(const unsigned char *cmd, int len)
 {
     const char *ret = "OK";
     if (cmd[1] == 'g') {
@@ -270,7 +467,7 @@ static void handle_H_command(const unsigned char* cmd, int len)
 }
 
 /** qC returns the current thread ID */
-static void handle_qC_command(const unsigned char* cmd, int len)
+static void handle_qC_command(const unsigned char *cmd, int len)
 {
     esp_gdbstub_send_start();
     esp_gdbstub_send_str("QC");
@@ -282,7 +479,7 @@ static void handle_qC_command(const unsigned char* cmd, int len)
  *  Since GDB isn't going to ask about the tasks which haven't been listed by q*ThreadInfo,
  *  and the state of tasks can not change (no stepping allowed), simply return "OK" here.
  */
-static void handle_T_command(const unsigned char* cmd, int len)
+static void handle_T_command(const unsigned char *cmd, int len)
 {
     esp_gdbstub_send_str_packet("OK");
 }
@@ -299,14 +496,14 @@ static void send_single_thread_info(int task_index)
 /** qfThreadInfo requests the start of the thread list, qsThreadInfo (below) is repeated to
  *  get the subsequent threads.
  */
-static void handle_qfThreadInfo_command(const unsigned char* cmd, int len)
+static void handle_qfThreadInfo_command(const unsigned char *cmd, int len)
 {
     assert(s_scratch.task_count > 0);  /* There should be at least one task */
     send_single_thread_info(0);
     s_scratch.thread_info_index = 1;
 }
 
-static void handle_qsThreadInfo_command(const unsigned char* cmd, int len)
+static void handle_qsThreadInfo_command(const unsigned char *cmd, int len)
 {
     int task_index = s_scratch.thread_info_index;
     if (task_index == s_scratch.task_count) {
@@ -319,7 +516,7 @@ static void handle_qsThreadInfo_command(const unsigned char* cmd, int len)
 }
 
 /** qThreadExtraInfo requests the thread name */
-static void handle_qThreadExtraInfo_command(const unsigned char* cmd, int len)
+static void handle_qThreadExtraInfo_command(const unsigned char *cmd, int len)
 {
     cmd += sizeof("qThreadExtraInfo,") - 1;
     int task_index = gdb_tid_to_task_index(esp_gdbstub_gethex(&cmd, -1));
@@ -329,19 +526,41 @@ static void handle_qThreadExtraInfo_command(const unsigned char* cmd, int len)
         return;
     }
     esp_gdbstub_send_start();
-    const char* task_name = pcTaskGetTaskName(handle);
-    while (*task_name) {
-        esp_gdbstub_send_hex(*task_name, 8);
-        task_name++;
+    esp_gdbstub_send_str_as_hex("Name: ");
+    esp_gdbstub_send_str_as_hex((const char *)pcTaskGetTaskName(handle));
+    esp_gdbstub_send_hex(' ', 8);
+
+    eTaskState state = get_task_state(task_index);
+    switch (state) {
+    case eRunning:
+        esp_gdbstub_send_str_as_hex("State: Running ");
+        esp_gdbstub_send_str_as_hex("@CPU");
+        esp_gdbstub_send_hex(get_task_cpu_id(task_index) + '0', 8);
+        break;
+    case eReady:
+        esp_gdbstub_send_str_as_hex("State: Ready");
+        break;
+    case eBlocked:
+        esp_gdbstub_send_str_as_hex("State: Blocked");
+        break;
+    case eSuspended:
+        esp_gdbstub_send_str_as_hex("State: Suspended");
+        break;
+    case eDeleted:
+        esp_gdbstub_send_str_as_hex("State: Deleted");
+        break;
+    default:
+        esp_gdbstub_send_str_as_hex("State: Invalid");
+        break;
     }
-    /** TODO: add "Running" or "Suspended" and "CPU0" or "CPU1" */
+
     esp_gdbstub_send_end();
 }
 
-bool command_name_matches(const char* pattern, const unsigned char* ucmd, int len)
+bool command_name_matches(const char *pattern, const unsigned char *ucmd, int len)
 {
-    const char* cmd = (const char*) ucmd;
-    const char* end = cmd + len;
+    const char *cmd = (const char *) ucmd;
+    const char *end = cmd + len;
     for (; *pattern && cmd < end; ++cmd, ++pattern) {
         if (*pattern == '?') {
             continue;
@@ -375,6 +594,8 @@ static int handle_task_commands(unsigned char *cmd, int len)
             /* Unrecognized command */
             return GDBSTUB_ST_ERR;
         }
+    } else if (strncmp((char *)cmd, "vCont;c", 7) == 0 || cmd[0] == 'c') { //continue execution
+        return GDBSTUB_ST_CONT;
     } else {
         /* Unrecognized command */
         return GDBSTUB_ST_ERR;
@@ -383,3 +604,4 @@ static int handle_task_commands(unsigned char *cmd, int len)
 }
 
 #endif // CONFIG_ESP_GDBSTUB_SUPPORT_TASKS
+
diff --git a/components/esp_gdbstub/src/packet.c b/components/esp_gdbstub/src/packet.c
index 9863bff8a9..a3ab60d6db 100644
--- a/components/esp_gdbstub/src/packet.c
+++ b/components/esp_gdbstub/src/packet.c
@@ -53,7 +53,7 @@ void esp_gdbstub_send_str(const char *c)
 // 'bits'/4 dictates the number of hex chars sent.
 void esp_gdbstub_send_hex(int val, int bits)
 {
-    const char* hex_chars = "0123456789abcdef";
+    const char *hex_chars = "0123456789abcdef";
     for (int i = bits; i > 0; i -= 4) {
         esp_gdbstub_send_char(hex_chars[(val >> (i - 4)) & 0xf]);
     }
@@ -68,7 +68,7 @@ void esp_gdbstub_send_end(void)
 }
 
 // Send a packet with a string as content
-void esp_gdbstub_send_str_packet(const char* str)
+void esp_gdbstub_send_str_packet(const char *str)
 {
     esp_gdbstub_send_start();
     if (str != NULL) {
@@ -164,7 +164,7 @@ int esp_gdbstub_read_command(unsigned char **out_cmd, size_t *out_size)
     // A # has been received. Get and check the received chsum.
     sentchs[0] = esp_gdbstub_getchar();
     sentchs[1] = esp_gdbstub_getchar();
-    const unsigned char* c_ptr = &sentchs[0];
+    const unsigned char *c_ptr = &sentchs[0];
     unsigned char rchsum = esp_gdbstub_gethex(&c_ptr, 8);
     if (rchsum != chsum) {
         esp_gdbstub_putchar('-');
diff --git a/components/esp_gdbstub/xtensa/gdbstub-entry.S b/components/esp_gdbstub/xtensa/gdbstub-entry.S
new file mode 100644
index 0000000000..780eed9967
--- /dev/null
+++ b/components/esp_gdbstub/xtensa/gdbstub-entry.S
@@ -0,0 +1,44 @@
+#include "freertos/xtensa_rtos.h"
+
+// ------------------------------------------------
+    .section .iram1,"ax"
+
+	.global gdbstub_handle_uart_int
+	.global _xt_gdbstub_int
+	.align	4
+
+_xt_gdbstub_int:
+
+    /* Allocate exception frame and save minimal context. */
+    mov     a0, sp
+    addi    sp, sp, -XT_STK_FRMSZ
+    s32i    a0, sp, XT_STK_A1
+    #if XCHAL_HAVE_WINDOWED
+    s32e    a0, sp, -12                     /* for debug backtrace */
+    #endif
+    rsr     a0, PS                          /* save interruptee's PS */
+    s32i    a0, sp, XT_STK_PS
+    rsr     a0, EPC_1                       /* save interruptee's PC */
+    s32i    a0, sp, XT_STK_PC
+    #if XCHAL_HAVE_WINDOWED
+    s32e    a0, sp, -16                     /* for debug backtrace */
+    #endif
+    s32i    a12, sp, XT_STK_A12             /* _xt_context_save requires A12- */
+    s32i    a13, sp, XT_STK_A13             /* A13 to have already been saved */
+
+    /* Save exc cause and vaddr into exception frame */
+    rsr     a0, EXCCAUSE
+    s32i    a0, sp, XT_STK_EXCCAUSE
+    rsr     a0, EXCVADDR
+    s32i    a0, sp, XT_STK_EXCVADDR
+
+
+    /* _xt_context_save seems to save the current a0, but we need the interuptees a0. Fix this. */
+    rsr     a0, EXCSAVE_1                   /* save interruptee's a0 */
+
+    s32i    a0, sp, XT_STK_A0
+
+    mov     a6,sp
+    call0   gdbstub_handle_uart_int
+    ret
+
diff --git a/components/esp_gdbstub/xtensa/gdbstub_xtensa.c b/components/esp_gdbstub/xtensa/gdbstub_xtensa.c
index cf8614ac5c..9640a574de 100644
--- a/components/esp_gdbstub/xtensa/gdbstub_xtensa.c
+++ b/components/esp_gdbstub/xtensa/gdbstub_xtensa.c
@@ -13,7 +13,6 @@
 // limitations under the License.
 
 #include <string.h>
-#include "esp_gdbstub.h"
 #include "esp_gdbstub_common.h"
 #include "soc/cpu.h"
 #include "soc/soc_memory_layout.h"
diff --git a/components/esp_system/Kconfig b/components/esp_system/Kconfig
index 21e4056dcd..398bafa026 100644
--- a/components/esp_system/Kconfig
+++ b/components/esp_system/Kconfig
@@ -26,11 +26,19 @@ menu "ESP System Settings"
                 Just resets the processor without outputting anything
 
         config ESP_SYSTEM_PANIC_GDBSTUB
-            bool "Invoke GDBStub"
+            bool "GDBStub on panic"
             select ESP_GDBSTUB_ENABLED
             help
                 Invoke gdbstub on the serial port, allowing for gdb to attach to it to do a postmortem
                 of the crash.
+
+        config ESP_SYSTEM_GDBSTUB_RUNTIME
+            bool "GDBStub at runtime"
+            select FREERTOS_UNICORE
+            select ESP_GDBSTUB_ENABLED
+            help
+                Invoke gdbstub on the serial port, allowing for gdb to attach to it and to do a debug on runtime.
+                This feature will switch system to single core mode.
     endchoice
 
     config ESP_SYSTEM_SINGLE_CORE_MODE
diff --git a/docs/en/api-guides/tools/idf-monitor.rst b/docs/en/api-guides/tools/idf-monitor.rst
index c689f5a1ca..cec09371ad 100644
--- a/docs/en/api-guides/tools/idf-monitor.rst
+++ b/docs/en/api-guides/tools/idf-monitor.rst
@@ -59,7 +59,10 @@ For easy interaction with IDF Monitor, use the keyboard shortcuts given in the t
    * - * Ctrl+X (or X)
      - Exit the program
      -                
-     
+   * - Ctrl+]
+     - Interrupt running application
+     - Pauses IDF monitor and run GDB_ project debugger to debug the application at runtime.     
+
 Any keys pressed, other than ``Ctrl-]`` and ``Ctrl-T``, will be sent through the serial port.
 
 
@@ -186,17 +189,20 @@ Launching GDB with GDBStub
 
 By default, if esp-idf crashes, the panic handler prints relevant registers and the stack dump (similar to the ones above) over the serial port. Then it resets the board.
 
+Furthermore, the application can be configured to run GDBStub in the background and handle the Ctrl+C event from the monitor.
+
 Optionally, the panic handler can be configured to run GDBStub, the tool which can communicate with  GDB_ project debugger. GDBStub allows to read memory, examine call stack frames and variables, etc. It is not as versatile as JTAG debugging, but this method does not require any special hardware.
 
-To enable GDBStub, open the project configuration menu (``idf.py menuconfig``) and set :ref:`CONFIG_ESP_SYSTEM_PANIC` to ``Invoke GDBStub``.
+To enable GDBStub on panic, open the project configuration menu (``idf.py menuconfig``) and set :ref:`CONFIG_ESP_SYSTEM_PANIC` to ``GDBStub on panic`` or set :ref:`CONFIG_ESP_SYSTEM_PANIC` to ``GDBStub on runtime``.
 
-In this case, if the panic handler is triggered, as soon as IDF Monitor sees that GDBStub has loaded, it automatically pauses serial monitoring and runs GDB with necessary arguments. After GDB exits, the board is reset via the RTS serial line. If this line is not connected, please reset the board manually by pressing its Reset button.
+In this case, if the panic handler or Ctrl+C command is triggered, as soon as IDF Monitor sees that GDBStub has loaded, it automatically pauses serial monitoring and runs GDB with necessary arguments. After GDB exits, the board is reset via the RTS serial line. If this line is not connected, please reset the board manually by pressing its Reset button.
 
 In the background, IDF Monitor runs the following command::
 
   {IDF_TARGET_TOOLCHAIN_PREFIX}-gdb -ex "set serial baud BAUD" -ex "target remote PORT" -ex interrupt build/PROJECT.elf :idf_target:`Hello NAME chip`
 
 
+
 Output Filtering
 ~~~~~~~~~~~~~~~~
 
diff --git a/examples/get-started/hello_world/main/CMakeLists.txt b/examples/get-started/hello_world/main/CMakeLists.txt
index 07686dc8e1..c299e03782 100644
--- a/examples/get-started/hello_world/main/CMakeLists.txt
+++ b/examples/get-started/hello_world/main/CMakeLists.txt
@@ -1,2 +1,2 @@
 idf_component_register(SRCS "hello_world_main.c"
-                    INCLUDE_DIRS "")
+                    INCLUDE_DIRS "")
\ No newline at end of file
diff --git a/examples/system/gdbstub/CMakeLists.txt b/examples/system/gdbstub/CMakeLists.txt
new file mode 100644
index 0000000000..06e470af47
--- /dev/null
+++ b/examples/system/gdbstub/CMakeLists.txt
@@ -0,0 +1,6 @@
+# The following lines of boilerplate have to be in your project's
+# CMakeLists in this exact order for cmake to work correctly
+cmake_minimum_required(VERSION 3.5)
+
+include($ENV{IDF_PATH}/tools/cmake/project.cmake)
+project(gdbstub)
\ No newline at end of file
diff --git a/examples/system/gdbstub/Makefile b/examples/system/gdbstub/Makefile
new file mode 100644
index 0000000000..a71a8bab1d
--- /dev/null
+++ b/examples/system/gdbstub/Makefile
@@ -0,0 +1,9 @@
+#
+# This is a project Makefile. It is assumed the directory this Makefile resides in is a
+# project subdirectory.
+#
+
+PROJECT_NAME := gdbstub
+
+include $(IDF_PATH)/make/project.mk
+
diff --git a/examples/system/gdbstub/README.md b/examples/system/gdbstub/README.md
new file mode 100644
index 0000000000..00391a3071
--- /dev/null
+++ b/examples/system/gdbstub/README.md
@@ -0,0 +1,127 @@
+# GDBstub example
+
+This example shows how to use gdbstub and it's functionality at runtime to debug an application with GDB. 
+With the gdbstub component it is possible to run GDB from IDF Monitor by pressing Ctrl+C and debug  
+the application using GDB. It is also possible to read/modify memory values, interrupt and continue the application.
+Upon exit from GDB, the application will continue to work in IDF Monitor as before.
+
+## How to use example
+### Hardware Required
+
+he example can run on any commonly available ESP32 development board.  
+There are two possible ways to execute gdbstub with GDB: from IDF Monitor and as standalone application.
+gdbstub support ESP32, ESP32-S2 and ESP32-S3 chips. 
+
+### Configure the project
+
+By default, the example is already pre-configured, but the user can change configuration options with the following command:
+```
+idf.py menuconfig
+``` 
+Current example is pre-configured. The user can scroll through the system parameters and see the settings.
+Most important one is:
+-> Component Config -> ESP System Settings -> Panic handler behaviour -> GDBStub on runtime
+This selection switches gdbstub to runtime mode.
+Depending on the project, following settings could be used:
+-> Component Config -> GDB Stub -> ...
+The user can enable or disable task list handling and define a maximum amount of tasks.
+Note that gdbstub can now only be used when FreeRTOS is run on the first core only. 
+This setting is located here:
+-> Component Config -> FreeRTOS -> Run FreeRTOS only on first core.
+
+### Build and Flash
+
+Build the project and flash it to the board, then run IDF Monitor to view the serial output:
+
+```
+idf.py -p PORT flash monitor
+```
+Replace PORT with the name of the serial port to use, for example COM4 for Windows or /dev/ttyUSB0 for Linux.
+To exit the serial monitor, type ``Ctrl-]``.
+See the Getting Started Guide for full steps to configure and use ESP-IDF to build projects.
+
+In addition, it is also possible to run GDB and connect to the Esp32 directly, without IDF Monitor.
+```
+xtensa-esp32-elf-gdb ./build/gdbstub.elf -ex "set serial baud 115200" -ex "target remote \\.\COM10"
+```
+This will execute GDB and GDB will connect to your Esp32 by serial port COM10 with baudrate 115200.
+
+## Example Output
+
+The example demonstrates how to switch to GDB, watch values, change values, continue to run, and exit from GDB to the application.  
+To switch to GDB, the user presses Ctrl+C. This will stop the application and run the GDB.
+In GDB, the user can print values "print call_count" and "print update_log_level" and then
+change them  "set call_count 100" and "set update_log_level = ESP_LOG_WARN".
+The user can continue running the application in GDB by entering "continue" and then interrupt the application by pressing Ctrl+C.
+The user can check again that the application has worked by checking variable "print call_count".
+The user can exit from GDB to continue seeing the trace from IDF Monitor by pressing "quit" and then "y".  
+The user will see in IDF Monitor that call_count and logging level have changed.
+A typical console output for such a scenario is shown below:
+```
+I (300) cpu_start: Starting scheduler on PRO CPU.
+Hello GDB example!
+I (307) gdbstub_example: INFO  mode enabled. Call - 0. To enter GDB please press "Ctrl+C"
+W (317) gdbstub_example: WARN  mode enabled. Call - 0. To enter GDB please press "Ctrl+C"
+I (1317) gdbstub_example: INFO  mode enabled. Call - 1. To enter GDB please press "Ctrl+C"
+W (1317) gdbstub_example: WARN  mode enabled. Call - 1. To enter GDB please press "Ctrl+C"
+To exit from the idf.py please use "Ctrl+]"
+$T02#b6GNU gdb (crosstool-NG esp-2020r3) 8.1.0.20180627-git
+Copyright (C) 2018 Free Software Foundation, Inc.
+License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
+This is free software: you are free to change and redistribute it.
+There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
+and "show warranty" for details.
+This GDB was configured as "--host=x86_64-host_w64-mingw32 --target=xtensa-esp32-elf".
+Type "show configuration" for configuration details.
+For bug reporting instructions, please see:
+<http://www.gnu.org/software/gdb/bugs/>.
+Find the GDB manual and other documentation resources online at:
+<http://www.gnu.org/software/gdb/documentation/>.
+For help, type "help".
+Type "apropos word" to search for commands related to "word"...
+Reading symbols from c:\esp-idf\examples\system\gdbstub\build\gdbstub.elf...done.
+Remote debugging using \\.\COM15
+0x400dff0a in esp_pm_impl_waiti () at C:/esp-idf/components/esp_pm/pm_impl.c:533
+533         asm("waiti 0");
+(gdb) print call_count
+$1 = 2
+(gdb) set call_count = 100
+(gdb) print call_count
+$2 = 100
+(gdb) print update_log_level
+$3 = ESP_LOG_DEBUG
+(gdb) set update_log_level = ESP_LOG_WARN
+(gdb) print update_log_level
+$4 = ESP_LOG_WARN
+(gdb) c
+Continuing.
+
+Thread 1 received signal SIGINT, Interrupt.
+0x400dff0a in esp_pm_impl_waiti () at C:/esp-idf/components/esp_pm/pm_impl.c:533
+533         asm("waiti 0");
+(gdb) print call_count
+$6 = 108
+(gdb) quit
+A debugging session is active.
+
+        Inferior 1 [Remote target] will be killed.
+
+Quit anyway? (y or n) y
+W (13977) gdbstub_example: WARN  mode enabled. Call - 108. To enter GDB please press "Ctrl+C"
+W (14977) gdbstub_example: WARN  mode enabled. Call - 109. To enter GDB please press "Ctrl+C"
+W (15977) gdbstub_example: WARN  mode enabled. Call - 110. To enter GDB please press "Ctrl+C"
+W (16977) gdbstub_example: WARN  mode enabled. Call - 111. To enter GDB please press "Ctrl+C"
+```
+
+To reproduce this scenario run the application by: idf.py -P PORT flash monitor
+Then:
+1. Interrupt the application by pressing Ctrl+C
+2. In GDB, print the application values by typing in GDB command line "print call_count" or "print update_log_level"  
+3. Modify the application values by typing in GDB command line "set call_count = 100" or "set update_log_level = ESP_LOG_WARN"
+4. Continue the application by typing in GDB command line "continue"
+5. Interrupt application by pressing Ctrl+C
+6. Check the value by typing in GDB command line "print call_count" or "print update_log_level"
+7. Exit GDB by typing "quit" and then "y"
+
+To exit from monitor please use Ctrl+]
+
diff --git a/examples/system/gdbstub/main/CMakeLists.txt b/examples/system/gdbstub/main/CMakeLists.txt
new file mode 100644
index 0000000000..7e624c9c17
--- /dev/null
+++ b/examples/system/gdbstub/main/CMakeLists.txt
@@ -0,0 +1,2 @@
+idf_component_register(SRCS "gdbstub_main.c"
+                    INCLUDE_DIRS "")
\ No newline at end of file
diff --git a/examples/system/gdbstub/main/component.mk b/examples/system/gdbstub/main/component.mk
new file mode 100644
index 0000000000..0b9d7585e7
--- /dev/null
+++ b/examples/system/gdbstub/main/component.mk
@@ -0,0 +1,5 @@
+#
+# "main" pseudo-component makefile.
+#
+# (Uses default behaviour of compiling all source files in directory, adding 'include' to include path.)
+
diff --git a/examples/system/gdbstub/main/gdbstub_main.c b/examples/system/gdbstub/main/gdbstub_main.c
new file mode 100644
index 0000000000..0884a7757b
--- /dev/null
+++ b/examples/system/gdbstub/main/gdbstub_main.c
@@ -0,0 +1,39 @@
+/* Hello World Example
+
+   This example code is in the Public Domain (or CC0 licensed, at your option.)
+
+   Unless required by applicable law or agreed to in writing, this
+   software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+   CONDITIONS OF ANY KIND, either express or implied.
+*/
+#include <stdio.h>
+#include "sdkconfig.h"
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+#include "esp_system.h"
+#include "esp_log.h"
+
+
+int call_count = 0;
+
+static const char *TAG = "gdbstub_example";
+esp_log_level_t log_level = ESP_LOG_DEBUG;
+esp_log_level_t update_log_level = ESP_LOG_DEBUG;
+
+void app_main(void)
+{
+    printf("Hello GDB example!\n");
+
+    call_count = 0;
+
+    for (;;) {
+        ESP_LOGD(TAG, "DEBUG mode enabled. Call - %i. To enter GDB please press \"Ctrl+C\"", call_count);
+        ESP_LOGI(TAG, "INFO  mode enabled. Call - %i. To enter GDB please press \"Ctrl+C\"", call_count);
+        ESP_LOGW(TAG, "WARN  mode enabled. Call - %i. To enter GDB please press \"Ctrl+C\"", call_count++);
+        if (update_log_level != log_level) {
+            log_level = update_log_level;
+            esp_log_level_set(TAG, log_level);
+        }
+        vTaskDelay(1000 / portTICK_PERIOD_MS);
+    }
+}
diff --git a/examples/system/gdbstub/sdkconfig.defaults b/examples/system/gdbstub/sdkconfig.defaults
new file mode 100644
index 0000000000..e679222122
--- /dev/null
+++ b/examples/system/gdbstub/sdkconfig.defaults
@@ -0,0 +1,22 @@
+#
+# GDB Stub
+#
+CONFIG_ESP_GDBSTUB_ENABLED=y
+CONFIG_ESP_GDBSTUB_SUPPORT_TASKS=y
+CONFIG_ESP_GDBSTUB_MAX_TASKS=32
+# end of GDB Stub
+
+#
+# FreeRTOS
+#
+CONFIG_FREERTOS_UNICORE=y
+
+#
+# ESP System Settings
+#
+# CONFIG_ESP_SYSTEM_PANIC_PRINT_HALT is not set
+# CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT is not set
+# CONFIG_ESP_SYSTEM_PANIC_SILENT_REBOOT is not set
+CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME=y
+CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE=y
+# end of ESP System Settings
\ No newline at end of file
-- 
2.25.1


From c6e3eb0922736b4d65e93ec30196625f4d81140c Mon Sep 17 00:00:00 2001
From: Dmitry <Dmitry.Yakovlev@espressif.com>
Date: Thu, 15 Apr 2021 10:54:15 +0300
Subject: [PATCH 08/43] idf.py.exe changes to handle Ctrl+C in correct way.
 Handling Ctrl+C in correct way for gdbstubs.

---
 tools/idf.py                     | 12 ++++++++++++
 tools/windows/idf_exe/idf_main.c | 14 ++++++++++++++
 2 files changed, 26 insertions(+)

diff --git a/tools/idf.py b/tools/idf.py
index 4e296c58aa..273eb24766 100755
--- a/tools/idf.py
+++ b/tools/idf.py
@@ -39,6 +39,9 @@ from collections import Counter, OrderedDict
 from importlib import import_module
 from pkgutil import iter_modules
 
+import signal
+
+
 # pyc files remain in the filesystem when switching between branches which might raise errors for incompatible
 # idf.py extensions. Therefore, pyc file generation is turned off:
 sys.dont_write_bytecode = True
@@ -723,7 +726,16 @@ def init_cli(verbose_output=None):
     return CLI(help=cli_help, verbose_output=verbose_output, all_actions=all_actions)
 
 
+def signal_handler(signal, frame):
+    # The Ctrl+C processed by other threads inside
+    pass
+
+
 def main():
+
+    # Processing of Ctrl+C event for all threads made by main()
+    signal.signal(signal.SIGINT, signal_handler)
+
     checks_output = check_environment()
     cli = init_cli(verbose_output=checks_output)
     # the argument `prog_name` must contain name of the file - not the absolute path to it!
diff --git a/tools/windows/idf_exe/idf_main.c b/tools/windows/idf_exe/idf_main.c
index cbfcf7990f..dbbe267305 100644
--- a/tools/windows/idf_exe/idf_main.c
+++ b/tools/windows/idf_exe/idf_main.c
@@ -16,6 +16,9 @@
 #include <shlwapi.h>
 #include <strsafe.h>
 #include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
 
 #define LINESIZE 1024
 
@@ -43,6 +46,17 @@ BOOL WINAPI CtrlHandler(DWORD fdwCtrlType)
     }
 }
 
+BOOL WINAPI CtrlHandler(DWORD fdwCtrlType)
+{
+    switch (fdwCtrlType) {
+    // Handle the CTRL-C signal.
+    case CTRL_C_EVENT:
+        return TRUE;
+    default:
+        return FALSE;
+    }
+}
+
 int main(int argc, LPTSTR argv[])
 {
     /* Print the version of this wrapper tool, but only if invoked as "idf.exe".
-- 
2.25.1


From a16ae6c73741f01b2458faaa890eed7b8f3d36cc Mon Sep 17 00:00:00 2001
From: Dmitry <Dmitry.Yakovlev@espressif.com>
Date: Fri, 16 Apr 2021 13:59:50 +0300
Subject: [PATCH 09/43] IDF monitor update

---
 tools/idf_monitor.py                    | 111 +++++++++++++++++-------
 tools/idf_monitor_base/serial_reader.py |  24 ++++-
 2 files changed, 103 insertions(+), 32 deletions(-)

diff --git a/tools/idf_monitor.py b/tools/idf_monitor.py
index e1a9164b5c..465db7ad32 100755
--- a/tools/idf_monitor.py
+++ b/tools/idf_monitor.py
@@ -140,6 +140,8 @@ class Monitor(object):
         self._decode_panic = decode_panic
         self._reading_panic = PANIC_IDLE
         self._panic_buffer = b''
+        self.gdb_exit = False
+        self.start_cmd_sent = False
 
     def invoke_processing_last_line(self):
         # type: () -> None
@@ -149,43 +151,70 @@ class Monitor(object):
         # type: () -> None
         self.console_reader.start()
         self.serial_reader.start()
+        self.gdb_exit = False
+        self.start_cmd_sent = False
         try:
             while self.console_reader.alive and self.serial_reader.alive:
                 try:
-                    item = self.cmd_queue.get_nowait()
-                except queue.Empty:
+                    if self.gdb_exit is True:
+                        self.gdb_exit = False
+
+                        time.sleep(0.3)
+                        try:
+                            # Continue the program after exit from the GDB
+                            self.serial.write(codecs.encode('+$c#63'))
+                            self.start_cmd_sent = True
+                        except serial.SerialException:
+                            pass  # this shouldn't happen, but sometimes port has closed in serial thread
+                        except UnicodeEncodeError:
+                            pass  # this can happen if a non-ascii character was passed, ignoring
+
                     try:
-                        item = self.event_queue.get(True, 0.03)
+                        item = self.cmd_queue.get_nowait()
                     except queue.Empty:
-                        continue
-
-                event_tag, data = item
-                if event_tag == TAG_CMD:
-                    self.handle_commands(data, self.target)
-                elif event_tag == TAG_KEY:
+                        try:
+                            item = self.event_queue.get(True, 0.03)
+                        except queue.Empty:
+                            continue
+
+                    (event_tag, data) = item
+
+                    if event_tag == TAG_CMD:
+                        self.handle_commands(data, self.target)
+                    elif event_tag == TAG_KEY:
+                        try:
+                            self.serial.write(codecs.encode(data))
+                        except serial.SerialException:
+                            pass  # this shouldn't happen, but sometimes port has closed in serial thread
+                        except UnicodeEncodeError:
+                            pass  # this can happen if a non-ascii character was passed, ignoring
+                    elif event_tag == TAG_SERIAL:
+                        self.handle_serial_input(data)
+                        if self._invoke_processing_last_line_timer is not None:
+                            self._invoke_processing_last_line_timer.cancel()
+                        self._invoke_processing_last_line_timer = threading.Timer(0.1, self.invoke_processing_last_line)
+                        self._invoke_processing_last_line_timer.start()
+                        # If no futher data is received in the next short period
+                        # of time then the _invoke_processing_last_line_timer
+                        # generates an event which will result in the finishing of
+                        # the last line. This is fix for handling lines sent
+                        # without EOL.
+                    elif event_tag == TAG_SERIAL_FLUSH:
+                        self.handle_serial_input(data, finalize_line=True)
+                    else:
+                        raise RuntimeError("Bad event data %r" % ((event_tag,data),))
+                except KeyboardInterrupt:
                     try:
-                        self.serial.write(codecs.encode(data))
+                        yellow_print("To exit from IDF monitor please use \"Ctrl+]\"")
+                        self.serial.write(codecs.encode('\x03'))
                     except serial.SerialException:
                         pass  # this shouldn't happen, but sometimes port has closed in serial thread
                     except UnicodeEncodeError:
                         pass  # this can happen if a non-ascii character was passed, ignoring
-                elif event_tag == TAG_SERIAL:
-                    self.handle_serial_input(data)
-                    if self._invoke_processing_last_line_timer is not None:
-                        self._invoke_processing_last_line_timer.cancel()
-                    self._invoke_processing_last_line_timer = threading.Timer(0.1, self.invoke_processing_last_line)
-                    self._invoke_processing_last_line_timer.start()
-                    # If no further data is received in the next short period
-                    # of time then the _invoke_processing_last_line_timer
-                    # generates an event which will result in the finishing of
-                    # the last line. This is fix for handling lines sent
-                    # without EOL.
-                elif event_tag == TAG_SERIAL_FLUSH:
-                    self.handle_serial_input(data, finalize_line=True)
-                else:
-                    raise RuntimeError('Bad event data %r' % ((event_tag, data),))
         except SerialStopException:
             normal_print('Stopping condition has been received\n')
+        except KeyboardInterrupt:
+            pass
         finally:
             try:
                 self.console_reader.stop()
@@ -200,6 +229,13 @@ class Monitor(object):
 
     def handle_serial_input(self, data, finalize_line=False):
         # type: (bytes, bool) -> None
+        # Remove "+" after Continue command
+        if self.start_cmd_sent is True:
+            self.start_cmd_sent = False
+            pos = data.find(b"+")
+            if pos != -1:
+                data = data[1:]
+
         sp = data.split(b'\n')
         if self._last_line_part != b'':
             # add unprocessed part from previous "data" to the first line
@@ -260,6 +296,7 @@ class Monitor(object):
     def __exit__(self, *args, **kwargs):  # type: ignore
         """ Use 'with self' to temporarily disable monitoring behaviour """
         self.console_reader.start()
+        self.serial_reader.gdb_exit = self.gdb_exit     # write gdb_exit flag
         self.serial_reader.start()
 
     def prompt_next_action(self, reason):  # type: (str) -> None
@@ -480,10 +517,25 @@ class Monitor(object):
                 cmd = ['%sgdb' % self.toolchain_prefix,
                        '-ex', 'set serial baud %d' % self.serial.baudrate,
                        '-ex', 'target remote %s' % self.serial.port,
-                       '-ex', 'interrupt',  # monitor has already parsed the first 'reason' command, need a second
                        self.elf_file]
-                process = subprocess.Popen(cmd, cwd='.')
-                process.wait()
+
+                # Here we handling GDB as a process
+                if True:
+                    # Open GDB process
+                    try:
+                        process = subprocess.Popen(cmd, cwd=".")
+                    except KeyboardInterrupt:
+                        pass
+
+                    # We ignore Ctrl+C interrupt form external process abd wait responce util GDB will be finished.
+                    while True:
+                        try:
+                            process.wait()
+                            break
+                        except KeyboardInterrupt:
+                            pass    # We ignore the Ctrl+C
+                    self.gdb_exit = True
+
             except OSError as e:
                 red_print('%s: %s' % (' '.join(cmd), e))
             except KeyboardInterrupt:
@@ -499,7 +551,6 @@ class Monitor(object):
                     subprocess.call(['stty', 'sane'])
                 except Exception:
                     pass  # don't care if there's no stty, we tried...
-            self.prompt_next_action('gdb exited')
 
     def output_enable(self, enable):  # type: (bool) -> None
         self._output_enabled = enable
@@ -733,6 +784,8 @@ def main():  # type: () -> None
             yellow_print('--- Print filter: {} ---'.format(args.print_filter))
 
         monitor.main_loop()
+    except KeyboardInterrupt:
+        pass
     finally:
         if ws:
             ws.close()
diff --git a/tools/idf_monitor_base/serial_reader.py b/tools/idf_monitor_base/serial_reader.py
index 29e26860b0..c3b7a60bf0 100644
--- a/tools/idf_monitor_base/serial_reader.py
+++ b/tools/idf_monitor_base/serial_reader.py
@@ -38,6 +38,7 @@ class SerialReader(StoppableThread):
         self.baud = serial_instance.baudrate
         self.serial = serial_instance
         self.event_queue = event_queue
+        self.gdb_exit = False
         if not hasattr(self.serial, 'cancel_read'):
             # enable timeout for checking alive flag,
             # if cancel_read not available
@@ -47,10 +48,27 @@ class SerialReader(StoppableThread):
         #  type: () -> None
         if not self.serial.is_open:
             self.serial.baudrate = self.baud
-            self.serial.rts = True  # Force an RTS reset on open
+            # We can come to this thread at startup or from external application line GDB.
+            # If we come from GDB we would like to continue to run without reset.
+            if self.gdb_exit is False:
+                # This sequence of DTR/RTS and open/close set the serial port to
+                # condition when GDB not make reset of the target by switching DTR/RTS.
+                self.serial.rts = True  # IO0=LOW
+                self.serial.dtr = self.serial.dtr   # usbser.sys workaround
+                self.serial.open()
+                self.serial.close()
+                self.serial.rts = False     # IO0=HIGH
+                self.serial.dtr = False
+            else:                           # if we exit from GDB, we don't need to reset the target
+                self.serial.rts = False
+                self.serial.dtr = True
+
+            # Current state not reset the target!
+            self.gdb_exit = False
             self.serial.open()
-            self.serial.rts = False
-            self.serial.dtr = self.serial.dtr  # usbser.sys workaround
+            time.sleep(0.005)  # Add a delay to meet the requirements of minimal EN low time (2ms for ESP32-C3)
+            self.serial.rts = False             # Set rts/dtr to the working state
+            self.serial.dtr = self.serial.dtr   # usbser.sys workaround
         try:
             while self.alive:
                 try:
-- 
2.25.1


From f8197c244652abd9b1488aec9f8245b2a62692c8 Mon Sep 17 00:00:00 2001
From: Dmitry <Dmitry.Yakovlev@espressif.com>
Date: Fri, 16 Apr 2021 13:59:37 +0300
Subject: [PATCH 10/43] Fix problem with panic handler with gdbstubs.

---
 components/esp_gdbstub/include/esp_gdbstub.h  |  1 +
 .../private_include/esp_gdbstub_common.h      |  1 +
 components/esp_gdbstub/src/gdbstub.c          |  3 +-
 .../esp_gdbstub/xtensa/esp_gdbstub_arch.h     |  1 -
 components/esp_system/panic.c                 | 93 +++++++------------
 5 files changed, 38 insertions(+), 61 deletions(-)

diff --git a/components/esp_gdbstub/include/esp_gdbstub.h b/components/esp_gdbstub/include/esp_gdbstub.h
index d896e77ffc..f1e7921de6 100644
--- a/components/esp_gdbstub/include/esp_gdbstub.h
+++ b/components/esp_gdbstub/include/esp_gdbstub.h
@@ -19,6 +19,7 @@ extern "C" {
 #endif
 
 void esp_gdbstub_init(void);
+void esp_gdbstub_panic_handler(void *frame);
 
 #ifdef __cplusplus
 }
diff --git a/components/esp_gdbstub/private_include/esp_gdbstub_common.h b/components/esp_gdbstub/private_include/esp_gdbstub_common.h
index cb3d341c32..d9f261c9d2 100644
--- a/components/esp_gdbstub/private_include/esp_gdbstub_common.h
+++ b/components/esp_gdbstub/private_include/esp_gdbstub_common.h
@@ -18,6 +18,7 @@
 #include <stddef.h>
 #include <stdbool.h>
 
+#include "gdbstub_target_config.h"
 #include "esp_gdbstub_arch.h"
 #include "sdkconfig.h"
 
diff --git a/components/esp_gdbstub/src/gdbstub.c b/components/esp_gdbstub/src/gdbstub.c
index b58fec135e..993d5e9e6b 100644
--- a/components/esp_gdbstub/src/gdbstub.c
+++ b/components/esp_gdbstub/src/gdbstub.c
@@ -45,8 +45,9 @@ static esp_gdbstub_gdb_regfile_t *gdb_local_regfile = &s_scratch.regfile;
 /**
  * @breef panic handler
 */
-void esp_gdbstub_panic_handler(esp_gdbstub_frame_t *frame)
+void esp_gdbstub_panic_handler(void *in_frame)
 {
+    esp_gdbstub_frame_t* frame = (esp_gdbstub_frame_t*)in_frame;
 #ifndef CONFIG_ESP_GDBSTUB_SUPPORT_TASKS
     esp_gdbstub_frame_to_regfile(frame, &s_scratch.regfile);
 #else
diff --git a/components/esp_gdbstub/xtensa/esp_gdbstub_arch.h b/components/esp_gdbstub/xtensa/esp_gdbstub_arch.h
index 18b119cb3f..4730e0a124 100644
--- a/components/esp_gdbstub/xtensa/esp_gdbstub_arch.h
+++ b/components/esp_gdbstub/xtensa/esp_gdbstub_arch.h
@@ -15,7 +15,6 @@
 #pragma once
 #include <stdint.h>
 #include "freertos/xtensa_context.h"
-#include "gdbstub_target_config.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/components/esp_system/panic.c b/components/esp_system/panic.c
index baa14dba80..7a55653a38 100644
--- a/components/esp_system/panic.c
+++ b/components/esp_system/panic.c
@@ -30,7 +30,6 @@
 
 #include "esp_private/panic_internal.h"
 #include "port/panic_funcs.h"
-#include "esp_rom_sys.h"
 
 #include "sdkconfig.h"
 
@@ -59,10 +58,6 @@
 #include "esp_gdbstub.h"
 #endif
 
-#if CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG
-#include "hal/usb_serial_jtag_ll.h"
-#endif
-
 bool g_panic_abort = false;
 static char *s_panic_abort_details = NULL;
 
@@ -73,13 +68,13 @@ static wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1
 #if !CONFIG_ESP_SYSTEM_PANIC_SILENT_REBOOT
 
 #if CONFIG_ESP_CONSOLE_UART
-static uart_hal_context_t s_panic_uart = { .dev = CONFIG_ESP_CONSOLE_UART_NUM == 0 ? &UART0 :&UART1 };
+static uart_hal_context_t s_panic_uart = { .dev = CONFIG_ESP_CONSOLE_UART_NUM == 0 ? &UART0 : &UART1 };
 
 void panic_print_char(const char c)
 {
     uint32_t sz = 0;
-    while (!uart_hal_get_txfifo_len(&s_panic_uart));
-    uart_hal_write_txfifo(&s_panic_uart, (uint8_t *) &c, 1, &sz);
+    while(!uart_hal_get_txfifo_len(&s_panic_uart));
+    uart_hal_write_txfifo(&s_panic_uart, (uint8_t*) &c, 1, &sz);
 }
 #endif // CONFIG_ESP_CONSOLE_UART
 
@@ -92,27 +87,6 @@ void panic_print_char(const char c)
 }
 #endif // CONFIG_ESP_CONSOLE_USB_CDC
 
-#if CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG
-//Timeout; if there's no host listening, the txfifo won't ever
-//be writable after the first packet.
-
-#define USBSERIAL_TIMEOUT_MAX_US 50000
-static int s_usbserial_timeout = 0;
-
-void panic_print_char(const char c)
-{
-    while (!usb_serial_jtag_ll_txfifo_writable() && s_usbserial_timeout < (USBSERIAL_TIMEOUT_MAX_US / 100)) {
-        esp_rom_delay_us(100);
-        s_usbserial_timeout++;
-    }
-    if (usb_serial_jtag_ll_txfifo_writable()) {
-        usb_serial_jtag_ll_write_txfifo((const uint8_t *)&c, 1);
-        s_usbserial_timeout = 0;
-    }
-}
-#endif //CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG
-
-
 #if CONFIG_ESP_CONSOLE_NONE
 void panic_print_char(const char c)
 {
@@ -122,7 +96,7 @@ void panic_print_char(const char c)
 
 void panic_print_str(const char *str)
 {
-    for (int i = 0; str[i] != 0; i++) {
+    for(int i = 0; str[i] != 0; i++) {
         panic_print_char(str[i]);
     }
 }
@@ -171,7 +145,7 @@ static void reconfigure_all_wdts(void)
     //Reconfigure TWDT (Timer Group 0)
     wdt_hal_init(&wdt0_context, WDT_MWDT0, MWDT0_TICK_PRESCALER, false); //Prescaler: wdt counts in ticks of TG0_WDT_TICK_US
     wdt_hal_write_protect_disable(&wdt0_context);
-    wdt_hal_config_stage(&wdt0_context, 0, 1000 * 1000 / MWDT0_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM); //1 second before reset
+    wdt_hal_config_stage(&wdt0_context, 0, 1000*1000/MWDT0_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM);   //1 second before reset
     wdt_hal_enable(&wdt0_context);
     wdt_hal_write_protect_enable(&wdt0_context);
 
@@ -216,29 +190,29 @@ void esp_panic_handler(panic_info_t *info)
         info->exception = PANIC_EXCEPTION_ABORT;
     }
 
-    /*
-      * For any supported chip, the panic handler prints the contents of panic_info_t in the following format:
-      *
-      *
-      * Guru Meditation Error: Core <core> (<exception>). <description>
-      * <details>
-      *
-      * <state>
-      *
-      * <elf_info>
-      *
-      *
-      * ----------------------------------------------------------------------------------------
-      * core - core where exception was triggered
-      * exception - what kind of exception occured
-      * description - a short description regarding the exception that occured
-      * details - more details about the exception
-      * state - processor state like register contents, and backtrace
-      * elf_info - details about the image currently running
-      *
-      * NULL fields in panic_info_t are not printed.
-      *
-      * */
+   /*
+     * For any supported chip, the panic handler prints the contents of panic_info_t in the following format:
+     *
+     *
+     * Guru Meditation Error: Core <core> (<exception>). <description>
+     * <details>
+     *
+     * <state>
+     *
+     * <elf_info>
+     *
+     *
+     * ----------------------------------------------------------------------------------------
+     * core - core where exception was triggered
+     * exception - what kind of exception occured
+     * description - a short description regarding the exception that occured
+     * details - more details about the exception
+     * state - processor state like register contents, and backtrace
+     * elf_info - details about the image currently running
+     *
+     * NULL fields in panic_info_t are not printed.
+     *
+     * */
     if (info->reason) {
         panic_print_str("Guru Meditation Error: Core ");
         panic_print_dec(info->core);
@@ -322,7 +296,7 @@ void esp_panic_handler(panic_info_t *info)
     wdt_hal_disable(&rtc_wdt_ctx);
     wdt_hal_write_protect_enable(&rtc_wdt_ctx);
     panic_print_str("Entering gdb stub now.\r\n");
-    esp_gdbstub_panic_handler((esp_gdbstub_frame_t *)info->frame);
+    esp_gdbstub_panic_handler(info->frame);
 #else
 #if CONFIG_ESP_COREDUMP_ENABLE
     static bool s_dumping_core;
@@ -347,7 +321,8 @@ void esp_panic_handler(panic_info_t *info)
 #if CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT || CONFIG_ESP_SYSTEM_PANIC_SILENT_REBOOT
 
     if (esp_reset_reason_get_hint() == ESP_RST_UNKNOWN) {
-        switch (info->exception) {
+        switch (info->exception)
+        {
         case PANIC_EXCEPTION_IWDT:
             esp_reset_reason_set_hint(ESP_RST_INT_WDT);
             break;
@@ -373,10 +348,10 @@ void esp_panic_handler(panic_info_t *info)
 }
 
 
-void __attribute__((noreturn,no_sanitize_undefined)) panic_abort(const char *details)
+void __attribute__((noreturn)) panic_abort(const char *details)
 {
     g_panic_abort = true;
-    s_panic_abort_details = (char *) details;
+    s_panic_abort_details = (char*) details;
 
 #if CONFIG_APPTRACE_ENABLE
 #if CONFIG_SYSVIEW_ENABLE
@@ -388,7 +363,7 @@ void __attribute__((noreturn,no_sanitize_undefined)) panic_abort(const char *det
 #endif
 
     *((int *) 0) = 0; // NOLINT(clang-analyzer-core.NullDereference) should be an invalid operation on targets
-    while (1);
+    while(1);
 }
 
 /* Weak versions of reset reason hint functions.
-- 
2.25.1


From 00a7ecb5a319a3901f3861f6c6ce3edc67bc3c1f Mon Sep 17 00:00:00 2001
From: Dmitry <Dmitry.Yakovlev@espressif.com>
Date: Mon, 19 Apr 2021 12:03:43 +0300
Subject: [PATCH 11/43] Code cleanup. Bugfix after rebase with master.
 Formating.

---
 components/esp_gdbstub/CMakeLists.txt         | 25 +++--
 components/esp_gdbstub/component.mk           |  2 +-
 components/esp_gdbstub/esp32/gdbstub_esp32.c  | 18 ----
 .../esp_gdbstub/esp32s2/gdbstub_esp32s2.c     | 18 ----
 .../esp_gdbstub/esp32s3/gdbstub_esp32s3.c     | 19 ----
 .../esp_gdbstub/esp_common/gdbstub_common.c   |  6 +-
 components/esp_gdbstub/riscv/gdbstub_riscv.c  |  5 +
 components/esp_gdbstub/src/gdbstub.c          | 47 ++--------
 .../esp_gdbstub/xtensa/esp_gdbstub_arch.h     |  1 +
 components/esp_gdbstub/xtensa/gdbstub-entry.S |  1 -
 components/esp_system/panic.c                 | 93 ++++++++++++-------
 components/freertos/port/port_common.c        |  8 ++
 docs/en/api-guides/tools/idf-monitor.rst      |  6 +-
 .../hello_world/main/CMakeLists.txt           |  2 +-
 examples/system/gdbstub/CMakeLists.txt        |  2 +-
 examples/system/gdbstub/Makefile              |  1 -
 examples/system/gdbstub/main/CMakeLists.txt   |  2 +-
 examples/system/gdbstub/main/component.mk     |  1 -
 examples/system/gdbstub/sdkconfig.defaults    |  2 +-
 tools/idf.py                                  |  6 +-
 tools/idf_monitor.py                          | 33 ++++---
 tools/idf_monitor_base/serial_reader.py       | 10 +-
 tools/windows/idf_exe/idf_main.c              | 14 ---
 23 files changed, 129 insertions(+), 193 deletions(-)
 delete mode 100644 components/esp_gdbstub/esp32/gdbstub_esp32.c
 delete mode 100644 components/esp_gdbstub/esp32s2/gdbstub_esp32s2.c
 delete mode 100644 components/esp_gdbstub/esp32s3/gdbstub_esp32s3.c

diff --git a/components/esp_gdbstub/CMakeLists.txt b/components/esp_gdbstub/CMakeLists.txt
index cb799481b3..797448b10a 100644
--- a/components/esp_gdbstub/CMakeLists.txt
+++ b/components/esp_gdbstub/CMakeLists.txt
@@ -1,15 +1,20 @@
 idf_build_get_property(target IDF_TARGET)
 
-set(esp_gdbstub_srcs "src/gdbstub.c"
-                     "src/packet.c"
-                     "esp_common/gdbstub_common.c"
-                     "${target}/gdbstub_${target}.c"
-                     "xtensa/gdbstub-entry.S"
-                     "xtensa/gdbstub_xtensa.c")
-
-idf_component_register(SRCS "${esp_gdbstub_srcs}"
+idf_component_register(SRCS "src/gdbstub.c" "src/packet.c"
                        INCLUDE_DIRS "include"
-                       PRIV_INCLUDE_DIRS "private_include" "${target}" "xtensa"
+                       PRIV_INCLUDE_DIRS "private_include"
                        LDFRAGMENTS "linker.lf"
                        REQUIRES "freertos"
-                       PRIV_REQUIRES "soc" "xtensa" "esp_rom")
+                       PRIV_REQUIRES "soc" "esp_rom")
+
+if(CONFIG_IDF_TARGET_ARCH_XTENSA)
+    target_include_directories(${COMPONENT_LIB} PUBLIC "xtensa" "${target}")
+    target_sources(${COMPONENT_LIB} PRIVATE "xtensa/gdbstub_xtensa.c"
+                                            "xtensa/gdbstub-entry.S"
+                                            "esp_common/gdbstub_common.c")
+
+elseif(CONFIG_IDF_TARGET_ARCH_RISCV)
+    target_include_directories(${COMPONENT_LIB} PUBLIC "riscv" "${target}")
+    target_sources(${COMPONENT_LIB} PRIVATE "riscv/gdbstub_riscv.c"
+    "${target}/gdbstub_${target}.c")
+endif()
diff --git a/components/esp_gdbstub/component.mk b/components/esp_gdbstub/component.mk
index 97dfce265f..91e522594d 100644
--- a/components/esp_gdbstub/component.mk
+++ b/components/esp_gdbstub/component.mk
@@ -1,4 +1,4 @@
 COMPONENT_ADD_INCLUDEDIRS := include
 COMPONENT_PRIV_INCLUDEDIRS := private_include esp32 xtensa
-COMPONENT_SRCDIRS := src esp32 xtensa
+COMPONENT_SRCDIRS := src esp32 xtensa esp_common
 COMPONENT_ADD_LDFRAGMENTS += linker.lf
diff --git a/components/esp_gdbstub/esp32/gdbstub_esp32.c b/components/esp_gdbstub/esp32/gdbstub_esp32.c
deleted file mode 100644
index 39fde0a6c7..0000000000
--- a/components/esp_gdbstub/esp32/gdbstub_esp32.c
+++ /dev/null
@@ -1,18 +0,0 @@
-// Copyright 2015-2019 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include "soc/uart_periph.h"
-#include "soc/gpio_periph.h"
-#include "esp_gdbstub_common.h"
-#include "sdkconfig.h"
diff --git a/components/esp_gdbstub/esp32s2/gdbstub_esp32s2.c b/components/esp_gdbstub/esp32s2/gdbstub_esp32s2.c
deleted file mode 100644
index 39fde0a6c7..0000000000
--- a/components/esp_gdbstub/esp32s2/gdbstub_esp32s2.c
+++ /dev/null
@@ -1,18 +0,0 @@
-// Copyright 2015-2019 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include "soc/uart_periph.h"
-#include "soc/gpio_periph.h"
-#include "esp_gdbstub_common.h"
-#include "sdkconfig.h"
diff --git a/components/esp_gdbstub/esp32s3/gdbstub_esp32s3.c b/components/esp_gdbstub/esp32s3/gdbstub_esp32s3.c
deleted file mode 100644
index 1e02fec0d0..0000000000
--- a/components/esp_gdbstub/esp32s3/gdbstub_esp32s3.c
+++ /dev/null
@@ -1,19 +0,0 @@
-// Copyright 2015-2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include "sdkconfig.h"
-#include "soc/uart_periph.h"
-#include "soc/gpio_periph.h"
-#include "esp_gdbstub_common.h"
-
diff --git a/components/esp_gdbstub/esp_common/gdbstub_common.c b/components/esp_gdbstub/esp_common/gdbstub_common.c
index 23ff278a2c..2cf908fea7 100644
--- a/components/esp_gdbstub/esp_common/gdbstub_common.c
+++ b/components/esp_gdbstub/esp_common/gdbstub_common.c
@@ -29,12 +29,16 @@ void esp_gdbstub_target_init(void)
     case 0:
         gdb_uart = &UART0;
         break;
+#if SOC_UART_NUM > 1
     case 1:
         gdb_uart = &UART1;
         break;
+#endif
+#if SOC_UART_NUM > 2
     case 2:
         gdb_uart = &UART2;
         break;
+#endif
     default:
         gdb_uart = &UART0;
         break;
@@ -126,4 +130,4 @@ int esp_gdbstub_writemem(unsigned int addr, unsigned char data)
     asm volatile("ISYNC\nISYNC\n");
 
     return 0;
-}
\ No newline at end of file
+}
diff --git a/components/esp_gdbstub/riscv/gdbstub_riscv.c b/components/esp_gdbstub/riscv/gdbstub_riscv.c
index 7cded48a34..ad99f5c64f 100644
--- a/components/esp_gdbstub/riscv/gdbstub_riscv.c
+++ b/components/esp_gdbstub/riscv/gdbstub_riscv.c
@@ -58,3 +58,8 @@ int esp_gdbstub_get_signal(const esp_gdbstub_frame_t *frame)
 {
       return 5; // SIGTRAP, see IDF-2490
 }
+
+void _xt_gdbstub_int(void * frame)
+{
+
+}
diff --git a/components/esp_gdbstub/src/gdbstub.c b/components/esp_gdbstub/src/gdbstub.c
index 993d5e9e6b..1361a64e73 100644
--- a/components/esp_gdbstub/src/gdbstub.c
+++ b/components/esp_gdbstub/src/gdbstub.c
@@ -24,7 +24,6 @@
 #include "hal/wdt_hal.h"
 #include "freertos/FreeRTOS.h"
 #include "freertos/task.h"
-//#include "esp_task_wdt.h"
 
 
 #ifdef CONFIG_ESP_GDBSTUB_SUPPORT_TASKS
@@ -43,11 +42,11 @@ static esp_gdbstub_scratch_t s_scratch;
 static esp_gdbstub_gdb_regfile_t *gdb_local_regfile = &s_scratch.regfile;
 
 /**
- * @breef panic handler
+ * @brief panic handler
 */
 void esp_gdbstub_panic_handler(void *in_frame)
 {
-    esp_gdbstub_frame_t* frame = (esp_gdbstub_frame_t*)in_frame;
+    esp_gdbstub_frame_t *frame = (esp_gdbstub_frame_t *)in_frame;
 #ifndef CONFIG_ESP_GDBSTUB_SUPPORT_TASKS
     esp_gdbstub_frame_to_regfile(frame, &s_scratch.regfile);
 #else
@@ -186,7 +185,7 @@ static inline void enable_all_wdts(void)
  * @param curr_regs - actual registers frame
  *
 */
-void gdbstub_handle_uart_int(XtExcFrame *regs_frame)
+void gdbstub_handle_uart_int(esp_gdbstub_frame_t *regs_frame)
 {
     // Disable all enabled WDT on enter
     disable_all_wdts();
@@ -234,7 +233,7 @@ intr_handle_t intr_handle_;
 extern void _xt_gdbstub_int(void * );
 
 #ifdef CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME
-/** @breef Init gdbstub
+/** @brief Init gdbstub
  * Init uart interrupt for gdbstub
  * */
 void esp_gdbstub_init(void)
@@ -395,18 +394,6 @@ static bool get_task_handle(size_t index, TaskHandle_t *handle)
     return true;
 }
 
-static eTaskState get_task_state(size_t index)
-{
-    return eSuspended;
-//    return s_scratch.tasks[index].eCurrentState;
-}
-
-static int get_task_cpu_id(size_t index)
-{
-    return 0;
-    // return s_scratch.tasks[index].xCoreID;
-}
-
 /** Get the index of the task running on the current CPU, and save the result */
 static void find_paniced_task_index(void)
 {
@@ -531,29 +518,8 @@ static void handle_qThreadExtraInfo_command(const unsigned char *cmd, int len)
     esp_gdbstub_send_str_as_hex((const char *)pcTaskGetTaskName(handle));
     esp_gdbstub_send_hex(' ', 8);
 
-    eTaskState state = get_task_state(task_index);
-    switch (state) {
-    case eRunning:
-        esp_gdbstub_send_str_as_hex("State: Running ");
-        esp_gdbstub_send_str_as_hex("@CPU");
-        esp_gdbstub_send_hex(get_task_cpu_id(task_index) + '0', 8);
-        break;
-    case eReady:
-        esp_gdbstub_send_str_as_hex("State: Ready");
-        break;
-    case eBlocked:
-        esp_gdbstub_send_str_as_hex("State: Blocked");
-        break;
-    case eSuspended:
-        esp_gdbstub_send_str_as_hex("State: Suspended");
-        break;
-    case eDeleted:
-        esp_gdbstub_send_str_as_hex("State: Deleted");
-        break;
-    default:
-        esp_gdbstub_send_str_as_hex("State: Invalid");
-        break;
-    }
+    // Current version report only Suspended state
+    esp_gdbstub_send_str_as_hex("State: Suspended");
 
     esp_gdbstub_send_end();
 }
@@ -605,4 +571,3 @@ static int handle_task_commands(unsigned char *cmd, int len)
 }
 
 #endif // CONFIG_ESP_GDBSTUB_SUPPORT_TASKS
-
diff --git a/components/esp_gdbstub/xtensa/esp_gdbstub_arch.h b/components/esp_gdbstub/xtensa/esp_gdbstub_arch.h
index 4730e0a124..18b119cb3f 100644
--- a/components/esp_gdbstub/xtensa/esp_gdbstub_arch.h
+++ b/components/esp_gdbstub/xtensa/esp_gdbstub_arch.h
@@ -15,6 +15,7 @@
 #pragma once
 #include <stdint.h>
 #include "freertos/xtensa_context.h"
+#include "gdbstub_target_config.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/components/esp_gdbstub/xtensa/gdbstub-entry.S b/components/esp_gdbstub/xtensa/gdbstub-entry.S
index 780eed9967..c73e419897 100644
--- a/components/esp_gdbstub/xtensa/gdbstub-entry.S
+++ b/components/esp_gdbstub/xtensa/gdbstub-entry.S
@@ -41,4 +41,3 @@ _xt_gdbstub_int:
     mov     a6,sp
     call0   gdbstub_handle_uart_int
     ret
-
diff --git a/components/esp_system/panic.c b/components/esp_system/panic.c
index 7a55653a38..58629dd5ca 100644
--- a/components/esp_system/panic.c
+++ b/components/esp_system/panic.c
@@ -30,6 +30,7 @@
 
 #include "esp_private/panic_internal.h"
 #include "port/panic_funcs.h"
+#include "esp_rom_sys.h"
 
 #include "sdkconfig.h"
 
@@ -58,6 +59,10 @@
 #include "esp_gdbstub.h"
 #endif
 
+#if CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG
+#include "hal/usb_serial_jtag_ll.h"
+#endif
+
 bool g_panic_abort = false;
 static char *s_panic_abort_details = NULL;
 
@@ -68,13 +73,13 @@ static wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1
 #if !CONFIG_ESP_SYSTEM_PANIC_SILENT_REBOOT
 
 #if CONFIG_ESP_CONSOLE_UART
-static uart_hal_context_t s_panic_uart = { .dev = CONFIG_ESP_CONSOLE_UART_NUM == 0 ? &UART0 : &UART1 };
+static uart_hal_context_t s_panic_uart = { .dev = CONFIG_ESP_CONSOLE_UART_NUM == 0 ? &UART0 :&UART1 };
 
 void panic_print_char(const char c)
 {
     uint32_t sz = 0;
-    while(!uart_hal_get_txfifo_len(&s_panic_uart));
-    uart_hal_write_txfifo(&s_panic_uart, (uint8_t*) &c, 1, &sz);
+    while (!uart_hal_get_txfifo_len(&s_panic_uart));
+    uart_hal_write_txfifo(&s_panic_uart, (uint8_t *) &c, 1, &sz);
 }
 #endif // CONFIG_ESP_CONSOLE_UART
 
@@ -87,6 +92,27 @@ void panic_print_char(const char c)
 }
 #endif // CONFIG_ESP_CONSOLE_USB_CDC
 
+#if CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG
+//Timeout; if there's no host listening, the txfifo won't ever
+//be writable after the first packet.
+
+#define USBSERIAL_TIMEOUT_MAX_US 50000
+static int s_usbserial_timeout = 0;
+
+void panic_print_char(const char c)
+{
+    while (!usb_serial_jtag_ll_txfifo_writable() && s_usbserial_timeout < (USBSERIAL_TIMEOUT_MAX_US / 100)) {
+        esp_rom_delay_us(100);
+        s_usbserial_timeout++;
+    }
+    if (usb_serial_jtag_ll_txfifo_writable()) {
+        usb_serial_jtag_ll_write_txfifo((const uint8_t *)&c, 1);
+        s_usbserial_timeout = 0;
+    }
+}
+#endif //CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG
+
+
 #if CONFIG_ESP_CONSOLE_NONE
 void panic_print_char(const char c)
 {
@@ -96,7 +122,7 @@ void panic_print_char(const char c)
 
 void panic_print_str(const char *str)
 {
-    for(int i = 0; str[i] != 0; i++) {
+    for (int i = 0; str[i] != 0; i++) {
         panic_print_char(str[i]);
     }
 }
@@ -145,7 +171,7 @@ static void reconfigure_all_wdts(void)
     //Reconfigure TWDT (Timer Group 0)
     wdt_hal_init(&wdt0_context, WDT_MWDT0, MWDT0_TICK_PRESCALER, false); //Prescaler: wdt counts in ticks of TG0_WDT_TICK_US
     wdt_hal_write_protect_disable(&wdt0_context);
-    wdt_hal_config_stage(&wdt0_context, 0, 1000*1000/MWDT0_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM);   //1 second before reset
+    wdt_hal_config_stage(&wdt0_context, 0, 1000 * 1000 / MWDT0_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM); //1 second before reset
     wdt_hal_enable(&wdt0_context);
     wdt_hal_write_protect_enable(&wdt0_context);
 
@@ -190,29 +216,29 @@ void esp_panic_handler(panic_info_t *info)
         info->exception = PANIC_EXCEPTION_ABORT;
     }
 
-   /*
-     * For any supported chip, the panic handler prints the contents of panic_info_t in the following format:
-     *
-     *
-     * Guru Meditation Error: Core <core> (<exception>). <description>
-     * <details>
-     *
-     * <state>
-     *
-     * <elf_info>
-     *
-     *
-     * ----------------------------------------------------------------------------------------
-     * core - core where exception was triggered
-     * exception - what kind of exception occured
-     * description - a short description regarding the exception that occured
-     * details - more details about the exception
-     * state - processor state like register contents, and backtrace
-     * elf_info - details about the image currently running
-     *
-     * NULL fields in panic_info_t are not printed.
-     *
-     * */
+    /*
+      * For any supported chip, the panic handler prints the contents of panic_info_t in the following format:
+      *
+      *
+      * Guru Meditation Error: Core <core> (<exception>). <description>
+      * <details>
+      *
+      * <state>
+      *
+      * <elf_info>
+      *
+      *
+      * ----------------------------------------------------------------------------------------
+      * core - core where exception was triggered
+      * exception - what kind of exception occured
+      * description - a short description regarding the exception that occured
+      * details - more details about the exception
+      * state - processor state like register contents, and backtrace
+      * elf_info - details about the image currently running
+      *
+      * NULL fields in panic_info_t are not printed.
+      *
+      * */
     if (info->reason) {
         panic_print_str("Guru Meditation Error: Core ");
         panic_print_dec(info->core);
@@ -296,7 +322,7 @@ void esp_panic_handler(panic_info_t *info)
     wdt_hal_disable(&rtc_wdt_ctx);
     wdt_hal_write_protect_enable(&rtc_wdt_ctx);
     panic_print_str("Entering gdb stub now.\r\n");
-    esp_gdbstub_panic_handler(info->frame);
+    esp_gdbstub_panic_handler((void *)info->frame);
 #else
 #if CONFIG_ESP_COREDUMP_ENABLE
     static bool s_dumping_core;
@@ -321,8 +347,7 @@ void esp_panic_handler(panic_info_t *info)
 #if CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT || CONFIG_ESP_SYSTEM_PANIC_SILENT_REBOOT
 
     if (esp_reset_reason_get_hint() == ESP_RST_UNKNOWN) {
-        switch (info->exception)
-        {
+        switch (info->exception) {
         case PANIC_EXCEPTION_IWDT:
             esp_reset_reason_set_hint(ESP_RST_INT_WDT);
             break;
@@ -348,10 +373,10 @@ void esp_panic_handler(panic_info_t *info)
 }
 
 
-void __attribute__((noreturn)) panic_abort(const char *details)
+void __attribute__((noreturn, no_sanitize_undefined)) panic_abort(const char *details)
 {
     g_panic_abort = true;
-    s_panic_abort_details = (char*) details;
+    s_panic_abort_details = (char *) details;
 
 #if CONFIG_APPTRACE_ENABLE
 #if CONFIG_SYSVIEW_ENABLE
@@ -363,7 +388,7 @@ void __attribute__((noreturn)) panic_abort(const char *details)
 #endif
 
     *((int *) 0) = 0; // NOLINT(clang-analyzer-core.NullDereference) should be an invalid operation on targets
-    while(1);
+    while (1);
 }
 
 /* Weak versions of reset reason hint functions.
diff --git a/components/freertos/port/port_common.c b/components/freertos/port/port_common.c
index 8a7984ea29..b6eb0bd00e 100644
--- a/components/freertos/port/port_common.c
+++ b/components/freertos/port/port_common.c
@@ -61,6 +61,10 @@ volatile unsigned port_xSchedulerRunning[portNUM_PROCESSORS] = {0};
 
 static void main_task(void* args);
 
+#ifdef CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME
+void esp_gdbstub_init(void);
+#endif // CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME
+
 extern void app_main(void);
 
 void esp_startup_start_app_common(void)
@@ -79,6 +83,10 @@ void esp_startup_start_app_common(void)
 #endif
 #endif
 
+#ifdef CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME
+    esp_gdbstub_init();
+#endif // CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME
+
 	portBASE_TYPE res = xTaskCreatePinnedToCore(&main_task, "main",
 												ESP_TASK_MAIN_STACK, NULL,
 												ESP_TASK_MAIN_PRIO, NULL, ESP_TASK_MAIN_CORE);
diff --git a/docs/en/api-guides/tools/idf-monitor.rst b/docs/en/api-guides/tools/idf-monitor.rst
index cec09371ad..a580095a12 100644
--- a/docs/en/api-guides/tools/idf-monitor.rst
+++ b/docs/en/api-guides/tools/idf-monitor.rst
@@ -10,7 +10,6 @@ This tool can be launched from an IDF project by running ``idf.py monitor``.
 
 For the legacy GNU Make system, run ``make monitor``.
 
-
 Keyboard Shortcuts
 ==================
 
@@ -59,9 +58,9 @@ For easy interaction with IDF Monitor, use the keyboard shortcuts given in the t
    * - * Ctrl+X (or X)
      - Exit the program
      -                
-   * - Ctrl+]
+   * - Ctrl+C
      - Interrupt running application
-     - Pauses IDF monitor and run GDB_ project debugger to debug the application at runtime.     
+     - Pauses IDF monitor and run GDB_ project debugger to debug the application at runtime. This requires :ref:CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME option to be enabled.     
 
 Any keys pressed, other than ``Ctrl-]`` and ``Ctrl-T``, will be sent through the serial port.
 
@@ -187,6 +186,7 @@ To decode each address, IDF Monitor runs the following command in the background
 Launching GDB with GDBStub
 ~~~~~~~~~~~~~~~~~~~~~~~~~~
 
+
 By default, if esp-idf crashes, the panic handler prints relevant registers and the stack dump (similar to the ones above) over the serial port. Then it resets the board.
 
 Furthermore, the application can be configured to run GDBStub in the background and handle the Ctrl+C event from the monitor.
diff --git a/examples/get-started/hello_world/main/CMakeLists.txt b/examples/get-started/hello_world/main/CMakeLists.txt
index c299e03782..07686dc8e1 100644
--- a/examples/get-started/hello_world/main/CMakeLists.txt
+++ b/examples/get-started/hello_world/main/CMakeLists.txt
@@ -1,2 +1,2 @@
 idf_component_register(SRCS "hello_world_main.c"
-                    INCLUDE_DIRS "")
\ No newline at end of file
+                    INCLUDE_DIRS "")
diff --git a/examples/system/gdbstub/CMakeLists.txt b/examples/system/gdbstub/CMakeLists.txt
index 06e470af47..9392d46b7b 100644
--- a/examples/system/gdbstub/CMakeLists.txt
+++ b/examples/system/gdbstub/CMakeLists.txt
@@ -3,4 +3,4 @@
 cmake_minimum_required(VERSION 3.5)
 
 include($ENV{IDF_PATH}/tools/cmake/project.cmake)
-project(gdbstub)
\ No newline at end of file
+project(gdbstub)
diff --git a/examples/system/gdbstub/Makefile b/examples/system/gdbstub/Makefile
index a71a8bab1d..6615607b98 100644
--- a/examples/system/gdbstub/Makefile
+++ b/examples/system/gdbstub/Makefile
@@ -6,4 +6,3 @@
 PROJECT_NAME := gdbstub
 
 include $(IDF_PATH)/make/project.mk
-
diff --git a/examples/system/gdbstub/main/CMakeLists.txt b/examples/system/gdbstub/main/CMakeLists.txt
index 7e624c9c17..b834e836a4 100644
--- a/examples/system/gdbstub/main/CMakeLists.txt
+++ b/examples/system/gdbstub/main/CMakeLists.txt
@@ -1,2 +1,2 @@
 idf_component_register(SRCS "gdbstub_main.c"
-                    INCLUDE_DIRS "")
\ No newline at end of file
+                    INCLUDE_DIRS "")
diff --git a/examples/system/gdbstub/main/component.mk b/examples/system/gdbstub/main/component.mk
index 0b9d7585e7..a98f634eae 100644
--- a/examples/system/gdbstub/main/component.mk
+++ b/examples/system/gdbstub/main/component.mk
@@ -2,4 +2,3 @@
 # "main" pseudo-component makefile.
 #
 # (Uses default behaviour of compiling all source files in directory, adding 'include' to include path.)
-
diff --git a/examples/system/gdbstub/sdkconfig.defaults b/examples/system/gdbstub/sdkconfig.defaults
index e679222122..7a32ecd7f2 100644
--- a/examples/system/gdbstub/sdkconfig.defaults
+++ b/examples/system/gdbstub/sdkconfig.defaults
@@ -19,4 +19,4 @@ CONFIG_FREERTOS_UNICORE=y
 # CONFIG_ESP_SYSTEM_PANIC_SILENT_REBOOT is not set
 CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME=y
 CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE=y
-# end of ESP System Settings
\ No newline at end of file
+# end of ESP System Settings
diff --git a/tools/idf.py b/tools/idf.py
index 273eb24766..b1323145fe 100755
--- a/tools/idf.py
+++ b/tools/idf.py
@@ -33,15 +33,13 @@ import json
 import locale
 import os
 import os.path
+import signal
 import subprocess
 import sys
 from collections import Counter, OrderedDict
 from importlib import import_module
 from pkgutil import iter_modules
 
-import signal
-
-
 # pyc files remain in the filesystem when switching between branches which might raise errors for incompatible
 # idf.py extensions. Therefore, pyc file generation is turned off:
 sys.dont_write_bytecode = True
@@ -726,7 +724,7 @@ def init_cli(verbose_output=None):
     return CLI(help=cli_help, verbose_output=verbose_output, all_actions=all_actions)
 
 
-def signal_handler(signal, frame):
+def signal_handler(_signal, _frame):
     # The Ctrl+C processed by other threads inside
     pass
 
diff --git a/tools/idf_monitor.py b/tools/idf_monitor.py
index 465db7ad32..10a9778a08 100755
--- a/tools/idf_monitor.py
+++ b/tools/idf_monitor.py
@@ -202,10 +202,10 @@ class Monitor(object):
                     elif event_tag == TAG_SERIAL_FLUSH:
                         self.handle_serial_input(data, finalize_line=True)
                     else:
-                        raise RuntimeError("Bad event data %r" % ((event_tag,data),))
+                        raise RuntimeError('Bad event data %r' % ((event_tag,data),))
                 except KeyboardInterrupt:
                     try:
-                        yellow_print("To exit from IDF monitor please use \"Ctrl+]\"")
+                        yellow_print('To exit from IDF monitor please use \"Ctrl+]\"')
                         self.serial.write(codecs.encode('\x03'))
                     except serial.SerialException:
                         pass  # this shouldn't happen, but sometimes port has closed in serial thread
@@ -232,9 +232,9 @@ class Monitor(object):
         # Remove "+" after Continue command
         if self.start_cmd_sent is True:
             self.start_cmd_sent = False
-            pos = data.find(b"+")
+            pos = data.find(b'+')
             if pos != -1:
-                data = data[1:]
+                data = data[(pos + 1):]
 
         sp = data.split(b'\n')
         if self._last_line_part != b'':
@@ -520,21 +520,20 @@ class Monitor(object):
                        self.elf_file]
 
                 # Here we handling GDB as a process
-                if True:
-                    # Open GDB process
+                # Open GDB process
+                try:
+                    process = subprocess.Popen(cmd, cwd='.')
+                except KeyboardInterrupt:
+                    pass
+
+                # We ignore Ctrl+C interrupt form external process abd wait responce util GDB will be finished.
+                while True:
                     try:
-                        process = subprocess.Popen(cmd, cwd=".")
+                        process.wait()
+                        break
                     except KeyboardInterrupt:
-                        pass
-
-                    # We ignore Ctrl+C interrupt form external process abd wait responce util GDB will be finished.
-                    while True:
-                        try:
-                            process.wait()
-                            break
-                        except KeyboardInterrupt:
-                            pass    # We ignore the Ctrl+C
-                    self.gdb_exit = True
+                        pass    # We ignore the Ctrl+C
+                self.gdb_exit = True
 
             except OSError as e:
                 red_print('%s: %s' % (' '.join(cmd), e))
diff --git a/tools/idf_monitor_base/serial_reader.py b/tools/idf_monitor_base/serial_reader.py
index c3b7a60bf0..f6779e23a9 100644
--- a/tools/idf_monitor_base/serial_reader.py
+++ b/tools/idf_monitor_base/serial_reader.py
@@ -50,18 +50,16 @@ class SerialReader(StoppableThread):
             self.serial.baudrate = self.baud
             # We can come to this thread at startup or from external application line GDB.
             # If we come from GDB we would like to continue to run without reset.
-            if self.gdb_exit is False:
+            if self.gdb_exit:
+                self.serial.rts = False
+                self.serial.dtr = True
+            else:                           # if we exit from GDB, we don't need to reset the target
                 # This sequence of DTR/RTS and open/close set the serial port to
                 # condition when GDB not make reset of the target by switching DTR/RTS.
                 self.serial.rts = True  # IO0=LOW
                 self.serial.dtr = self.serial.dtr   # usbser.sys workaround
-                self.serial.open()
-                self.serial.close()
                 self.serial.rts = False     # IO0=HIGH
                 self.serial.dtr = False
-            else:                           # if we exit from GDB, we don't need to reset the target
-                self.serial.rts = False
-                self.serial.dtr = True
 
             # Current state not reset the target!
             self.gdb_exit = False
diff --git a/tools/windows/idf_exe/idf_main.c b/tools/windows/idf_exe/idf_main.c
index dbbe267305..cbfcf7990f 100644
--- a/tools/windows/idf_exe/idf_main.c
+++ b/tools/windows/idf_exe/idf_main.c
@@ -16,9 +16,6 @@
 #include <shlwapi.h>
 #include <strsafe.h>
 #include <stdarg.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <unistd.h>
 
 #define LINESIZE 1024
 
@@ -46,17 +43,6 @@ BOOL WINAPI CtrlHandler(DWORD fdwCtrlType)
     }
 }
 
-BOOL WINAPI CtrlHandler(DWORD fdwCtrlType)
-{
-    switch (fdwCtrlType) {
-    // Handle the CTRL-C signal.
-    case CTRL_C_EVENT:
-        return TRUE;
-    default:
-        return FALSE;
-    }
-}
-
 int main(int argc, LPTSTR argv[])
 {
     /* Print the version of this wrapper tool, but only if invoked as "idf.exe".
-- 
2.25.1


From 2d0895e9a98bc7846d0ac7321f2b86b47346bf21 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jan=20Brudn=C3=BD?= <jan.brudny@espressif.com>
Date: Mon, 17 May 2021 02:56:33 +0200
Subject: [PATCH 12/43] asio: update copyright notice

---
 components/asio/port/include/esp_asio_config.h | 18 +++++-------------
 components/asio/port/include/esp_exception.h   | 18 +++++-------------
 components/asio/port/include/openssl/conf.h    | 18 +++++-------------
 components/asio/port/include/openssl/dh.h      | 18 +++++-------------
 .../include/openssl/esp_asio_openssl_stubs.h   | 18 +++++-------------
 components/asio/port/include/openssl/rsa.h     | 18 +++++-------------
 components/asio/port/include/openssl/x509v3.h  | 18 +++++-------------
 .../asio/port/src/esp_asio_openssl_stubs.c     | 18 +++++-------------
 8 files changed, 40 insertions(+), 104 deletions(-)

diff --git a/components/asio/port/include/esp_asio_config.h b/components/asio/port/include/esp_asio_config.h
index bcf8c38d40..cba316527e 100644
--- a/components/asio/port/include/esp_asio_config.h
+++ b/components/asio/port/include/esp_asio_config.h
@@ -1,16 +1,8 @@
-// Copyright 2018 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2018-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #ifndef _ESP_ASIO_CONFIG_H_
 #define _ESP_ASIO_CONFIG_H_
 
diff --git a/components/asio/port/include/esp_exception.h b/components/asio/port/include/esp_exception.h
index cbf20d7a63..6f88866a4e 100644
--- a/components/asio/port/include/esp_exception.h
+++ b/components/asio/port/include/esp_exception.h
@@ -1,17 +1,9 @@
 
-// Copyright 2018 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2018-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #ifndef _ESP_EXCEPTION_H_
 #define _ESP_EXCEPTION_H_
 
diff --git a/components/asio/port/include/openssl/conf.h b/components/asio/port/include/openssl/conf.h
index f125c3e6cf..1ed025d93c 100644
--- a/components/asio/port/include/openssl/conf.h
+++ b/components/asio/port/include/openssl/conf.h
@@ -1,16 +1,8 @@
-// Copyright 2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2020-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #ifndef _ESP_ASIO_OPENSSL_CONF_H
 #define _ESP_ASIO_OPENSSL_CONF_H
diff --git a/components/asio/port/include/openssl/dh.h b/components/asio/port/include/openssl/dh.h
index def713cfd3..af72e083aa 100644
--- a/components/asio/port/include/openssl/dh.h
+++ b/components/asio/port/include/openssl/dh.h
@@ -1,16 +1,8 @@
-// Copyright 2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2020-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #ifndef _ESP_ASIO_OPENSSL_DH_STUB_H
 #define _ESP_ASIO_OPENSSL_DH_STUB_H
diff --git a/components/asio/port/include/openssl/esp_asio_openssl_stubs.h b/components/asio/port/include/openssl/esp_asio_openssl_stubs.h
index fde5231722..5062774107 100644
--- a/components/asio/port/include/openssl/esp_asio_openssl_stubs.h
+++ b/components/asio/port/include/openssl/esp_asio_openssl_stubs.h
@@ -1,16 +1,8 @@
-// Copyright 2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2020-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #ifndef _ESP_ASIO_OPENSSL_STUBS_H
 #define _ESP_ASIO_OPENSSL_STUBS_H
diff --git a/components/asio/port/include/openssl/rsa.h b/components/asio/port/include/openssl/rsa.h
index 5d9d10e82b..53018a33a8 100644
--- a/components/asio/port/include/openssl/rsa.h
+++ b/components/asio/port/include/openssl/rsa.h
@@ -1,16 +1,8 @@
-// Copyright 2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2020-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #ifndef _ESP_ASIO_OPENSSL_RSA_STUB_H
 #define _ESP_ASIO_OPENSSL_RSA_STUB_H
diff --git a/components/asio/port/include/openssl/x509v3.h b/components/asio/port/include/openssl/x509v3.h
index 5ae8e78435..dad7475424 100644
--- a/components/asio/port/include/openssl/x509v3.h
+++ b/components/asio/port/include/openssl/x509v3.h
@@ -1,16 +1,8 @@
-// Copyright 2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2020-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #ifndef _ESP_ASIO_OPENSSL_X509V3_STUB_H
 #define _ESP_ASIO_OPENSSL_X509V3_STUB_H
diff --git a/components/asio/port/src/esp_asio_openssl_stubs.c b/components/asio/port/src/esp_asio_openssl_stubs.c
index 6deb099caa..c766fb0d72 100644
--- a/components/asio/port/src/esp_asio_openssl_stubs.c
+++ b/components/asio/port/src/esp_asio_openssl_stubs.c
@@ -1,16 +1,8 @@
-// Copyright 2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2020-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 //
 
 #include "esp_asio_config.h"
-- 
2.25.1


From e20826cc7fc81214280c4fc92e17445897bc276b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jan=20Brudn=C3=BD?= <jan.brudny@espressif.com>
Date: Mon, 17 May 2021 02:58:32 +0200
Subject: [PATCH 13/43] libsodium: update copyright notice

---
 .../crypto_hash_sha256_mbedtls.c               | 18 +++++-------------
 .../crypto_hash_sha512_mbedtls.c               | 18 +++++-------------
 components/libsodium/port/randombytes_esp32.c  | 18 +++++-------------
 .../libsodium/port/randombytes_internal.h      | 18 +++++-------------
 .../libsodium/port_include/sodium/version.h    |  5 +++++
 components/libsodium/test/test_sodium.c        |  5 +++++
 6 files changed, 30 insertions(+), 52 deletions(-)

diff --git a/components/libsodium/port/crypto_hash_mbedtls/crypto_hash_sha256_mbedtls.c b/components/libsodium/port/crypto_hash_mbedtls/crypto_hash_sha256_mbedtls.c
index 39c36c70a0..13b6a3989a 100644
--- a/components/libsodium/port/crypto_hash_mbedtls/crypto_hash_sha256_mbedtls.c
+++ b/components/libsodium/port/crypto_hash_mbedtls/crypto_hash_sha256_mbedtls.c
@@ -1,16 +1,8 @@
-// Copyright 2017 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2017-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #include "crypto_hash_sha256.h"
 #include "mbedtls/sha256.h"
diff --git a/components/libsodium/port/crypto_hash_mbedtls/crypto_hash_sha512_mbedtls.c b/components/libsodium/port/crypto_hash_mbedtls/crypto_hash_sha512_mbedtls.c
index 48d31a61e4..d0d7a663da 100644
--- a/components/libsodium/port/crypto_hash_mbedtls/crypto_hash_sha512_mbedtls.c
+++ b/components/libsodium/port/crypto_hash_mbedtls/crypto_hash_sha512_mbedtls.c
@@ -1,16 +1,8 @@
-// Copyright 2017 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2017-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #include "crypto_hash_sha512.h"
 #include "mbedtls/sha512.h"
diff --git a/components/libsodium/port/randombytes_esp32.c b/components/libsodium/port/randombytes_esp32.c
index fc0617155a..4d98538a47 100644
--- a/components/libsodium/port/randombytes_esp32.c
+++ b/components/libsodium/port/randombytes_esp32.c
@@ -1,16 +1,8 @@
-// Copyright 2017 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2017-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include "randombytes_internal.h"
 #include "esp_system.h"
 
diff --git a/components/libsodium/port/randombytes_internal.h b/components/libsodium/port/randombytes_internal.h
index b0b96897e5..35da42d7b3 100644
--- a/components/libsodium/port/randombytes_internal.h
+++ b/components/libsodium/port/randombytes_internal.h
@@ -1,16 +1,8 @@
-// Copyright 2017 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2017-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #pragma once
 
 # include "export.h"
diff --git a/components/libsodium/port_include/sodium/version.h b/components/libsodium/port_include/sodium/version.h
index c0bf5869de..820996409e 100644
--- a/components/libsodium/port_include/sodium/version.h
+++ b/components/libsodium/port_include/sodium/version.h
@@ -1,3 +1,8 @@
+/*
+ * SPDX-FileCopyrightText: 2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #ifndef sodium_version_H
 #define sodium_version_H
diff --git a/components/libsodium/test/test_sodium.c b/components/libsodium/test/test_sodium.c
index f7f37d509f..22455dcb5f 100644
--- a/components/libsodium/test/test_sodium.c
+++ b/components/libsodium/test/test_sodium.c
@@ -1,3 +1,8 @@
+/*
+ * SPDX-FileCopyrightText: 2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include "unity.h"
 #include "sodium/crypto_hash_sha256.h"
 #include "sodium/crypto_hash_sha512.h"
-- 
2.25.1


From 28a94328d4f03a057411d69bcae82572385b8dd2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jan=20Brudn=C3=BD?= <jan.brudny@espressif.com>
Date: Mon, 17 May 2021 03:41:32 +0200
Subject: [PATCH 14/43] console: update copyright notice

---
 components/console/commands.c          | 18 +++++-------------
 components/console/esp_console.h       | 18 +++++-------------
 components/console/esp_console_repl.c  | 18 +++++-------------
 components/console/split_argv.c        | 18 +++++-------------
 components/console/test/test_console.c |  5 +++++
 5 files changed, 25 insertions(+), 52 deletions(-)

diff --git a/components/console/commands.c b/components/console/commands.c
index 251fa92343..77654a30c2 100644
--- a/components/console/commands.c
+++ b/components/console/commands.c
@@ -1,16 +1,8 @@
-// Copyright 2016-2019 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2016-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #include <stdio.h>
 #include <string.h>
diff --git a/components/console/esp_console.h b/components/console/esp_console.h
index 29aab8b4fb..a0b7cbf178 100644
--- a/components/console/esp_console.h
+++ b/components/console/esp_console.h
@@ -1,16 +1,8 @@
-// Copyright 2016-2019 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2016-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #pragma once
 
 #ifdef __cplusplus
diff --git a/components/console/esp_console_repl.c b/components/console/esp_console_repl.c
index 19dd9d85ab..66963bde13 100644
--- a/components/console/esp_console_repl.c
+++ b/components/console/esp_console_repl.c
@@ -1,16 +1,8 @@
-// Copyright 2016-2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2016-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #include <stdint.h>
 #include <stdio.h>
diff --git a/components/console/split_argv.c b/components/console/split_argv.c
index e762b0abae..d2e3bd0846 100644
--- a/components/console/split_argv.c
+++ b/components/console/split_argv.c
@@ -1,16 +1,8 @@
-// Copyright 2016-2017 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2016-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #include <stdio.h>
 #include <ctype.h>
diff --git a/components/console/test/test_console.c b/components/console/test/test_console.c
index b634a6c204..eab793dce7 100644
--- a/components/console/test/test_console.c
+++ b/components/console/test/test_console.c
@@ -1,3 +1,8 @@
+/*
+ * SPDX-FileCopyrightText: 2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include <stdio.h>
 #include <string.h>
 #include "sdkconfig.h"
-- 
2.25.1


From 71170dd5bc67bd9eb9414a95103b225c3bdfe0e7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jan=20Brudn=C3=BD?= <jan.brudny@espressif.com>
Date: Mon, 17 May 2021 03:43:02 +0200
Subject: [PATCH 15/43] cxx: update copyright notice

---
 components/cxx/cxx_exception_stubs.cpp       |  5 +++++
 components/cxx/cxx_guards.cpp                | 18 +++++-------------
 components/cxx/test/test_cxx.cpp             |  5 +++++
 components/cxx/test/test_initialization.cpp  |  5 +++++
 components/cxx/test/test_rtti.cpp            |  5 +++++
 components/cxx/test/test_stack_check_cxx.cpp |  5 +++++
 6 files changed, 30 insertions(+), 13 deletions(-)

diff --git a/components/cxx/cxx_exception_stubs.cpp b/components/cxx/cxx_exception_stubs.cpp
index 01b6f5884d..a652ace2e3 100644
--- a/components/cxx/cxx_exception_stubs.cpp
+++ b/components/cxx/cxx_exception_stubs.cpp
@@ -1,3 +1,8 @@
+/*
+ * SPDX-FileCopyrightText: 2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include <cstdlib>
 #include <cstdio>
 #include <exception>
diff --git a/components/cxx/cxx_guards.cpp b/components/cxx/cxx_guards.cpp
index 8580a26cc9..17d53b27ef 100644
--- a/components/cxx/cxx_guards.cpp
+++ b/components/cxx/cxx_guards.cpp
@@ -1,16 +1,8 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
+/*
+ * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 
 #include <stdlib.h>
 #include <assert.h>
diff --git a/components/cxx/test/test_cxx.cpp b/components/cxx/test/test_cxx.cpp
index 03ee89075e..7050538b15 100644
--- a/components/cxx/test/test_cxx.cpp
+++ b/components/cxx/test/test_cxx.cpp
@@ -1,3 +1,8 @@
+/*
+ * SPDX-FileCopyrightText: 2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include <vector>
 #include <numeric>
 #include <stdexcept>
diff --git a/components/cxx/test/test_initialization.cpp b/components/cxx/test/test_initialization.cpp
index 6d5ced3061..3c0a2f5367 100644
--- a/components/cxx/test/test_initialization.cpp
+++ b/components/cxx/test/test_initialization.cpp
@@ -1,3 +1,8 @@
+/*
+ * SPDX-FileCopyrightText: 2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include <vector>
 #include <numeric>
 #include <stdexcept>
diff --git a/components/cxx/test/test_rtti.cpp b/components/cxx/test/test_rtti.cpp
index c3174c9366..252b9ad872 100644
--- a/components/cxx/test/test_rtti.cpp
+++ b/components/cxx/test/test_rtti.cpp
@@ -1,3 +1,8 @@
+/*
+ * SPDX-FileCopyrightText: 2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include <typeinfo>
 #include "unity.h"
 
diff --git a/components/cxx/test/test_stack_check_cxx.cpp b/components/cxx/test/test_stack_check_cxx.cpp
index cb6e5a7701..86f179be28 100644
--- a/components/cxx/test/test_stack_check_cxx.cpp
+++ b/components/cxx/test/test_stack_check_cxx.cpp
@@ -1,3 +1,8 @@
+/*
+ * SPDX-FileCopyrightText: 2021 Espressif Systems (Shanghai) CO LTD
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
 #include "unity.h"
 
 #if CONFIG_COMPILER_STACK_CHECK
-- 
2.25.1


From 721a0c3415c06ee5731759d31ab47dca819c2651 Mon Sep 17 00:00:00 2001
From: baohongde <baohongde@espressif.com>
Date: Wed, 7 Apr 2021 16:46:52 +0800
Subject: [PATCH 16/43] components/bt: Delete BLE ADV priority high

---
 components/bt/controller/esp32/Kconfig.in | 15 ---------------
 components/bt/controller/esp32/bt.c       |  7 -------
 components/bt/controller/lib_esp32        |  2 +-
 3 files changed, 1 insertion(+), 23 deletions(-)

diff --git a/components/bt/controller/esp32/Kconfig.in b/components/bt/controller/esp32/Kconfig.in
index 04ec13d25f..d12712862d 100644
--- a/components/bt/controller/esp32/Kconfig.in
+++ b/components/bt/controller/esp32/Kconfig.in
@@ -415,18 +415,3 @@ config BTDM_BLE_ADV_REPORT_DISCARD_THRSHOLD
         of ADV packets lost in the controller reaches this threshold. It is better to set a larger value.
         If you set `BTDM_BLE_ADV_REPORT_DISCARD_THRSHOLD` to a small value or printf every adv lost event, it
         may cause adv packets lost more.
-
-menuconfig BTDM_COEX_BT_OPTIONS
-    bool "Coexistence Bluetooth Side Options"
-    depends on ESP32_WIFI_SW_COEXIST_ENABLE
-    default n
-    help
-        Options of Bluetooth Side of WiFi and bluetooth coexistence.
-
-config BTDM_COEX_BLE_ADV_HIGH_PRIORITY
-    bool "Improve BLE ADV priority for WiFi & BLE coexistence"
-    depends on BTDM_COEX_BT_OPTIONS
-    default n
-    help
-        Improve BLE ADV coexistence priority to make it better performance.
-        For example, BLE mesh need to enable this option to improve BLE adv performance.
diff --git a/components/bt/controller/esp32/bt.c b/components/bt/controller/esp32/bt.c
index bdc903f78e..b046109d1a 100644
--- a/components/bt/controller/esp32/bt.c
+++ b/components/bt/controller/esp32/bt.c
@@ -240,7 +240,6 @@ extern uint8_t coex_schm_curr_period_get(void);
 extern void * coex_schm_curr_phase_get(void);
 extern int coex_wifi_channel_get(uint8_t *primary, uint8_t *secondary);
 extern int coex_register_wifi_channel_change_callback(void *cb);
-extern void coex_ble_adv_priority_high_set(bool high);
 
 extern char _bss_start_btdm;
 extern char _bss_end_btdm;
@@ -1465,12 +1464,6 @@ esp_err_t esp_bt_controller_init(esp_bt_controller_config_t *cfg)
         goto error;
     }
 
-    #ifdef CONFIG_BTDM_COEX_BLE_ADV_HIGH_PRIORITY
-        coex_ble_adv_priority_high_set(true);
-    #else
-        coex_ble_adv_priority_high_set(false);
-    #endif
-
     btdm_controller_status = ESP_BT_CONTROLLER_STATUS_INITED;
 
     return ESP_OK;
diff --git a/components/bt/controller/lib_esp32 b/components/bt/controller/lib_esp32
index 606e0f422c..1f7e45e2f6 160000
--- a/components/bt/controller/lib_esp32
+++ b/components/bt/controller/lib_esp32
@@ -1 +1 @@
-Subproject commit 606e0f422ce612936b857b1599bff2662544e12b
+Subproject commit 1f7e45e2f645f115fc4ca7fc35ecee2d894ff2ea
-- 
2.25.1


From 01664923f6d7a9f5c686f8eba5070c2ba07e640a Mon Sep 17 00:00:00 2001
From: Marius Vikhammer <marius.vikhammer@espressif.com>
Date: Mon, 17 May 2021 16:52:33 +0800
Subject: [PATCH 17/43] mbedtls: fixed CMake build warning

Building mbedtls with CMake would warn that:

"A private source from a directory other than that of target "mbedcrypto
 has a relative path"

This happened due to some of the CMake variables listing sources could be empty.

Changed to only use target_sources in the code-path where we set the sources,
so we only call target_sources will non-empty variables.

Closes https://github.com/espressif/esp-idf/issues/6767
---
 components/mbedtls/CMakeLists.txt | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/components/mbedtls/CMakeLists.txt b/components/mbedtls/CMakeLists.txt
index c97f337523..e7a26f0ff3 100644
--- a/components/mbedtls/CMakeLists.txt
+++ b/components/mbedtls/CMakeLists.txt
@@ -99,16 +99,19 @@ if(SHA_PERIPHERAL_TYPE STREQUAL "dma")
         set(SHA_DMA_SRCS "${COMPONENT_DIR}/port/sha/dma/esp_sha_gdma_impl.c"
                          "${COMPONENT_DIR}/port/crypto_shared_gdma/esp_crypto_shared_gdma.c")
     endif()
+    target_sources(mbedcrypto PRIVATE  "${SHA_DMA_SRCS}")
 endif()
 
 if(AES_PERIPHERAL_TYPE STREQUAL "dma")
-    target_include_directories(mbedcrypto PRIVATE "${COMPONENT_DIR}/port/aes/dma/include")
 
     if(CONFIG_IDF_TARGET_ESP32S2)
         set(AES_DMA_SRCS "${COMPONENT_DIR}/port/aes/dma/esp_aes_crypto_dma_impl.c")
     else()
         set(AES_DMA_SRCS "${COMPONENT_DIR}/port/aes/dma/esp_aes_gdma_impl.c")
     endif()
+
+    target_include_directories(mbedcrypto PRIVATE "${COMPONENT_DIR}/port/aes/dma/include")
+    target_sources(mbedcrypto PRIVATE  "${AES_DMA_SRCS}")
 endif()
 
 target_sources(mbedcrypto PRIVATE "${COMPONENT_DIR}/port/esp_hardware.c"
@@ -119,8 +122,6 @@ target_sources(mbedcrypto PRIVATE "${COMPONENT_DIR}/port/esp_hardware.c"
                                   "${COMPONENT_DIR}/port/aes/esp_aes_common.c"
                                   "${COMPONENT_DIR}/port/aes/${AES_PERIPHERAL_TYPE}/esp_aes.c"
                                   "${COMPONENT_DIR}/port/sha/${SHA_PERIPHERAL_TYPE}/sha.c"
-                                  "${SHA_DMA_SRCS}"
-                                  "${AES_DMA_SRCS}"
 )
 
 # CONFIG_ESP_TLS_USE_DS_PERIPHERAL can be enabled only for the supported targets.
-- 
2.25.1


From 6713291dade585d9951f2e501c41f62055946c2b Mon Sep 17 00:00:00 2001
From: Angus Gratton <angus@espressif.com>
Date: Thu, 13 May 2021 17:06:21 +1000
Subject: [PATCH 18/43] pthread: Fix behaviour when pthread destructor calls
 pthread_getspecific/pthread_setspecific

Update as per specification at https://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_key_create.html

Specifically:

- Before a destructor is called then the value for the corresponding key is
  already set to NULL.

- If a destructor calls pthread_setspecific() to assign a non-NULL value then
  this destructor is called again, after all existing non-NULL values have been
  called.

Adds a test for this relatively complex behaviour.

Closes https://github.com/espressif/esp-idf/issues/6643
---
 components/pthread/pthread_local_storage.c    | 39 +++++++--
 .../pthread/test/test_pthread_local_storage.c | 87 +++++++++++++++++++
 2 files changed, 118 insertions(+), 8 deletions(-)

diff --git a/components/pthread/pthread_local_storage.c b/components/pthread/pthread_local_storage.c
index 5572768470..e784c4cb6b 100644
--- a/components/pthread/pthread_local_storage.c
+++ b/components/pthread/pthread_local_storage.c
@@ -113,12 +113,17 @@ int pthread_key_delete(pthread_key_t key)
    This is called from one of two places:
 
    If the thread was created via pthread_create() then it's called by pthread_task_func() when that thread ends,
-   and the FreeRTOS thread-local-storage is removed before the FreeRTOS task is deleted.
+   or calls pthread_exit(), and the FreeRTOS thread-local-storage is removed before the FreeRTOS task is deleted.
 
    For other tasks, this is called when the FreeRTOS idle task performs its task cleanup after the task is deleted.
 
-   (The reason for calling it early for pthreads is to keep the timing consistent with "normal" pthreads, so after
-   pthread_join() the task's destructors have all been called even if the idle task hasn't run cleanup yet.)
+   There are two reasons for calling it early for pthreads:
+
+   - To keep the timing consistent with "normal" pthreads, so after pthread_join() the task's destructors have all
+     been called even if the idle task hasn't run cleanup yet.
+
+   - The destructor is always called in the context of the thread itself - which is important if the task then calls
+     pthread_getspecific() or pthread_setspecific() to update the state further, as allowed for in the spec.
 */
 static void pthread_local_storage_thread_deleted_callback(int index, void *v_tls)
 {
@@ -126,8 +131,13 @@ static void pthread_local_storage_thread_deleted_callback(int index, void *v_tls
     assert(tls != NULL);
 
     /* Walk the list, freeing all entries and calling destructors if they are registered */
-    value_entry_t *entry = SLIST_FIRST(tls);
-    while(entry != NULL) {
+    while (1) {
+        value_entry_t *entry = SLIST_FIRST(tls);
+        if (entry == NULL) {
+            break;
+        }
+        SLIST_REMOVE_HEAD(tls, next);
+
         // This is a little slow, walking the linked list of keys once per value,
         // but assumes that the thread's value list will have less entries
         // than the keys list
@@ -135,9 +145,7 @@ static void pthread_local_storage_thread_deleted_callback(int index, void *v_tls
         if (key != NULL && key->destructor != NULL) {
             key->destructor(entry->value);
         }
-        value_entry_t *next_entry = SLIST_NEXT(entry, next);
         free(entry);
-        entry = next_entry;
     }
     free(tls);
 }
@@ -250,7 +258,22 @@ int pthread_setspecific(pthread_key_t key, const void *value)
         }
         entry->key = key;
         entry->value = (void *) value; // see note above about cast
-        SLIST_INSERT_HEAD(tls, entry, next);
+
+        // insert the new entry at the end of the list. this is important because
+        // a destructor may call pthread_setspecific() to add a new non-NULL value
+        // to the list, and this should be processed after all other entries.
+        //
+        // See pthread_local_storage_thread_deleted_callback()
+        value_entry_t *last_entry = NULL;
+        value_entry_t *it;
+        SLIST_FOREACH(it, tls, next) {
+            last_entry = it;
+        }
+        if (last_entry == NULL) {
+            SLIST_INSERT_HEAD(tls, entry, next);
+        } else {
+            SLIST_INSERT_AFTER(last_entry, entry, next);
+        }
     }
 
     return 0;
diff --git a/components/pthread/test/test_pthread_local_storage.c b/components/pthread/test/test_pthread_local_storage.c
index ebcaafcbe8..98e6fd7d99 100644
--- a/components/pthread/test/test_pthread_local_storage.c
+++ b/components/pthread/test/test_pthread_local_storage.c
@@ -162,3 +162,90 @@ TEST_CASE("pthread local storage stress test", "[pthread]")
         TEST_ASSERT_EQUAL(0, pthread_join(threads[i], NULL));
     }
 }
+
+
+#define NUM_KEYS 4 // number of keys used in repeat destructor test
+#define NUM_REPEATS 17 // number of times we re-set a key to a non-NULL value to re-trigger destructor
+
+typedef struct {
+    pthread_key_t keys[NUM_KEYS]; // pthread local storage keys used in test
+    unsigned count; // number of times the destructor has been called
+    int last_idx; // index of last key where destructor was called
+} destr_test_state_t;
+
+static void s_test_repeat_destructor(void *vp_state);
+static void *s_test_repeat_destructor_thread(void *vp_state);
+
+// Test the correct behaviour of a pthread destructor function that uses
+// pthread_setspecific() to set another value when it runs, and also
+//
+// As described in https://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_key_create.html
+TEST_CASE("pthread local storage 'repeat' destructor test", "[pthread]")
+{
+    int r;
+    destr_test_state_t state = { .last_idx = -1 };
+    pthread_t thread;
+
+    for (int i = 0; i < NUM_KEYS; i++) {
+        r = pthread_key_create(&state.keys[i], s_test_repeat_destructor);
+        TEST_ASSERT_EQUAL(0, r);
+    }
+
+    r = pthread_create(&thread, NULL, s_test_repeat_destructor_thread, &state);
+    TEST_ASSERT_EQUAL(0, r);
+
+    r = pthread_join(thread, NULL);
+    TEST_ASSERT_EQUAL(0 ,r);
+
+    // Cheating here to make sure compiler reads the value of 'count' from memory not from a register
+    //
+    // We expect the destructor was called NUM_REPEATS times when it repeated, then NUM_KEYS times when it didn't
+    TEST_ASSERT_EQUAL(NUM_REPEATS + NUM_KEYS, ((volatile destr_test_state_t)state).count);
+
+    // cleanup
+    for (int i = 0; i < NUM_KEYS; i++) {
+        r = pthread_key_delete(state.keys[i]);
+        TEST_ASSERT_EQUAL(0, r);
+    }
+}
+
+static void s_test_repeat_destructor(void *vp_state)
+{
+    destr_test_state_t *state = vp_state;
+
+    state->count++;
+    printf("Destructor! Arg %p Count %d\n", state, state->count);
+    if (state->count > NUM_REPEATS) {
+        return; // Stop replacing values after NUM_REPEATS destructors have been called, they will be NULLed out now
+    }
+
+    // Find the key which has a NULL value, this is the key for this destructor. We will set it back to 'state' to repeat later.
+    // At this point only one key should have a NULL value
+    int null_idx = -1;
+    for (int i = 0; i < NUM_KEYS; i++) {
+        if (pthread_getspecific(state->keys[i]) == NULL) {
+            TEST_ASSERT_EQUAL(-1, null_idx); // If more than one key has a NULL value, something has gone wrong
+            null_idx = i;
+            // don't break, verify the other keys have non-NULL values
+        }
+    }
+
+    TEST_ASSERT_NOT_EQUAL(-1, null_idx); // One key should have a NULL value
+
+    // The same key shouldn't be destroyed twice in a row, as new non-NULL values should be destroyed
+    // after existing non-NULL values (to match spec behaviour)
+    TEST_ASSERT_NOT_EQUAL(null_idx, state->last_idx);
+
+    printf("Re-setting index %d\n", null_idx);
+    pthread_setspecific(state->keys[null_idx], state);
+    state->last_idx = null_idx;
+}
+
+static void *s_test_repeat_destructor_thread(void *vp_state)
+{
+    destr_test_state_t *state = vp_state;
+    for (int i = 0; i < NUM_KEYS; i++) {
+        pthread_setspecific(state->keys[i], state);
+    }
+    pthread_exit(NULL);
+}
-- 
2.25.1


From ede477ea652b3b24c9333c909515fe5d29ade257 Mon Sep 17 00:00:00 2001
From: Angus Gratton <angus@espressif.com>
Date: Thu, 4 Feb 2021 11:12:04 +1100
Subject: [PATCH 19/43] paritition_table: Verify the partition table md5sum
 when loading the app

Additionally, always enable the partition MD5 check if flash encryption is on in
Release mode. This ensures the partition table ciphertext has not been modified
(CVE-2021-27926).

The exception is pre-V3.1 ESP-IDF bootloaders and partition tables, which
don't have support for the MD5 entry.
---
 components/bootloader/Kconfig.projbuild       |   2 +
 .../include/esp_flash_partitions.h            |   3 +
 .../bootloader_support/src/flash_partitions.c |   2 +-
 components/esp32/Kconfig                      |  21 +++-
 components/esp_rom/include/esp_rom_md5.h      |   4 +-
 components/partition_table/Kconfig.projbuild  |   1 +
 components/spi_flash/partition.c              | 109 ++++++++++++++----
 docs/en/api-guides/bootloader.rst             |   5 +
 docs/en/api-guides/partition-tables.rst       |   9 +-
 9 files changed, 128 insertions(+), 28 deletions(-)

diff --git a/components/bootloader/Kconfig.projbuild b/components/bootloader/Kconfig.projbuild
index 18a3a7da8f..e801aad3d2 100644
--- a/components/bootloader/Kconfig.projbuild
+++ b/components/bootloader/Kconfig.projbuild
@@ -672,6 +672,8 @@ menu "Security features"
 
         config SECURE_FLASH_ENCRYPTION_MODE_RELEASE
             bool "Release"
+            select PARTITION_TABLE_MD5 if !ESP32_COMPATIBLE_PRE_V3_1_BOOTLOADERS
+
     endchoice
 
     menu "Potentially insecure options"
diff --git a/components/bootloader_support/include/esp_flash_partitions.h b/components/bootloader_support/include/esp_flash_partitions.h
index 1fc9d4f6c1..6c2f5b41ba 100644
--- a/components/bootloader_support/include/esp_flash_partitions.h
+++ b/components/bootloader_support/include/esp_flash_partitions.h
@@ -42,6 +42,9 @@ extern "C" {
 
 #define PART_FLAG_ENCRYPTED (1<<0)
 
+/* The md5sum value is found this many bytes after the ESP_PARTITION_MAGIC_MD5 offset */
+#define ESP_PARTITION_MD5_OFFSET 16
+
 /* Pre-partition table fixed flash offsets */
 #define ESP_BOOTLOADER_DIGEST_OFFSET 0x0
 #define ESP_BOOTLOADER_OFFSET CONFIG_BOOTLOADER_OFFSET_IN_FLASH  /* Offset of bootloader image. Has matching value in bootloader KConfig.projbuild file. */
diff --git a/components/bootloader_support/src/flash_partitions.c b/components/bootloader_support/src/flash_partitions.c
index e4e2ce615c..edd68969da 100644
--- a/components/bootloader_support/src/flash_partitions.c
+++ b/components/bootloader_support/src/flash_partitions.c
@@ -60,7 +60,7 @@ esp_err_t esp_partition_table_verify(const esp_partition_info_t *partition_table
             esp_rom_md5_update(&context, (unsigned char *) partition_table, num_parts * sizeof(esp_partition_info_t));
             esp_rom_md5_final(digest, &context);
 
-            unsigned char *md5sum = ((unsigned char *) part) + 16; // skip the 2B magic number and the 14B fillup bytes
+            unsigned char *md5sum = ((unsigned char *) part) + ESP_PARTITION_MD5_OFFSET;
 
             if (memcmp(md5sum, digest, sizeof(digest)) != 0) {
                 if (log_errors) {
diff --git a/components/esp32/Kconfig b/components/esp32/Kconfig
index 828cd683d8..24e370f959 100644
--- a/components/esp32/Kconfig
+++ b/components/esp32/Kconfig
@@ -653,10 +653,11 @@ menu "ESP32-specific"
             that after enabling this Wi-Fi/Bluetooth will not work.
 
     config ESP32_COMPATIBLE_PRE_V2_1_BOOTLOADERS
-        bool "App compatible with bootloaders before IDF v2.1"
+        bool "App compatible with bootloaders before ESP-IDF v2.1"
+        select ESP32_COMPATIBLE_PRE_V3_1_BOOTLOADERS
         default n
         help
-            Bootloaders before IDF v2.1 did less initialisation of the
+            Bootloaders before ESP-IDF v2.1 did less initialisation of the
             system clock. This setting needs to be enabled to build an app
             which can be booted by these older bootloaders.
 
@@ -668,6 +669,22 @@ menu "ESP32-specific"
 
             Enabling this setting adds approximately 1KB to the app's IRAM usage.
 
+    config ESP32_COMPATIBLE_PRE_V3_1_BOOTLOADERS
+        bool "App compatible with bootloader and partition table before ESP-IDF v3.1"
+        default n
+        help
+            Partition tables before ESP-IDF V3.1 do not contain an MD5 checksum
+            field, and the bootloader before ESP-IDF v3.1 cannot read a partition
+            table that contains an MD5 checksum field.
+
+            Enable this option only if your app needs to boot on a bootloader and/or
+            partition table that was generated from a version *before* ESP-IDF v3.1.
+
+            If this option and Flash Encryption are enabled at the same time, and any
+            data partitions in the partition table are marked Encrypted, then the
+            partition encrypted flag should be manually verified in the app before accessing
+            the partition (see CVE-2021-27926).
+
     config ESP32_APP_INIT_CLK
         bool
         default y if ESP32_COMPATIBLE_PRE_V2_1_BOOTLOADERS
diff --git a/components/esp_rom/include/esp_rom_md5.h b/components/esp_rom/include/esp_rom_md5.h
index 5bb71f3eb9..7adc430bcb 100644
--- a/components/esp_rom/include/esp_rom_md5.h
+++ b/components/esp_rom/include/esp_rom_md5.h
@@ -34,6 +34,8 @@ typedef struct MD5Context {
     uint8_t in[64];
 } md5_context_t;
 
+#define ESP_ROM_MD5_DIGEST_LEN 16
+
 /**
  * @brief Initialize the MD5 context
  *
@@ -56,7 +58,7 @@ void esp_rom_md5_update(md5_context_t *context, const uint8_t *buf, uint32_t len
  * @param digest Where to store the 128-bit digest value
  * @param context MD5 context
  */
-void esp_rom_md5_final(uint8_t digest[16], md5_context_t *context);
+void esp_rom_md5_final(uint8_t digest[ESP_ROM_MD5_DIGEST_LEN], md5_context_t *context);
 
 #ifdef __cplusplus
 }
diff --git a/components/partition_table/Kconfig.projbuild b/components/partition_table/Kconfig.projbuild
index 6aaef75875..208b75d9eb 100644
--- a/components/partition_table/Kconfig.projbuild
+++ b/components/partition_table/Kconfig.projbuild
@@ -121,6 +121,7 @@ menu "Partition Table"
     config PARTITION_TABLE_MD5
         bool "Generate an MD5 checksum for the partition table"
         default y
+        depends on !ESP32_COMPATIBLE_PRE_V3_1_BOOTLOADERS
         help
             Generate an MD5 checksum for the partition table for protecting the
             integrity of the table. The generation should be turned off for legacy
diff --git a/components/spi_flash/partition.c b/components/spi_flash/partition.c
index 47b938f4ea..39675a5da5 100644
--- a/components/spi_flash/partition.c
+++ b/components/spi_flash/partition.c
@@ -24,6 +24,7 @@
 #include "esp_partition.h"
 #include "esp_flash_encrypt.h"
 #include "esp_log.h"
+#include "esp_rom_md5.h"
 #include "bootloader_common.h"
 #include "bootloader_util.h"
 #include "esp_ota_ops.h"
@@ -36,8 +37,6 @@
 #endif
 #include "sys/queue.h"
 
-
-
 typedef struct partition_list_item_ {
     esp_partition_t info;
     bool user_registered;
@@ -164,24 +163,53 @@ static esp_partition_iterator_opaque_t* iterator_create(esp_partition_type_t typ
 // This function is called only once, with s_partition_list_lock taken.
 static esp_err_t load_partitions(void)
 {
-    const uint32_t* ptr;
+    const uint8_t *p_start;
+    const uint8_t *p_end;
     spi_flash_mmap_handle_t handle;
+
+    // Temporary list of loaded partitions, if valid then we copy this to s_partition_list
+    typeof(s_partition_list) new_partitions_list = SLIST_HEAD_INITIALIZER(s_partition_list);
+    partition_list_item_t* last = NULL;
+
+#if CONFIG_PARTITION_TABLE_MD5
+    const uint8_t *md5_part = NULL;
+    const uint8_t *stored_md5;
+    uint8_t calc_md5[ESP_ROM_MD5_DIGEST_LEN];
+    md5_context_t context;
+
+    esp_rom_md5_init(&context);
+#endif
+
     // map 64kB block where partition table is located
     esp_err_t err = spi_flash_mmap(ESP_PARTITION_TABLE_OFFSET & 0xffff0000,
-            SPI_FLASH_SEC_SIZE, SPI_FLASH_MMAP_DATA, (const void**) &ptr, &handle);
+                                   SPI_FLASH_SEC_SIZE, SPI_FLASH_MMAP_DATA, (const void **)&p_start, &handle);
     if (err != ESP_OK) {
         return err;
     }
     // calculate partition address within mmap-ed region
-    const esp_partition_info_t* it = (const esp_partition_info_t*)
-            (ptr + (ESP_PARTITION_TABLE_OFFSET & 0xffff) / sizeof(*ptr));
-    const esp_partition_info_t* end = it + SPI_FLASH_SEC_SIZE / sizeof(*it);
-    // tail of the linked list of partitions
-    partition_list_item_t* last = NULL;
-    for (; it != end; ++it) {
-        if (it->magic != ESP_PARTITION_MAGIC) {
+    p_start += (ESP_PARTITION_TABLE_OFFSET & 0xffff);
+    p_end = p_start + SPI_FLASH_SEC_SIZE;
+
+    for(const uint8_t *p_entry = p_start; p_entry < p_end; p_entry += sizeof(esp_partition_info_t)) {
+        esp_partition_info_t entry;
+        // copying to RAM instead of using pointer to flash to avoid any chance of TOCTOU due to cache miss
+        // when flash encryption is used
+        memcpy(&entry, p_entry, sizeof(entry));
+
+#if CONFIG_PARTITION_TABLE_MD5
+        if (entry.magic == ESP_PARTITION_MAGIC_MD5) {
+            md5_part = p_entry;
+            break;
+        }
+#endif
+        if (entry.magic != ESP_PARTITION_MAGIC) {
             break;
         }
+
+#if CONFIG_PARTITION_TABLE_MD5
+        esp_rom_md5_update(&context, &entry, sizeof(entry));
+#endif
+
         // allocate new linked list item and populate it with data from partition table
         partition_list_item_t* item = (partition_list_item_t*) calloc(sizeof(partition_list_item_t), 1);
         if (item == NULL) {
@@ -189,35 +217,70 @@ static esp_err_t load_partitions(void)
             break;
         }
         item->info.flash_chip = esp_flash_default_chip;
-        item->info.address = it->pos.offset;
-        item->info.size = it->pos.size;
-        item->info.type = it->type;
-        item->info.subtype = it->subtype;
-        item->info.encrypted = it->flags & PART_FLAG_ENCRYPTED;
+        item->info.address = entry.pos.offset;
+        item->info.size = entry.pos.size;
+        item->info.type = entry.type;
+        item->info.subtype = entry.subtype;
+        item->info.encrypted = entry.flags & PART_FLAG_ENCRYPTED;
         item->user_registered = false;
 
         if (!esp_flash_encryption_enabled()) {
             /* If flash encryption is not turned on, no partitions should be treated as encrypted */
             item->info.encrypted = false;
-        } else if (it->type == PART_TYPE_APP
-                || (it->type == PART_TYPE_DATA && it->subtype == PART_SUBTYPE_DATA_OTA)
-                || (it->type == PART_TYPE_DATA && it->subtype == PART_SUBTYPE_DATA_NVS_KEYS)) {
+        } else if (entry.type == PART_TYPE_APP
+                || (entry.type == PART_TYPE_DATA && entry.subtype == PART_SUBTYPE_DATA_OTA)
+                || (entry.type == PART_TYPE_DATA && entry.subtype == PART_SUBTYPE_DATA_NVS_KEYS)) {
             /* If encryption is turned on, all app partitions and OTA data
                are always encrypted */
             item->info.encrypted = true;
         }
 
-        // it->label may not be zero-terminated
-        strncpy(item->info.label, (const char*) it->label, sizeof(item->info.label) - 1);
-        item->info.label[sizeof(it->label)] = 0;
+        // note: if label in flash is not null terminated, one byte will be truncated here
+        strlcpy(item->info.label, (const char*) entry.label, sizeof(item->info.label));
+
         // add it to the list
         if (last == NULL) {
-            SLIST_INSERT_HEAD(&s_partition_list, item, next);
+            SLIST_INSERT_HEAD(&new_partitions_list, item, next);
         } else {
             SLIST_INSERT_AFTER(last, item, next);
         }
         last = item;
     }
+
+#if CONFIG_PARTITION_TABLE_MD5
+    if (md5_part == NULL) {
+        ESP_LOGE(TAG, "No MD5 found in partition table");
+        err = ESP_ERR_NOT_FOUND;
+    } else {
+        stored_md5 = md5_part + ESP_PARTITION_MD5_OFFSET;
+
+        esp_rom_md5_final(calc_md5, &context);
+
+        ESP_LOG_BUFFER_HEXDUMP("calculated md5", calc_md5, ESP_ROM_MD5_DIGEST_LEN, ESP_LOG_VERBOSE);
+        ESP_LOG_BUFFER_HEXDUMP("stored md5", stored_md5, ESP_ROM_MD5_DIGEST_LEN, ESP_LOG_VERBOSE);
+
+        if (memcmp(calc_md5, stored_md5, ESP_ROM_MD5_DIGEST_LEN) != 0) {
+            ESP_LOGE(TAG, "Partition table MD5 mismatch");
+            err = ESP_ERR_INVALID_STATE;
+        } else {
+            ESP_LOGD(TAG, "Partition table MD5 verified");
+        }
+    }
+#endif
+
+    if (err == ESP_OK) {
+        /* Don't copy the list to the static variable unless it's verified */
+        s_partition_list = new_partitions_list;
+    } else {
+        /* Otherwise, free all the memory we just allocated */
+        partition_list_item_t *it = new_partitions_list.slh_first;
+        while (it) {
+            partition_list_item_t *next = it->next.sle_next;
+            free(it);
+            it = next;
+        }
+    }
+
     spi_flash_munmap(handle);
     return err;
 }
diff --git a/docs/en/api-guides/bootloader.rst b/docs/en/api-guides/bootloader.rst
index 395efe2bc6..eba32ffb5e 100644
--- a/docs/en/api-guides/bootloader.rst
+++ b/docs/en/api-guides/bootloader.rst
@@ -35,6 +35,11 @@ The bootloader does not support booting apps from older versions of ESP-IDF. Whe
 
     Bootloaders built from very old versions of ESP-IDF (before ESP-IDF V2.1) perform less hardware configuration than newer versions. When using a bootloader from these early ESP-IDF versions and building a new app, enable the config option :ref:`CONFIG_ESP32_COMPATIBLE_PRE_V2_1_BOOTLOADERS`.
 
+    Before ESP-IDF V3.1
+    ^^^^^^^^^^^^^^^^^^^
+
+    Bootloaders built from versions of ESP-IDF before V3.1 do not support MD5 checksums in the partition table binary. When using a bootloader from these ESP-IDF versions and building a new app, enable the config option :ref:`CONFIG_ESP32_COMPATIBLE_PRE_V3_1_BOOTLOADERS`.
+
 SPI Flash Configuration
 ^^^^^^^^^^^^^^^^^^^^^^^
 
diff --git a/docs/en/api-guides/partition-tables.rst b/docs/en/api-guides/partition-tables.rst
index 3a6ef16547..297551ea07 100644
--- a/docs/en/api-guides/partition-tables.rst
+++ b/docs/en/api-guides/partition-tables.rst
@@ -192,7 +192,14 @@ MD5 checksum
 
 The binary format of the partition table contains an MD5 checksum computed based on the partition table. This checksum is used for checking the integrity of the partition table during the boot.
 
-The MD5 checksum generation can be disabled by the ``--disable-md5sum`` option of ``gen_esp32part.py`` or by the :ref:`CONFIG_PARTITION_TABLE_MD5` option. This is useful for example when one uses a legacy bootloader which cannot process MD5 checksums and the boot fails with the error message ``invalid magic number 0xebeb``.
+.. only:: esp32
+
+    The MD5 checksum generation can be disabled by the ``--disable-md5sum`` option of ``gen_esp32part.py`` or by the :ref:`CONFIG_PARTITION_TABLE_MD5` option. This is useful for example when one :ref:`uses a bootloader from ESP-IDF before v3.1 <CONFIG_ESP32_COMPATIBLE_PRE_V3_1_BOOTLOADERS>` which cannot process MD5 checksums and the boot fails with the error message ``invalid magic number 0xebeb``.
+
+.. only:: not esp32
+
+    The MD5 checksum generation can be disabled by the ``--disable-md5sum`` option of ``gen_esp32part.py`` or by the :ref:`CONFIG_PARTITION_TABLE_MD5` option.
+
 
 Flashing the partition table
 ----------------------------
-- 
2.25.1


From 9235754d4c7b36ac33ec38ccb4576b9a3fd8ee70 Mon Sep 17 00:00:00 2001
From: Angus Gratton <angus@espressif.com>
Date: Thu, 4 Feb 2021 12:18:39 +1100
Subject: [PATCH 20/43] esp_rom: Allow passing any type of data pointer to md5,
 remove unchecked size on digest pointer

---
 components/esp_rom/include/esp_rom_md5.h | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/components/esp_rom/include/esp_rom_md5.h b/components/esp_rom/include/esp_rom_md5.h
index 7adc430bcb..0deaca4714 100644
--- a/components/esp_rom/include/esp_rom_md5.h
+++ b/components/esp_rom/include/esp_rom_md5.h
@@ -48,9 +48,9 @@ void esp_rom_md5_init(md5_context_t *context);
  *
  * @param context MD5 context which has been initialized by `MD5Init`
  * @param buf Input buffer
- * @param len Buffer length
+ * @param len Buffer length in bytes
  */
-void esp_rom_md5_update(md5_context_t *context, const uint8_t *buf, uint32_t len);
+void esp_rom_md5_update(md5_context_t *context, const void *buf, uint32_t len);
 
 /**
  * @brief Extract the MD5 result, and erase the context
@@ -58,7 +58,7 @@ void esp_rom_md5_update(md5_context_t *context, const uint8_t *buf, uint32_t len
  * @param digest Where to store the 128-bit digest value
  * @param context MD5 context
  */
-void esp_rom_md5_final(uint8_t digest[ESP_ROM_MD5_DIGEST_LEN], md5_context_t *context);
+void esp_rom_md5_final(uint8_t *digest, md5_context_t *context);
 
 #ifdef __cplusplus
 }
-- 
2.25.1


From 83f2d802ce4d613a60fa223066eebd949c7d0acb Mon Sep 17 00:00:00 2001
From: morris <maoshengrong@espressif.com>
Date: Tue, 18 May 2021 10:50:01 +0800
Subject: [PATCH 21/43] esp_eth: fix default PHY reset gpio

Closes https://github.com/espressif/esp-idf/issues/7034
---
 components/esp_eth/component.mk                | 2 +-
 examples/ethernet/basic/main/Kconfig.projbuild | 5 ++---
 2 files changed, 3 insertions(+), 4 deletions(-)

diff --git a/components/esp_eth/component.mk b/components/esp_eth/component.mk
index 4650d5f5c4..3426f54cde 100644
--- a/components/esp_eth/component.mk
+++ b/components/esp_eth/component.mk
@@ -5,7 +5,7 @@ COMPONENT_ADD_INCLUDEDIRS := include
 COMPONENT_SRCDIRS := src
 
 ifndef CONFIG_ETH_USE_ESP32_EMAC
-    COMPONENT_OBJEXCLUDE += src/esp_eth_mac_esp32.o
+    COMPONENT_OBJEXCLUDE += src/esp_eth_mac_esp.o
 endif
 
 ifndef CONFIG_ETH_SPI_ETHERNET_DM9051
diff --git a/examples/ethernet/basic/main/Kconfig.projbuild b/examples/ethernet/basic/main/Kconfig.projbuild
index 2d01147086..be155389b2 100644
--- a/examples/ethernet/basic/main/Kconfig.projbuild
+++ b/examples/ethernet/basic/main/Kconfig.projbuild
@@ -145,7 +145,7 @@ menu "Example Configuration"
             range 0 34 if IDF_TARGET_ESP32
             range 0 46 if IDF_TARGET_ESP32S2
             range 0 19 if IDF_TARGET_ESP32C3
-            default 5 if IDF_TARGET_ESP32
+            default 16 if IDF_TARGET_ESP32
             default 21 if IDF_TARGET_ESP32S2
             default 10 if IDF_TARGET_ESP32C3
             help
@@ -169,8 +169,7 @@ menu "Example Configuration"
 
     config EXAMPLE_ETH_PHY_RST_GPIO
         int "PHY Reset GPIO number"
-        default 16 if IDF_TARGET_ESP32
-        default 5 if IDF_TARGET_ESP32S2 || IDF_TARGET_ESP32C3
+        default 5
         help
             Set the GPIO number used to reset PHY chip.
             Set to -1 to disable PHY chip hardware reset.
-- 
2.25.1


From 0c25793b0663f9ae8ad70713d5898a9ba61a743f Mon Sep 17 00:00:00 2001
From: morris <maoshengrong@espressif.com>
Date: Thu, 6 May 2021 20:16:12 +0800
Subject: [PATCH 22/43] esp_eth: restart negotiation in esp_eth_start

---
 components/esp_eth/src/esp_eth.c                |  6 ++++--
 components/esp_eth/src/esp_eth_phy_dm9051.c     | 10 +++++-----
 components/esp_eth/src/esp_eth_phy_dp83848.c    | 10 +++++-----
 components/esp_eth/src/esp_eth_phy_ip101.c      | 10 +++++-----
 components/esp_eth/src/esp_eth_phy_ksz80xx.c    | 10 +++++-----
 components/esp_eth/src/esp_eth_phy_ksz8851snl.c | 10 +++++-----
 components/esp_eth/src/esp_eth_phy_lan8720.c    | 10 +++++-----
 components/esp_eth/src/esp_eth_phy_rtl8201.c    | 10 +++++-----
 components/esp_eth/src/esp_eth_phy_w5500.c      |  6 ++----
 9 files changed, 41 insertions(+), 41 deletions(-)

diff --git a/components/esp_eth/src/esp_eth.c b/components/esp_eth/src/esp_eth.c
index 2e16de1893..611ba936c9 100644
--- a/components/esp_eth/src/esp_eth.c
+++ b/components/esp_eth/src/esp_eth.c
@@ -269,14 +269,16 @@ esp_err_t esp_eth_start(esp_eth_handle_t hdl)
     esp_eth_driver_t *eth_driver = (esp_eth_driver_t *)hdl;
     ESP_GOTO_ON_FALSE(eth_driver, ESP_ERR_INVALID_ARG, err, TAG, "ethernet driver handle can't be null");
     esp_eth_phy_t *phy = eth_driver->phy;
+    esp_eth_mac_t *mac = eth_driver->mac;
     // check if driver has stopped
     esp_eth_fsm_t expected_fsm = ESP_ETH_FSM_STOP;
     ESP_GOTO_ON_FALSE(atomic_compare_exchange_strong(&eth_driver->fsm, &expected_fsm, ESP_ETH_FSM_START),
                       ESP_ERR_INVALID_STATE, err, TAG, "driver started already");
-    // reset PHY device, to put it back to LINK_DOWN state
-    ESP_GOTO_ON_ERROR(phy->reset(phy), err, TAG, "reset phy failed");
+    ESP_GOTO_ON_ERROR(phy->negotiate(phy), err, TAG, "phy negotiation failed");
+    ESP_GOTO_ON_ERROR(mac->start(mac), err, TAG, "start mac failed");
     ESP_GOTO_ON_ERROR(esp_event_post(ETH_EVENT, ETHERNET_EVENT_START, &eth_driver, sizeof(esp_eth_driver_t *), 0),
                       err, TAG, "send ETHERNET_EVENT_START event failed");
+    ESP_GOTO_ON_ERROR(phy->get_link(phy), err, TAG, "phy get link status failed");
     ESP_GOTO_ON_ERROR(esp_timer_start_periodic(eth_driver->check_link_timer, eth_driver->check_link_period_ms * 1000),
                       err, TAG, "start link timer failed");
 err:
diff --git a/components/esp_eth/src/esp_eth_phy_dm9051.c b/components/esp_eth/src/esp_eth_phy_dm9051.c
index 95b66a896c..5c1c112a61 100644
--- a/components/esp_eth/src/esp_eth_phy_dm9051.c
+++ b/components/esp_eth/src/esp_eth_phy_dm9051.c
@@ -200,6 +200,8 @@ static esp_err_t dm9051_negotiate(esp_eth_phy_t *phy)
     esp_err_t ret = ESP_OK;
     phy_dm9051_t *dm9051 = __containerof(phy, phy_dm9051_t, parent);
     esp_eth_mediator_t *eth = dm9051->eth;
+    /* in case any link status has changed, let's assume we're in link down status */
+    dm9051->link_status = ETH_LINK_DOWN;
     /* Start auto negotiation */
     bmcr_reg_t bmcr = {
         .speed_select = 1,     /* 100Mbps */
@@ -212,19 +214,17 @@ static esp_err_t dm9051_negotiate(esp_eth_phy_t *phy)
     bmsr_reg_t bmsr;
     dscsr_reg_t dscsr;
     uint32_t to = 0;
-    for (to = 0; to < dm9051->autonego_timeout_ms / 10; to++) {
-        vTaskDelay(pdMS_TO_TICKS(10));
+    for (to = 0; to < dm9051->autonego_timeout_ms / 100; to++) {
+        vTaskDelay(pdMS_TO_TICKS(100));
         ESP_GOTO_ON_ERROR(eth->phy_reg_read(eth, dm9051->addr, ETH_PHY_BMSR_REG_ADDR, &(bmsr.val)), err, TAG, "read BMSR failed");
         ESP_GOTO_ON_ERROR(eth->phy_reg_read(eth, dm9051->addr, ETH_PHY_DSCSR_REG_ADDR, &(dscsr.val)), err, TAG, "read DSCSR failed");
         if (bmsr.auto_nego_complete && dscsr.anmb & 0x08) {
             break;
         }
     }
-    if (to >= dm9051->autonego_timeout_ms / 10) {
+    if (to >= dm9051->autonego_timeout_ms / 100) {
         ESP_LOGW(TAG, "Ethernet PHY auto negotiation timeout");
     }
-    /* Updata information about link, speed, duplex */
-    ESP_GOTO_ON_ERROR(dm9051_update_link_duplex_speed(dm9051), err, TAG, "update link duplex speed failed");
     return ESP_OK;
 err:
     return ret;
diff --git a/components/esp_eth/src/esp_eth_phy_dp83848.c b/components/esp_eth/src/esp_eth_phy_dp83848.c
index 96508897f7..cafef8d59c 100644
--- a/components/esp_eth/src/esp_eth_phy_dp83848.c
+++ b/components/esp_eth/src/esp_eth_phy_dp83848.c
@@ -194,6 +194,8 @@ static esp_err_t dp83848_negotiate(esp_eth_phy_t *phy)
     esp_err_t ret = ESP_OK;
     phy_dp83848_t *dp83848 = __containerof(phy, phy_dp83848_t, parent);
     esp_eth_mediator_t *eth = dp83848->eth;
+    /* in case any link status has changed, let's assume we're in link down status */
+    dp83848->link_status = ETH_LINK_DOWN;
     /* Start auto negotiation */
     bmcr_reg_t bmcr = {
         .speed_select = 1,     /* 100Mbps */
@@ -206,8 +208,8 @@ static esp_err_t dp83848_negotiate(esp_eth_phy_t *phy)
     bmsr_reg_t bmsr;
     physts_reg_t physts;
     uint32_t to = 0;
-    for (to = 0; to < dp83848->autonego_timeout_ms / 10; to++) {
-        vTaskDelay(pdMS_TO_TICKS(10));
+    for (to = 0; to < dp83848->autonego_timeout_ms / 100; to++) {
+        vTaskDelay(pdMS_TO_TICKS(100));
         ESP_GOTO_ON_ERROR(eth->phy_reg_read(eth, dp83848->addr, ETH_PHY_BMSR_REG_ADDR, &(bmsr.val)), err, TAG, "read BMSR failed");
         ESP_GOTO_ON_ERROR(eth->phy_reg_read(eth, dp83848->addr, ETH_PHY_STS_REG_ADDR, &(physts.val)), err, TAG, "read PHYSTS failed");
         if (bmsr.auto_nego_complete && physts.auto_nego_complete) {
@@ -215,11 +217,9 @@ static esp_err_t dp83848_negotiate(esp_eth_phy_t *phy)
         }
     }
     /* Auto negotiation failed, maybe no network cable plugged in, so output a warning */
-    if (to >= dp83848->autonego_timeout_ms / 10) {
+    if (to >= dp83848->autonego_timeout_ms / 100) {
         ESP_LOGW(TAG, "auto negotiation timeout");
     }
-    /* Updata information about link, speed, duplex */
-    ESP_GOTO_ON_ERROR(dp83848_update_link_duplex_speed(dp83848), err, TAG, "update link duplex speed failed");
     return ESP_OK;
 err:
     return ret;
diff --git a/components/esp_eth/src/esp_eth_phy_ip101.c b/components/esp_eth/src/esp_eth_phy_ip101.c
index a412a631e6..e8424288b6 100644
--- a/components/esp_eth/src/esp_eth_phy_ip101.c
+++ b/components/esp_eth/src/esp_eth_phy_ip101.c
@@ -235,6 +235,8 @@ static esp_err_t ip101_negotiate(esp_eth_phy_t *phy)
     esp_err_t ret = ESP_OK;
     phy_ip101_t *ip101 = __containerof(phy, phy_ip101_t, parent);
     esp_eth_mediator_t *eth = ip101->eth;
+    /* in case any link status has changed, let's assume we're in link down status */
+    ip101->link_status = ETH_LINK_DOWN;
     /* Restart auto negotiation */
     bmcr_reg_t bmcr = {
         .speed_select = 1,     /* 100Mbps */
@@ -246,19 +248,17 @@ static esp_err_t ip101_negotiate(esp_eth_phy_t *phy)
     /* Wait for auto negotiation complete */
     bmsr_reg_t bmsr;
     uint32_t to = 0;
-    for (to = 0; to < ip101->autonego_timeout_ms / 10; to++) {
-        vTaskDelay(pdMS_TO_TICKS(10));
+    for (to = 0; to < ip101->autonego_timeout_ms / 100; to++) {
+        vTaskDelay(pdMS_TO_TICKS(100));
         ESP_GOTO_ON_ERROR(eth->phy_reg_read(eth, ip101->addr, ETH_PHY_BMSR_REG_ADDR, &(bmsr.val)), err, TAG, "read BMSR failed");
         if (bmsr.auto_nego_complete) {
             break;
         }
     }
     /* Auto negotiation failed, maybe no network cable plugged in, so output a warning */
-    if (to >= ip101->autonego_timeout_ms / 10) {
+    if (to >= ip101->autonego_timeout_ms / 100) {
         ESP_LOGW(TAG, "auto negotiation timeout");
     }
-    /* Updata information about link, speed, duplex */
-    ESP_GOTO_ON_ERROR(ip101_update_link_duplex_speed(ip101), err, TAG, "update link duplex speed failed");
     return ESP_OK;
 err:
     return ret;
diff --git a/components/esp_eth/src/esp_eth_phy_ksz80xx.c b/components/esp_eth/src/esp_eth_phy_ksz80xx.c
index c328ae1232..1674648085 100644
--- a/components/esp_eth/src/esp_eth_phy_ksz80xx.c
+++ b/components/esp_eth/src/esp_eth_phy_ksz80xx.c
@@ -213,6 +213,8 @@ static esp_err_t ksz80xx_negotiate(esp_eth_phy_t *phy)
     esp_err_t ret = ESP_OK;
     phy_ksz80xx_t *ksz80xx = __containerof(phy, phy_ksz80xx_t, parent);
     esp_eth_mediator_t *eth = ksz80xx->eth;
+    /* in case any link status has changed, let's assume we're in link down status */
+    ksz80xx->link_status = ETH_LINK_DOWN;
     /* Restart auto negotiation */
     bmcr_reg_t bmcr = {
         .speed_select = 1,     /* 100Mbps */
@@ -224,19 +226,17 @@ static esp_err_t ksz80xx_negotiate(esp_eth_phy_t *phy)
     /* Wait for auto negotiation complete */
     bmsr_reg_t bmsr;
     uint32_t to = 0;
-    for (to = 0; to < ksz80xx->autonego_timeout_ms / 10; to++) {
-        vTaskDelay(pdMS_TO_TICKS(10));
+    for (to = 0; to < ksz80xx->autonego_timeout_ms / 100; to++) {
+        vTaskDelay(pdMS_TO_TICKS(100));
         ESP_GOTO_ON_ERROR(eth->phy_reg_read(eth, ksz80xx->addr, ETH_PHY_BMSR_REG_ADDR, &(bmsr.val)), err, TAG, "read BMSR failed");
         if (bmsr.auto_nego_complete) {
             break;
         }
     }
     /* Auto negotiation failed, maybe no network cable plugged in, so output a warning */
-    if (to >= ksz80xx->autonego_timeout_ms / 10) {
+    if (to >= ksz80xx->autonego_timeout_ms / 100) {
         ESP_LOGW(TAG, "auto negotiation timeout");
     }
-    /* Updata information about link, speed, duplex */
-    ESP_GOTO_ON_ERROR(ksz80xx_update_link_duplex_speed(ksz80xx), err, TAG, "update link duplex speed failed");
     return ESP_OK;
 err:
     return ret;
diff --git a/components/esp_eth/src/esp_eth_phy_ksz8851snl.c b/components/esp_eth/src/esp_eth_phy_ksz8851snl.c
index ab5cf497ea..2f72e6b394 100644
--- a/components/esp_eth/src/esp_eth_phy_ksz8851snl.c
+++ b/components/esp_eth/src/esp_eth_phy_ksz8851snl.c
@@ -166,27 +166,27 @@ static esp_err_t phy_ksz8851_negotiate(esp_eth_phy_t *phy)
     phy_ksz8851snl_t *ksz8851 = __containerof(phy, phy_ksz8851snl_t, parent);
     esp_eth_mediator_t *eth   = ksz8851->eth;
     ESP_LOGD(TAG, "restart negotiation");
-
+    /* in case any link status has changed, let's assume we're in link down status */
+    ksz8851->link_status = ETH_LINK_DOWN;
     uint32_t control;
     ESP_GOTO_ON_ERROR(eth->phy_reg_read(eth, ksz8851->addr, KSZ8851_P1CR, &control), err, TAG, "P1CR read failed");
     ESP_GOTO_ON_ERROR(eth->phy_reg_write(eth, ksz8851->addr, KSZ8851_P1CR, control | P1CR_RESTART_AN), err, TAG, "P1CR write failed");
 
     uint32_t status;
     unsigned to;
-    for (to = 0; to < ksz8851->autonego_timeout_ms / 10; to++) {
-        vTaskDelay(pdMS_TO_TICKS(10));
+    for (to = 0; to < ksz8851->autonego_timeout_ms / 100; to++) {
+        vTaskDelay(pdMS_TO_TICKS(100));
         ESP_GOTO_ON_ERROR(eth->phy_reg_read(eth, ksz8851->addr, KSZ8851_P1SR, &status), err, TAG, "P1SR read failed");
         if (status & P1SR_AN_DONE) {
             break;
         }
     }
-    if (to >= ksz8851->autonego_timeout_ms / 10) {
+    if (to >= ksz8851->autonego_timeout_ms / 100) {
         ESP_LOGW(TAG, "Ethernet PHY auto negotiation timeout");
     }
 
     ESP_GOTO_ON_ERROR(eth->phy_reg_write(eth, ksz8851->addr, KSZ8851_P1CR, control), err, TAG, "P1CR write failed");
 
-    ESP_GOTO_ON_ERROR(ksz8851_update_link_duplex_speed(ksz8851), err, TAG, "update link duplex speed failed");
     ESP_LOGD(TAG, "negotiation succeeded");
     return ESP_OK;
 err:
diff --git a/components/esp_eth/src/esp_eth_phy_lan8720.c b/components/esp_eth/src/esp_eth_phy_lan8720.c
index bb84160279..88a04ff1b9 100644
--- a/components/esp_eth/src/esp_eth_phy_lan8720.c
+++ b/components/esp_eth/src/esp_eth_phy_lan8720.c
@@ -278,6 +278,8 @@ static esp_err_t lan8720_negotiate(esp_eth_phy_t *phy)
     esp_err_t ret = ESP_OK;
     phy_lan8720_t *lan8720 = __containerof(phy, phy_lan8720_t, parent);
     esp_eth_mediator_t *eth = lan8720->eth;
+    /* in case any link status has changed, let's assume we're in link down status */
+    lan8720->link_status = ETH_LINK_DOWN;
     /* Restart auto negotiation */
     bmcr_reg_t bmcr = {
         .speed_select = 1,     /* 100Mbps */
@@ -290,8 +292,8 @@ static esp_err_t lan8720_negotiate(esp_eth_phy_t *phy)
     bmsr_reg_t bmsr;
     pscsr_reg_t pscsr;
     uint32_t to = 0;
-    for (to = 0; to < lan8720->autonego_timeout_ms / 10; to++) {
-        vTaskDelay(pdMS_TO_TICKS(10));
+    for (to = 0; to < lan8720->autonego_timeout_ms / 100; to++) {
+        vTaskDelay(pdMS_TO_TICKS(100));
         ESP_GOTO_ON_ERROR(eth->phy_reg_read(eth, lan8720->addr, ETH_PHY_BMSR_REG_ADDR, &(bmsr.val)), err, TAG, "read BMSR failed");
         ESP_GOTO_ON_ERROR(eth->phy_reg_read(eth, lan8720->addr, ETH_PHY_PSCSR_REG_ADDR, &(pscsr.val)), err, TAG, "read PSCSR failed");
         if (bmsr.auto_nego_complete && pscsr.auto_nego_done) {
@@ -299,11 +301,9 @@ static esp_err_t lan8720_negotiate(esp_eth_phy_t *phy)
         }
     }
     /* Auto negotiation failed, maybe no network cable plugged in, so output a warning */
-    if (to >= lan8720->autonego_timeout_ms / 10) {
+    if (to >= lan8720->autonego_timeout_ms / 100) {
         ESP_LOGW(TAG, "auto negotiation timeout");
     }
-    /* Updata information about link, speed, duplex */
-    ESP_GOTO_ON_ERROR(lan8720_update_link_duplex_speed(lan8720), err, TAG, "update link duplex speed failed");
     return ESP_OK;
 err:
     return ret;
diff --git a/components/esp_eth/src/esp_eth_phy_rtl8201.c b/components/esp_eth/src/esp_eth_phy_rtl8201.c
index fe0f6c9014..8ba4a35445 100644
--- a/components/esp_eth/src/esp_eth_phy_rtl8201.c
+++ b/components/esp_eth/src/esp_eth_phy_rtl8201.c
@@ -188,6 +188,8 @@ static esp_err_t rtl8201_negotiate(esp_eth_phy_t *phy)
     esp_err_t ret = ESP_OK;
     phy_rtl8201_t *rtl8201 = __containerof(phy, phy_rtl8201_t, parent);
     esp_eth_mediator_t *eth = rtl8201->eth;
+    /* in case any link status has changed, let's assume we're in link down status */
+    rtl8201->link_status = ETH_LINK_DOWN;
     /* Restart auto negotiation */
     bmcr_reg_t bmcr = {
         .speed_select = 1,     /* 100Mbps */
@@ -199,19 +201,17 @@ static esp_err_t rtl8201_negotiate(esp_eth_phy_t *phy)
     /* Wait for auto negotiation complete */
     bmsr_reg_t bmsr;
     uint32_t to = 0;
-    for (to = 0; to < rtl8201->autonego_timeout_ms / 10; to++) {
-        vTaskDelay(pdMS_TO_TICKS(10));
+    for (to = 0; to < rtl8201->autonego_timeout_ms / 100; to++) {
+        vTaskDelay(pdMS_TO_TICKS(100));
         ESP_GOTO_ON_ERROR(eth->phy_reg_read(eth, rtl8201->addr, ETH_PHY_BMSR_REG_ADDR, &(bmsr.val)), err, TAG, "read BMSR failed");
         if (bmsr.auto_nego_complete) {
             break;
         }
     }
     /* Auto negotiation failed, maybe no network cable plugged in, so output a warning */
-    if (to >= rtl8201->autonego_timeout_ms / 10) {
+    if (to >= rtl8201->autonego_timeout_ms / 100) {
         ESP_LOGW(TAG, "auto negotiation timeout");
     }
-    /* Updata information about link, speed, duplex */
-    ESP_GOTO_ON_ERROR(rtl8201_update_link_duplex_speed(rtl8201), err, TAG, "update link duplex speed failed");
     return ESP_OK;
 err:
     return ret;
diff --git a/components/esp_eth/src/esp_eth_phy_w5500.c b/components/esp_eth/src/esp_eth_phy_w5500.c
index ac43ed7b52..2ec157c6b4 100644
--- a/components/esp_eth/src/esp_eth_phy_w5500.c
+++ b/components/esp_eth/src/esp_eth_phy_w5500.c
@@ -148,15 +148,13 @@ static esp_err_t w5500_negotiate(esp_eth_phy_t *phy)
     esp_err_t ret = ESP_OK;
     phy_w5500_t *w5500 = __containerof(phy, phy_w5500_t, parent);
     esp_eth_mediator_t *eth = w5500->eth;
-
+    /* in case any link status has changed, let's assume we're in link down status */
+    w5500->link_status = ETH_LINK_DOWN;
     phycfg_reg_t phycfg;
     ESP_GOTO_ON_ERROR(eth->phy_reg_read(eth, w5500->addr, W5500_REG_PHYCFGR, (uint32_t *) & (phycfg.val)), err, TAG, "read PHYCFG failed");
     phycfg.opsel = 1;  // PHY working mode configured by register
     phycfg.opmode = 7; // all capable, auto-negotiation enabled
     ESP_GOTO_ON_ERROR(eth->phy_reg_write(eth, w5500->addr, W5500_REG_PHYCFGR, phycfg.val), err, TAG, "write PHYCFG failed");
-
-    /* Update information about link, speed, duplex */
-    ESP_GOTO_ON_ERROR(w5500_update_link_duplex_speed(w5500), err, TAG, "update link duplex speed failed");
     return ESP_OK;
 err:
     return ret;
-- 
2.25.1


From 9b4ba3d7078779cf85da760bd0930883aede329f Mon Sep 17 00:00:00 2001
From: Marius Vikhammer <marius.vikhammer@espressif.com>
Date: Tue, 30 Mar 2021 20:12:08 +0800
Subject: [PATCH 23/43] crypto: initial S3 Beta 3 bringup and testing for
 SHA/AES/RSA/flash enc

---
 components/bootloader/Kconfig.projbuild     |  2 +-
 components/esptool_py/CMakeLists.txt        |  3 +-
 components/esptool_py/project_include.cmake |  2 ++
 components/mbedtls/Kconfig                  |  2 +-
 components/mbedtls/port/aes/dma/esp_aes.c   |  3 +-
 components/mbedtls/test/test_mbedtls_sha.c  |  8 ++---
 components/soc/include/soc/lldesc.h         | 33 +++++++++++++++++++--
 components/soc/lldesc.c                     |  6 ++--
 8 files changed, 43 insertions(+), 16 deletions(-)

diff --git a/components/bootloader/Kconfig.projbuild b/components/bootloader/Kconfig.projbuild
index 18a3a7da8f..73a8bcb812 100644
--- a/components/bootloader/Kconfig.projbuild
+++ b/components/bootloader/Kconfig.projbuild
@@ -634,7 +634,7 @@ menu "Security features"
     choice SECURE_FLASH_ENCRYPTION_KEYSIZE
         bool "Size of generated AES-XTS key"
         default SECURE_FLASH_ENCRYPTION_AES128
-        depends on IDF_TARGET_ESP32S2 && SECURE_FLASH_ENC_ENABLED
+        depends on (IDF_TARGET_ESP32S2 || IDF_TARGET_ESP32S3) && SECURE_FLASH_ENC_ENABLED
         help
             Size of generated AES-XTS key.
 
diff --git a/components/esptool_py/CMakeLists.txt b/components/esptool_py/CMakeLists.txt
index c57f25c820..094da4d240 100644
--- a/components/esptool_py/CMakeLists.txt
+++ b/components/esptool_py/CMakeLists.txt
@@ -24,11 +24,10 @@ consist of two ota app without factory or test partitions.")
 
     # Generate flasher_args.json for tools that need it. The variables below are used
     # in configuring the template flasher_args.json.in.
-    # Some of the variables (flash mode, size, frequency) are already set in project_include.cmake.
+    # Some of the variables (flash mode, size, frequency, chip) are already set in project_include.cmake.
 
     set(ESPTOOLPY_BEFORE "${CONFIG_ESPTOOLPY_BEFORE}")
     set(ESPTOOLPY_AFTER  "${CONFIG_ESPTOOLPY_AFTER}")
-    set(ESPTOOLPY_CHIP "${target}")
     if(CONFIG_ESPTOOLPY_NO_STUB)
         set(ESPTOOLPY_WITH_STUB false)
     else()
diff --git a/components/esptool_py/project_include.cmake b/components/esptool_py/project_include.cmake
index 07e72667a1..5948fe40c2 100644
--- a/components/esptool_py/project_include.cmake
+++ b/components/esptool_py/project_include.cmake
@@ -21,6 +21,8 @@ set(ESPFLASHMODE ${CONFIG_ESPTOOLPY_FLASHMODE})
 set(ESPFLASHFREQ ${CONFIG_ESPTOOLPY_FLASHFREQ})
 set(ESPFLASHSIZE ${CONFIG_ESPTOOLPY_FLASHSIZE})
 
+set(ESPTOOLPY_CHIP "${chip_model}")
+
 set(ESPTOOLPY_FLASH_OPTIONS
     --flash_mode ${ESPFLASHMODE}
     --flash_freq ${ESPFLASHFREQ}
diff --git a/components/mbedtls/Kconfig b/components/mbedtls/Kconfig
index bbe4009cee..9770497391 100644
--- a/components/mbedtls/Kconfig
+++ b/components/mbedtls/Kconfig
@@ -248,7 +248,7 @@ menu "mbedTLS"
 
     config MBEDTLS_AES_USE_INTERRUPT
         bool "Use interrupt for long AES operations"
-        depends on IDF_TARGET_ESP32S2 && MBEDTLS_HARDWARE_AES
+        depends on !IDF_TARGET_ESP32 && MBEDTLS_HARDWARE_AES
         default y
         help
             Use an interrupt to coordinate long AES operations.
diff --git a/components/mbedtls/port/aes/dma/esp_aes.c b/components/mbedtls/port/aes/dma/esp_aes.c
index a0b9af4ca5..1cd854000e 100644
--- a/components/mbedtls/port/aes/dma/esp_aes.c
+++ b/components/mbedtls/port/aes/dma/esp_aes.c
@@ -359,7 +359,8 @@ static int esp_aes_process_dma(esp_aes_context *ctx, const unsigned char *input,
         block_out_desc = block_desc + lldesc_num;
 
         lldesc_setup_link(block_in_desc, input, block_bytes, 0);
-        lldesc_setup_link(block_out_desc, output, block_bytes, 0);
+        //Limit max inlink descriptor length to be 16 byte aligned, require for EDMA
+        lldesc_setup_link_constrained(block_out_desc, output, block_bytes, LLDESC_MAX_NUM_PER_DESC_16B_ALIGNED, 0);
 
         out_desc_tail = &block_out_desc[lldesc_num - 1];
     }
diff --git a/components/mbedtls/test/test_mbedtls_sha.c b/components/mbedtls/test/test_mbedtls_sha.c
index 190769592a..88a9f364cf 100644
--- a/components/mbedtls/test/test_mbedtls_sha.c
+++ b/components/mbedtls/test/test_mbedtls_sha.c
@@ -475,11 +475,11 @@ TEST_CASE("mbedtls SHA512/t", "[mbedtls]")
         }
     }
 }
+#endif //CONFIG_MBEDTLS_HARDWARE_SHA
 
-#ifdef CONFIG_SPIRAM
+#ifdef CONFIG_SPIRAM_USE_MALLOC
 TEST_CASE("mbedtls SHA256 PSRAM DMA", "[mbedtls]")
 {
-
     const unsigned CALLS = 256;
     const unsigned CALL_SZ = 16 * 1024;
     mbedtls_sha256_context sha256_ctx;
@@ -510,6 +510,4 @@ TEST_CASE("mbedtls SHA256 PSRAM DMA", "[mbedtls]")
     TEST_ASSERT_EQUAL_STRING(expected_hash, hash_str);
 
 }
-#endif //CONFIG_SPIRAM
-
-#endif //CONFIG_MBEDTLS_HARDWARE_SHA
+#endif //CONFIG_SPIRAM_USE_MALLOC
diff --git a/components/soc/include/soc/lldesc.h b/components/soc/include/soc/lldesc.h
index 31e02125c4..ef74ce7aa4 100644
--- a/components/soc/include/soc/lldesc.h
+++ b/components/soc/include/soc/lldesc.h
@@ -31,6 +31,24 @@
 /** Maximum size of data in the buffer that a DMA descriptor can hold. */
 #define LLDESC_MAX_NUM_PER_DESC (4096-4)
 
+// Some DMA operations might impose certain alignment restrictions on the length
+#define LLDESC_MAX_NUM_PER_DESC_16B_ALIGNED (4096 - 16)
+#define LLDESC_MAX_NUM_PER_DESC_32B_ALIGNED (4096 - 32)
+
+/**
+ * Generate a linked list pointing to a (huge) buffer in an descriptor array.
+ *
+ * The caller should ensure there is enough size to hold the array, by calling
+ * ``lldesc_get_required_num_constrained`` with the same max_desc_size argument.
+ *
+ * @param[out] out_desc_array Output of a descriptor array, the head should be fed to the DMA.
+ * @param buffer Buffer for the descriptors to point to.
+ * @param size Size (or length for TX) of the buffer
+ * @param max_desc_size Maximum length of each descriptor
+ * @param isrx The RX DMA may require the buffer to be word-aligned, set to true for a RX link, otherwise false.
+ */
+void lldesc_setup_link_constrained(lldesc_t *out_desc_array, const void *buffer, int size, int max_desc_size, bool isrx);
+
 /**
  * Generate a linked list pointing to a (huge) buffer in an descriptor array.
  *
@@ -42,7 +60,7 @@
  * @param size Size (or length for TX) of the buffer
  * @param isrx The RX DMA may require the buffer to be word-aligned, set to true for a RX link, otherwise false.
  */
-void lldesc_setup_link(lldesc_t *out_desc_array, const void *buffer, int size, bool isrx);
+#define lldesc_setup_link(out_desc_array, buffer, size, isrx) lldesc_setup_link_constrained(out_desc_array, buffer, size, LLDESC_MAX_NUM_PER_DESC, isrx)
 
 /**
  * @brief Get the received length of a linked list, until end of the link or eof.
@@ -61,7 +79,16 @@ int lldesc_get_received_len(lldesc_t* head, lldesc_t** out_next);
  *
  * @return Numbers required.
  */
-static inline int lldesc_get_required_num(int data_size)
+static inline int lldesc_get_required_num_constrained(int data_size, int max_desc_size)
 {
-    return (data_size + LLDESC_MAX_NUM_PER_DESC - 1) / LLDESC_MAX_NUM_PER_DESC;
+    return (data_size + max_desc_size - 1) / max_desc_size;
 }
+
+/**
+ * Get the number of descriptors required for a given buffer size.
+ *
+ * @param data_size Size to check descriptor num.
+ * @param max_desc_size Maximum length of each descriptor
+ * @return Numbers required.
+ */
+#define lldesc_get_required_num(data_size) lldesc_get_required_num_constrained(data_size, LLDESC_MAX_NUM_PER_DESC)
diff --git a/components/soc/lldesc.c b/components/soc/lldesc.c
index c1bf6f022a..3e27537e05 100644
--- a/components/soc/lldesc.c
+++ b/components/soc/lldesc.c
@@ -1,12 +1,12 @@
 #include "soc/lldesc.h"
 
-void lldesc_setup_link(lldesc_t *dmadesc, const void *data, int len, bool isrx)
+void lldesc_setup_link_constrained(lldesc_t *dmadesc, const void *data, int len, int max_desc_size, bool isrx)
 {
     int n = 0;
     while (len) {
         int dmachunklen = len;
-        if (dmachunklen > LLDESC_MAX_NUM_PER_DESC) {
-            dmachunklen = LLDESC_MAX_NUM_PER_DESC;
+        if (dmachunklen > max_desc_size) {
+            dmachunklen = max_desc_size;
         }
         if (isrx) {
             //Receive needs DMA length rounded to next 32-bit boundary
-- 
2.25.1


From e14edecf5f8cd65b271da3880cc0f9473103eedb Mon Sep 17 00:00:00 2001
From: Angus Gratton <angus@espressif.com>
Date: Tue, 11 May 2021 11:40:38 +1000
Subject: [PATCH 24/43] docs: Add random number generation to the API Reference
 System section

---
 .../include/bootloader_random.h               | 29 ++++++-----
 .../esp_hw_support/include/esp_random.h       | 24 ++-------
 docs/doxygen/Doxyfile_common                  |  4 +-
 docs/en/api-reference/system/index.rst        |  1 +
 docs/en/api-reference/system/random.rst       | 49 +++++++++++++++++++
 docs/en/api-reference/system/system.rst       | 10 ----
 docs/zh_CN/api-guides/startup.rst             | 12 +++--
 docs/zh_CN/api-reference/system/random.rst    |  1 +
 8 files changed, 84 insertions(+), 46 deletions(-)
 create mode 100644 docs/en/api-reference/system/random.rst
 create mode 100644 docs/zh_CN/api-reference/system/random.rst

diff --git a/components/bootloader_support/include/bootloader_random.h b/components/bootloader_support/include/bootloader_random.h
index 0c7b61eb9b..268857dd6f 100644
--- a/components/bootloader_support/include/bootloader_random.h
+++ b/components/bootloader_support/include/bootloader_random.h
@@ -21,33 +21,38 @@ extern "C" {
 #endif
 
 /**
- * @brief Enable early entropy source for RNG
+ * @brief Enable an entropy source for RNG if RF is disabled
  *
- * Uses the SAR ADC to feed entropy into the HWRNG. The ADC is put
- * into a test mode that reads an internal reference voltage and
- * constantly feeds the LSB of data into the HWRNG. Consult the
- * SoC Technical Reference Manual for more information.
+ * The exact internal entropy source mechanism depends on the chip in use but
+ * all SoCs use the SAR ADC to continuously mix random bits (an internal
+ * noise reading) into the HWRNG. Consult the SoC Technical Reference
+ * Manual for more information.
  *
  * Can also be used from app code early during operation, if true
- * random numbers are required before WiFi stack is initialised.
- * Call this function from app code only if WiFi/BT are not yet
- * enabled and I2S and ADC are not in use.
- *
- * Call bootloader_random_disable() when done.
+ * random numbers are required before RF is initialised. Consult
+ * ESP-IDF Programming Guide "Random Number Generation" section for
+ * details.
  */
 void bootloader_random_enable(void);
 
 /**
- * @brief Disable early entropy source for RNG
+ * @brief Disable entropy source for RNG
  *
- * Disables SAR ADC source and resets the I2S hardware.
+ * Disables internal entropy source. Must be called after
+ * bootloader_random_enable() and before RF features, ADC, or
+ * I2S (ESP32 only) are initialized.
  *
+ * Consult the ESP-IDF Programming Guide "Random Number Generation"
+ * section for details.
  */
 void bootloader_random_disable(void);
 
 /**
  * @brief Fill buffer with 'length' random bytes
  *
+ * @note If this function is being called from app code only, and never
+ * from the bootloader, then it's better to call esp_fill_random().
+ *
  * @param buffer Pointer to buffer
  * @param length This many bytes of random data will be copied to buffer
  */
diff --git a/components/esp_hw_support/include/esp_random.h b/components/esp_hw_support/include/esp_random.h
index 7064fa8115..3b939ef132 100644
--- a/components/esp_hw_support/include/esp_random.h
+++ b/components/esp_hw_support/include/esp_random.h
@@ -24,28 +24,13 @@ extern "C" {
 /**
  * @brief  Get one random 32-bit word from hardware RNG
  *
- * The hardware RNG produces true random numbers under any of the following conditions:
- *
- * - An RF subsystem is running (i.e. Bluetooth or WiFi is enabled)
- * - An internal entropy source has been enabled by calling bootloader_random_enable()
- *   and not yet disabled by calling bootloader_random_disable()
- * - While the ESP-IDF bootloader is running (due to the internal entropy source being enabled
- *   for the duration of bootloader execution).
- *
- * If none of the above conditions are true, the hardware RNG will produce pseudo-random numbers only.
- *
- * When the hardware RNG is producing true random numbers, external entropy (noise samples) are
- * continuously mixed into the internal hardware RNG state. Consult the SoC Technical Reference Manual
- * for more details.
+ * If Wi-Fi or Bluetooth are enabled, this function returns true random numbers. In other
+ * situations, if true random numbers are required then consult the ESP-IDF Programming
+ * Guide "Random Number Generation" section for necessary prerequisites.
  *
  * This function automatically busy-waits to ensure enough external entropy has been
  * introduced into the hardware RNG state, before returning a new random number.
  *
- * If generating random numbers from an app which has not yet enabled Bluetooth or Wi-Fi, call the
- * API function bootloader_random_enable() before generating random numbers and then call
- * bootloader_random_disable() before using any APIs for Bluetooth, Wi-Fi, ADC, or I2S. Consult the
- * bootloader_random.h header for more details.
- *
  * @return Random value between 0 and UINT32_MAX
  */
 uint32_t esp_random(void);
@@ -53,7 +38,8 @@ uint32_t esp_random(void);
 /**
  * @brief Fill a buffer with random bytes from hardware RNG
  *
- * @note This function has the same restrictions regarding available entropy as esp_random()
+ * @note This function is implemented via calls to esp_random(), so the same
+ * constraints apply.
  *
  * @param buf Pointer to buffer to fill with random numbers.
  * @param len Length of buffer in bytes
diff --git a/docs/doxygen/Doxyfile_common b/docs/doxygen/Doxyfile_common
index 985e6cde9f..004c48370e 100644
--- a/docs/doxygen/Doxyfile_common
+++ b/docs/doxygen/Doxyfile_common
@@ -142,6 +142,7 @@ INPUT = \
     $(IDF_PATH)/components/spi_flash/include/esp_flash.h \
     $(IDF_PATH)/components/spi_flash/include/esp_partition.h \
     $(IDF_PATH)/components/bootloader_support/include/esp_flash_encrypt.h \
+    $(IDF_PATH)/components/bootloader_support/include/bootloader_random.h \
     $(IDF_PATH)/components/spiffs/include/esp_spiffs.h \
     $(IDF_PATH)/components/driver/include/driver/sdmmc_types.h \
     $(IDF_PATH)/components/sdmmc/include/sdmmc_cmd.h \
@@ -179,8 +180,9 @@ INPUT = \
     $(IDF_PATH)/components/esp_system/include/esp_expression_with_stack.h \
     $(IDF_PATH)/components/app_update/include/esp_ota_ops.h \
     $(IDF_PATH)/components/esp_https_ota/include/esp_https_ota.h \
-    $(IDF_PATH)/components/esp_hw_support/include/esp_sleep.h \
     $(IDF_PATH)/components/esp_hw_support/include/esp_async_memcpy.h \
+    $(IDF_PATH)/components/esp_hw_support/include/esp_random.h \
+    $(IDF_PATH)/components/esp_hw_support/include/esp_sleep.h \
     $(IDF_PATH)/components/log/include/esp_log.h \
     $(IDF_PATH)/components/esp_rom/include/esp_rom_sys.h \
     $(IDF_PATH)/components/esp_system/include/esp_system.h \
diff --git a/docs/en/api-reference/system/index.rst b/docs/en/api-reference/system/index.rst
index 3fa360854b..adc4a2930e 100644
--- a/docs/en/api-reference/system/index.rst
+++ b/docs/en/api-reference/system/index.rst
@@ -27,6 +27,7 @@ System API
     Over The Air Updates (OTA) <ota>
     :CONFIG_IDF_TARGET_ARCH_XTENSA: Performance Monitor <perfmon>
     Power Management <power_management>
+    Random Number Generation <random>
     Sleep Modes <sleep_modes>
     Watchdogs <wdts>
     System Time <system_time>
diff --git a/docs/en/api-reference/system/random.rst b/docs/en/api-reference/system/random.rst
new file mode 100644
index 0000000000..a25f65946f
--- /dev/null
+++ b/docs/en/api-reference/system/random.rst
@@ -0,0 +1,49 @@
+Random Number Generation
+========================
+
+{IDF_TARGET_RF_NAME: default="Wi-Fi or Bluetooth", esp32s2="Wi-Fi"}
+{IDF_TARGET_RF_IS: default="are", esp32s2="is"}
+{IDF_TARGET_BOOTLOADER_RANDOM_INCOMPATIBLE: default="", esp32="I2S, "}
+
+{IDF_TARGET_NAME} contains a hardware random number generator, values from it can be obtained using the APIs :cpp:func:`esp_random` and :cpp:func:`esp_fill_random`.
+
+The hardware RNG produces true random numbers under any of the following conditions:
+
+- RF subsystem is enabled (i.e. {IDF_TARGET_RF_NAME} {IDF_TARGET_RF_IS} enabled).
+- An internal entropy source has been enabled by calling :cpp:func:`bootloader_random_enable` and not yet disabled by calling :cpp:func:`bootloader_random_disable`.
+- While the ESP-IDF :ref:`second-stage-bootloader` is running. This is because the default ESP-IDF bootloader implementation calls :cpp:func:`bootloader_random_enable` when the bootloader starts, and :cpp:func:`bootloader_random_disable` before executing the app.
+
+When any of these conditions are true, samples of physical noise are continuously mixed into the internal hardware RNG state to provide entropy. Consult the  *{IDF_TARGET_NAME} Technical Reference Manual* > *Random Number Generator (RNG)* [`PDF <{IDF_TARGET_TRM_EN_URL}#rng>`__] chapter for more details.
+
+If none of the above conditions are true, the output of the RNG should be considered pseudo-random only.
+
+Startup
+-------
+
+During startup, ESP-IDF bootloader temporarily enables a non-RF entropy source (internal reference voltage noise) that provides entropy for any first boot key generation. However, after the app starts executing then normally only pseudo-random numbers are available until {IDF_TARGET_RF_NAME} {IDF_TARGET_RF_IS} initialized.
+
+To re-enable the entropy source temporarily during app startup, or for an application that does not use {IDF_TARGET_RF_NAME}, call the function :cpp:func:`bootloader_random_enable` to re-enable the internal entropy source. The function :cpp:func:`bootloader_random_disable` must be called to disable the entropy source again before using ADC, {IDF_TARGET_BOOTLOADER_RANDOM_INCOMPATIBLE}{IDF_TARGET_RF_NAME}.
+
+.. note::
+
+   The entropy source enabled during the boot process by the ESP-IDF Second Stage Bootloader will seed the internal RNG state with some entropy. However, the internal hardware RNG state is not large enough to provide a continuous stream of true random numbers. This is why a continuous entropy source must be enabled whenever true random numbers are required.
+
+.. note::
+
+   If an application requires a source of true random numbers but it is not possible to permanently enable a hardware entropy source, consider using a strong software DRBG implementation such as the mbedTLS CTR-DRBG or HMAC-DRBG, with an initial seed of entropy from hardware RNG true random numbers.
+
+.. only:: not esp32
+
+    Secondary Entropy
+    -----------------
+
+    {IDF_TARGET_NAME} RNG contains a secondary entropy source, based on sampling an asynchronous 8MHz internal oscillator (see the Technical Reference Manual for details). This entropy source is always enabled in ESP-IDF and continuously mixed into the RNG state by hardware. In testing, this secondary entropy source was sufficient to pass the `Dieharder`_ random number test suite without the main entropy source enabled (test input was created by concatenating short samples from a continuously resetting {IDF_TARGET_NAME}). However, it is currently only guaranteed that true random numbers will be produced when the main entropy source is also enabled as described above.
+
+API Reference
+-------------
+
+.. include-build-file:: inc/esp_random.inc
+.. include-build-file:: inc/bootloader_random.inc
+
+.. _Dieharder: https://webhome.phy.duke.edu/~rgb/General/dieharder.php
+
diff --git a/docs/en/api-reference/system/system.rst b/docs/en/api-reference/system/system.rst
index 5038f99dd5..194a401ea7 100644
--- a/docs/en/api-reference/system/system.rst
+++ b/docs/en/api-reference/system/system.rst
@@ -25,13 +25,6 @@ Two heap memory related functions are provided:
 
 Note that ESP-IDF supports multiple heaps with different capabilities. Functions mentioned in this section return the size of heap memory which can be allocated using ``malloc`` family of functions. For further information about heap memory see :doc:`Heap Memory Allocation <mem_alloc>`.
 
-Random number generation
-------------------------
-
-{IDF_TARGET_NAME} contains a hardware random number generator, values from it can be obtained using :cpp:func:`esp_random`.
-
-When Wi-Fi or Bluetooth are enabled, numbers returned by hardware random number generator (RNG) can be considered true random numbers. Without Wi-Fi or Bluetooth enabled, hardware RNG is a pseudo-random number generator. At startup, ESP-IDF bootloader seeds the hardware RNG with entropy, but care must be taken when reading random values between the start of ``app_main`` and initialization of Wi-Fi or Bluetooth drivers.
-
 .. _MAC-Address-Allocation:
 
 MAC Address
@@ -189,12 +182,9 @@ To set version in your project manually you need to set ``PROJECT_VER`` variable
 
 If :ref:`CONFIG_APP_PROJECT_VER_FROM_CONFIG` option is set, the value of :ref:`CONFIG_APP_PROJECT_VER` will be used. Otherwise if ``PROJECT_VER`` variable is not set in the project then it will be retrieved from either ``$(PROJECT_PATH)/version.txt`` file (if present) else using git command ``git describe``. If neither is available then ``PROJECT_VER`` will be set to "1". Application can make use of this by calling :cpp:func:`esp_ota_get_app_description` or :cpp:func:`esp_ota_get_partition_description` functions.
 
-
-
 API Reference
 -------------
 
 .. include-build-file:: inc/esp_system.inc
 .. include-build-file:: inc/esp_idf_version.inc
 
-
diff --git a/docs/zh_CN/api-guides/startup.rst b/docs/zh_CN/api-guides/startup.rst
index a8155d8737..58e4760197 100644
--- a/docs/zh_CN/api-guides/startup.rst
+++ b/docs/zh_CN/api-guides/startup.rst
@@ -2,13 +2,15 @@
 ===================
 :link_to_translation:`en:[English]`
 
+{IDF_TARGET_BOOTLOADER_OFFSET:default="0x0", esp32="0x1000", esp32s2="0x1000"}
+
 本文将会介绍 {IDF_TARGET_NAME} 从上电到运行 ``app_main``
 函数中间所经历的步骤（即启动流程）。
 
 宏观上，该启动流程可以分为如下 3 个步骤：
 
 1. 一级引导程序被固化在了 {IDF_TARGET_NAME} 内部的 ROM 中，它会从 Flash 的
-   ``0x1000`` 偏移地址处加载二级引导程序至 RAM(IRAM & DRAM) 中。
+   {IDF_TARGET_BOOTLOADER_OFFSET} 偏移地址处加载二级引导程序至 RAM(IRAM & DRAM) 中。
 
 2. 二级引导程序从 Flash 中加载分区表和主程序镜像至内存中，主程序中包含了
    RAM 段和通过 Flash 高速缓存映射的只读段。
@@ -53,20 +55,22 @@ SoC 复位后，PRO CPU 会立即开始运行，执行复位向量代码，而 A
    SoC，重复整个过程。如果解析器收到了来自 UART
    的输入，程序会关闭看门狗。
 
-应用程序的二进制镜像会从 Flash 的 ``0x1000`` 地址处加载。Flash 的第一个
+应用程序的二进制镜像会从 Flash 的 {IDF_TARGET_BOOTLOADER_OFFSET} 地址处加载。Flash 的第一个
 4kB
 扇区用于存储安全引导程序和应用程序镜像的签名。有关详细信息，请查看安全启动文档。
 
 .. TODO: describe application binary image format, describe optional flash configuration commands.
 
+.. _second-stage-bootloader:
+
 二级引导程序
 ~~~~~~~~~~~~
 
-在 ESP-IDF 中，存放在 Flash 的 ``0x1000``
+在 ESP-IDF 中，存放在 Flash 的 {IDF_TARGET_BOOTLOADER_OFFSET}
 偏移地址处的二进制镜像就是二级引导程序。二级引导程序的源码可以在 ESP-IDF
 的 components/bootloader 目录下找到。请注意，对于 {IDF_TARGET_NAME}
 芯片来说，这并不是唯一的安排程序镜像的方式。事实上用户完全可以把一个功能齐全的应用程序烧写到
-Flash 的 ``0x1000`` 偏移地址处运行，但这超出本文档的范围。ESP-IDF
+Flash 的 {IDF_TARGET_BOOTLOADER_OFFSET} 偏移地址处运行，但这超出本文档的范围。ESP-IDF
 使用二级引导程序可以增加 Flash 分区的灵活性（使用分区表），并且方便实现
 Flash 加密，安全引导和空中升级（OTA）等功能。
 
diff --git a/docs/zh_CN/api-reference/system/random.rst b/docs/zh_CN/api-reference/system/random.rst
new file mode 100644
index 0000000000..bcd4592e10
--- /dev/null
+++ b/docs/zh_CN/api-reference/system/random.rst
@@ -0,0 +1 @@
+.. include:: ../../../en/api-reference/system/random.rst
-- 
2.25.1


From 19a407ed1a41b6c5aa4220a255cf66c01ccc733e Mon Sep 17 00:00:00 2001
From: Wang Ning <wangning@espressif.com>
Date: Tue, 27 Apr 2021 16:16:00 +0800
Subject: [PATCH 25/43] 
 doc/remove_romconsole_since_it_is_no_longer_supported_from_ESP32_ECO3

---
 docs/en/api-guides/index.rst         |   1 -
 docs/en/api-guides/romconsole.rst    | 114 ---------------------------
 docs/zh_CN/api-guides/index.rst      |   1 -
 docs/zh_CN/api-guides/romconsole.rst |   1 -
 4 files changed, 117 deletions(-)
 delete mode 100644 docs/en/api-guides/romconsole.rst
 delete mode 100644 docs/zh_CN/api-guides/romconsole.rst

diff --git a/docs/en/api-guides/index.rst b/docs/en/api-guides/index.rst
index 07dce1e674..1e3403bac1 100644
--- a/docs/en/api-guides/index.rst
+++ b/docs/en/api-guides/index.rst
@@ -30,7 +30,6 @@ API Guides
     lwIP TCP/IP Stack <lwip>
     Partition Tables <partition-tables>
     :esp32: RF Calibration <RF_calibration>
-    :esp32: ROM debug console <romconsole>
     :esp32: Secure Boot <../security/secure-boot-v1>
     Secure Boot V2 <../security/secure-boot-v2>
     Thread Local Storage <thread-local-storage>
diff --git a/docs/en/api-guides/romconsole.rst b/docs/en/api-guides/romconsole.rst
deleted file mode 100644
index e34d8ca9db..0000000000
--- a/docs/en/api-guides/romconsole.rst
+++ /dev/null
@@ -1,114 +0,0 @@
-*****************************
-{IDF_TARGET_NAME} ROM console
-*****************************
-
-When an {IDF_TARGET_NAME} is unable to boot from flash ROM (and the fuse disabling it hasn't been blown), it boots into a rom console. The console
-is based on TinyBasic, and statements entered should be in the form of BASIC statements. As is common in the BASIC language, without a
-preceeding line number, commands entered are executed immediately; lines with a prefixed line number are stored as part of a program.
-
-Full list of supported statements and functions
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-System
-------
-
-- BYE		- *exits Basic, reboots and retries booting from flash*
-- END 		- *stops execution from the program, also "STOP"*
-- MEM		- *displays memory usage statistics*
-- NEW		- *clears the current program*
-- RUN		- *executes the current program*
-
-IO, Documentation
------------------
-
-- PEEK( address )	- *get a 32-bit value from a memory address*
-- POKE			- *write a 32-bit value to memory*
-- USR(addr, arg1, ..) - *Execute a machine language function*
-- PRINT expression	- *print out the expression, also "?"*
-- PHEX expression	- *print expression as a hex number*
-- REM stuff		- *remark/comment, also "'"*
-
-Expressions, Math
------------------
-
-- A=V, LET A=V	- *assign value to a variable*
-- +, -, \*, / - *Math*
-- <,<=,=,<>,!=,>=,> - *Comparisons*
-- ABS( expression )  - *returns the absolute value of the expression*
-- RSEED( v ) - *sets the random seed to v*
-- RND( m ) - *returns a random number from 0 to m*
-- A=1234 - * Assign a decimal value*
-- A=&h1A2 - * Assign a hex value*
-- A=&b1001 - *Assign a binary value*
-
-Control
--------
-
-- IF expression statement - *perform statement if expression is true*
-- FOR variable = start TO end	- *start for block*
-- FOR variable = start TO end STEP value - *start for block with step*
-- NEXT - *end of for block*
-- GOTO linenumber - *continue execution at this line number*
-- GOSUB linenumber - *call a subroutine at this line number*
-- RETURN	- *return from a subroutine*
-- DELAY		- *Delay a given number of milliseconds*
-
-Pin IO
-------
-- IODIR		- *Set a GPIO-pin as an output (1) or input (0)*
-- IOSET		- *Set a GPIO-pin, configured as output, to high (1) or low (0)*
-- IOGET		- *Get the value of a GPIO-pin*
-
-
-Example programs
-~~~~~~~~~~~~~~~~
-
-Here are a few example commands and programs to get you started...
-
-Read UART_DATE register of uart0
---------------------------------
-
-::
-
-	> PHEX PEEK(&h3FF40078)
-	15122500
-
-Set GPIO2 using memory writes to GPIO_OUT_REG
----------------------------------------------
-
-Note: you can do this easier with the IOSET command
-
-::
-
-	> POKE &h3FF44004,PEEK(&h3FF44004) OR &b100
-
-Get value of GPIO0
-------------------
-
-::
-
-	> IODIR 0,0
-	> PRINT IOGET(0)
-	0
-
-Blink LED
----------
-
-Hook up an LED between GPIO2 and ground. When running the program, the LED should blink 10 times.
-
-::
-
-	10 IODIR 2,1
-	20 FOR A=1 TO 10
-	30 IOSET 2,1
-	40 DELAY 250
-	50 IOSET 2,0
-	60 DELAY 250
-	70 NEXT A
-	RUN
-
-Credits
-~~~~~~~
-
-The ROM console is based on "TinyBasicPlus" by Mike Field and Scott Lawrence, which is based on "68000 TinyBasic" by Gordon Brandly
-
diff --git a/docs/zh_CN/api-guides/index.rst b/docs/zh_CN/api-guides/index.rst
index 1a25f4e3b9..490335b8be 100644
--- a/docs/zh_CN/api-guides/index.rst
+++ b/docs/zh_CN/api-guides/index.rst
@@ -30,7 +30,6 @@ API 指南
    Memory Types <memory-types>
    分区表 <partition-tables>
    :esp32: 射频校准 <RF_calibration>
-   :esp32: ROM 调试控制台 <romconsole>
    :esp32: 安全启动 <../security/secure-boot-v1>
    安全启动 V2 <../security/secure-boot-v2>
    线程本地存储 <thread-local-storage>
diff --git a/docs/zh_CN/api-guides/romconsole.rst b/docs/zh_CN/api-guides/romconsole.rst
deleted file mode 100644
index 59791099eb..0000000000
--- a/docs/zh_CN/api-guides/romconsole.rst
+++ /dev/null
@@ -1 +0,0 @@
-.. include:: ../../en/api-guides/romconsole.rst
\ No newline at end of file
-- 
2.25.1


From 53c18a85db104bb37ebeadec2faf5d42d764d0f9 Mon Sep 17 00:00:00 2001
From: Suren Gabrielyan <suren.gabrielyan@espressif.com>
Date: Sun, 18 Apr 2021 16:55:37 +0400
Subject: [PATCH 26/43] Docs: Added README.md for lwip fuzzer tests

Closes IDFCI-540
---
 components/lwip/test_afl_host/README.md      | 77 ++++++++++++++++++++
 components/mdns/test_afl_fuzz_host/README.md | 35 +++++++--
 2 files changed, 104 insertions(+), 8 deletions(-)
 create mode 100644 components/lwip/test_afl_host/README.md

diff --git a/components/lwip/test_afl_host/README.md b/components/lwip/test_afl_host/README.md
new file mode 100644
index 0000000000..e392eef99b
--- /dev/null
+++ b/components/lwip/test_afl_host/README.md
@@ -0,0 +1,77 @@
+## Introduction
+This test uses [american fuzzy lop](http://lcamtuf.coredump.cx/afl/) to mangle real dns, dhcp client, dhcp server packets and look for exceptions caused by the parser.
+
+A few actual packets are collected and exported as bins in the ```in_dns, in_dhcp_client, in_dhcp_server``` folders, which is then passed as input to AFL when testing. The setup procedure for the test includes all possible services and scenarios that could be used with the given input packets. The output of the parser before fuzzing can be found in [input_packets.txt](input_packets.txt)
+
+## Building and running the tests using AFL
+To build and run the tests using AFL(afl-clang-fast) instrumentation
+
+```bash
+cd $IDF_PATH/components/lwip/test_afl_host
+make fuzz MODE=dns/dhcp_client/dhcp_server
+```
+
+(Please note you have to install AFL instrumentation first, check `Installing AFL` section)
+
+## Building the tests using GCC INSTR(off)
+To build the tests without AFL instrumentations and instead of that use GCC compiler(In this case it will only check for compilation issues and will not run AFL tests).
+
+```bash
+cd $IDF_PATH/components/lwip/test_afl_host
+make INSTR=off MODE=dns/dhcp_client/dhcp_server
+```
+
+## Installing AFL
+To run the test yourself, you need to download the [latest afl archive](http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz) and extract it to a folder on your computer.
+
+The rest of the document will refer to that folder as ```PATH_TO_AFL```.
+
+### Preparation
+- On Mac, you will need to install the latest Xcode and llvm support from [Homebrew](https://brew.sh)
+
+    ```bash
+    /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
+    brew install --with-clang --with-lld --HEAD llvm
+    export PATH="/usr/local/opt/llvm/bin:$PATH"
+    ```
+
+- On Ubuntu you need the following packages:
+    
+    ```bash
+    sudo apt-get install make clang-4.0(or <=4.0) llvm-4.0(or <=4.0) libbsd-dev
+    ```
+
+Please note that if specified package version can't be installed(becouse the system is newer than 2017), you can install it from source.
+
+### Compile AFL
+Compiling AFL is as easy as running make:
+
+```bash
+cd [PATH_TO_AFL]
+make
+cd llvm_mode/
+make
+```
+
+After successful compilation, you can export the following variables to your shell (you can also add them to your profile if you want to use AFL in other projects).
+
+```bash
+export AFL_PATH=[PATH_TO_AFL]
+export PATH="$AFL_PATH:$PATH"
+```
+
+Please note LLVM must be <=4.0.0, otherwise afl does not compile, as there are some limitations with building AFL on MacOS/Linux with the latest LLVM. Also, Windows build on cygwin is not fully supported.
+
+## Additional info
+Apple has a crash reporting service that could interfere with AFL's normal operation. To turn that off, run the following command:
+
+```bash
+launchctl unload -w /System/Library/LaunchAgents/com.apple.ReportCrash.plist
+sudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.ReportCrash.Root.plist
+```
+
+Ubuntu has a similar service. To turn that off, run as root:
+
+```bash
+echo core >/proc/sys/kernel/core_pattern
+```
diff --git a/components/mdns/test_afl_fuzz_host/README.md b/components/mdns/test_afl_fuzz_host/README.md
index 7d78bab554..4a9e68200a 100644
--- a/components/mdns/test_afl_fuzz_host/README.md
+++ b/components/mdns/test_afl_fuzz_host/README.md
@@ -1,7 +1,25 @@
 ## Introduction
 This test uses [american fuzzy lop](http://lcamtuf.coredump.cx/afl/) to mangle real mdns packets and look for exceptions caused by the parser.
 
-A few actuall packets are collected and exported as bins in the ```in``` folder, which is then passed as input to AFL when testing. The setup procedure for the test includes all possible services and scenarios that could be used with the given input packets. Output of the parser before fuzzing can be found in [input_packets.txt](input_packets.txt)
+A few actual packets are collected and exported as bins in the ```in``` folder, which is then passed as input to AFL when testing. The setup procedure for the test includes all possible services and scenarios that could be used with the given input packets.The output of the parser before fuzzing can be found in [input_packets.txt](input_packets.txt)
+
+## Building and running the tests using AFL
+To build and run the tests using AFL(afl-clang-fast) instrumentation
+
+```bash
+cd $IDF_PATH/components/mdns/test_afl_host
+make fuzz
+```
+
+(Please note you have to install AFL instrumentation first, check `Installing AFL` section)
+
+## Building the tests using GCC INSTR(off)
+To build the tests without AFL instrumentations and instead of that use GCC compiler(In this case it will only check for compilation issues and will not run AFL tests).
+
+```bash
+cd $IDF_PATH/components/mdns/test_afl_host
+make INSTR=off
+```
 
 ## Installing AFL
 To run the test yourself, you need to dounload the [latest afl archive](http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz) and extract it to a folder on your computer.
@@ -9,7 +27,7 @@ To run the test yourself, you need to dounload the [latest afl archive](http://l
 The rest of the document will refer to that folder as ```PATH_TO_AFL```.
 
 ### Preparation
-- On Mac, you will need to insall the latest Xcode and llvm support from [Homebrew](https://brew.sh)
+- On Mac, you will need to install the latest Xcode and llvm support from [Homebrew](https://brew.sh)
 
     ```bash
     /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
@@ -20,9 +38,11 @@ The rest of the document will refer to that folder as ```PATH_TO_AFL```.
 - On Ubuntu you need the following packages:
     
     ```bash
-    sudo apt-get install make clang llvm libbsd-dev
+    sudo apt-get install make clang-4.0(or <=4.0) llvm-4.0(or <=4.0) libbsd-dev
     ```
 
+Please note that if specified package version can't be installed(due to system is the latest), you can download, build and install it manually.
+
 ### Compile AFL
 Compiling AFL is as easy as running make:
 
@@ -33,14 +53,16 @@ cd llvm_mode/
 make
 ```
 
-After successful compilation, you can export the following variables to your shell (you can also add them to your profile if you want to use afl in other projects)
+After successful compilation, you can export the following variables to your shell (you can also add them to your profile if you want to use AFL in other projects).
 
 ```bash
 export AFL_PATH=[PATH_TO_AFL]
 export PATH="$AFL_PATH:$PATH"
 ```
 
-## Running the test
+Please note LLVM must be <=4.0.0, otherwise afl does not compile, as there are some limitations with building AFL on MacOS/Linux with the latest LLVM. Also, Windows build on cygwin is not fully supported.
+
+## Additional info
 Apple has a crash reporting service that could interfere with AFLs normal operation. To turn that off, run the following command:
 
 ```bash
@@ -53,6 +75,3 @@ Ubuntu has a similar service. To turn that off, run as root:
 ```bash
 echo core >/proc/sys/kernel/core_pattern
 ```
-
-After going through all of the requirements above, you can ```cd``` into this test's folder and simply run ```make fuzz```.
-
-- 
2.25.1


From 611ecc619bace1fba2b6348f19970574bad10a28 Mon Sep 17 00:00:00 2001
From: daiziyan <daiziyan@madcowdeMacBook-Air-3.local>
Date: Wed, 19 May 2021 16:25:27 +0800
Subject: [PATCH 27/43] docs:translate chip series comparison table and update
 adc_types.h

---
 components/hal/include/hal/adc_types.h        |   6 +-
 .../hw-reference/chip-series-comparison.rst   |  16 +-
 .../hw-reference/chip-series-comparison.rst   | 250 +++++++++++++++++-
 docs/zh_CN/hw-reference/index.rst             |   2 +-
 4 files changed, 268 insertions(+), 6 deletions(-)

diff --git a/components/hal/include/hal/adc_types.h b/components/hal/include/hal/adc_types.h
index be0f3c67c8..b70d0948b3 100644
--- a/components/hal/include/hal/adc_types.h
+++ b/components/hal/include/hal/adc_types.h
@@ -56,9 +56,9 @@ typedef enum {
  */
 typedef enum {
     ADC_ATTEN_DB_0   = 0,  /*!<No input attenumation, ADC can measure up to approx. 800 mV. */
-    ADC_ATTEN_DB_2_5 = 1,  /*!<The input voltage of ADC will be attenuated, extending the range of measurement to up to approx. 1100 mV. */
-    ADC_ATTEN_DB_6   = 2,  /*!<The input voltage of ADC will be attenuated, extending the range of measurement to up to  approx. 1350 mV. */
-    ADC_ATTEN_DB_11  = 3,  /*!<The input voltage of ADC will be attenuated, extending the range of measurement to up to  approx. 2600 mV. */
+    ADC_ATTEN_DB_2_5 = 1,  /*!<The input voltage of ADC will be attenuated extending the range of measurement by about 2.5 dB (1.33 x) */
+    ADC_ATTEN_DB_6   = 2,  /*!<The input voltage of ADC will be attenuated extending the range of measurement by about 6 dB (2 x) */
+    ADC_ATTEN_DB_11  = 3,  /*!<The input voltage of ADC will be attenuated extending the range of measurement by about 11 dB (3.55 x) */
     ADC_ATTEN_MAX,
 } adc_atten_t;
 
diff --git a/docs/en/hw-reference/chip-series-comparison.rst b/docs/en/hw-reference/chip-series-comparison.rst
index db55f395e8..39a2ae56b9 100644
--- a/docs/en/hw-reference/chip-series-comparison.rst
+++ b/docs/en/hw-reference/chip-series-comparison.rst
@@ -2,6 +2,8 @@
 Chip Series Comparison
 ***********************
 
+:link_to_translation:`zh_CN:[中文]`
+
 The comparison below covers key features of chips supported by ESP-IDF. For the full list of features please refer to respective datasheets in Section `Related Documents`_.
 
 .. list-table:: Chip Series Comparison
@@ -71,7 +73,11 @@ The comparison below covers key features of chips supported by ESP-IDF. For the
    * - DAC
      - Two 8-bit channels
      - Two 8-bit channels
-     - ✖️       
+     - ✖️ 
+   * - Timers
+     - Four 64-bit general-purpose timers, and three watchdog timers
+     - Four 64-bit general-purpose timers, and three watchdog timers
+     - Two 54-bit general-purpose timers, and three watchdog timers       
    * - Temperature sensor
      - ✖️
      - 1
@@ -128,6 +134,10 @@ The comparison below covers key features of chips supported by ESP-IDF. For the
      - 16 channels
      - 8 channels :sup:`1`
      - 6 channels :sup:`2`
+   * - MCPWM
+     - 2, six PWM outputs
+     - ✖️ 
+     - ✖️ 
    * - USB OTG
      - ✖️
      - 1
@@ -215,11 +225,15 @@ The comparison below covers key features of chips supported by ESP-IDF. For the
 
 **Note** 1: Reduced chip area compared with ESP32
 
+
 **Note** 2: Reduced chip area compared with ESP32 and ESP32-S2
 
+
 **Note** 3: Die size: ESP32-C3 < ESP32-S2 < ESP32
 
 
+
+
 Related Documents
 =================
 
diff --git a/docs/zh_CN/hw-reference/chip-series-comparison.rst b/docs/zh_CN/hw-reference/chip-series-comparison.rst
index 61f6ca3d5d..7fac5e0cfa 100644
--- a/docs/zh_CN/hw-reference/chip-series-comparison.rst
+++ b/docs/zh_CN/hw-reference/chip-series-comparison.rst
@@ -1 +1,249 @@
-.. include:: ../../en/hw-reference/chip-series-comparison.rst
+***********************
+芯片系列对比
+***********************
+
+:link_to_translation:`en: [English]`
+
+下表对比了 ESP-IDF 各系列芯片的主要特性，如需了解更多信息，请参考 `相关文档`_ 中各系列芯片的技术规格书。
+
+.. list-table:: 芯片系列对比
+   :widths: 20 40 40 40
+   :header-rows: 1
+
+   * - 特性
+     - ESP32 系列
+     - ESP32-S2 系列
+     - ESP32-C3 系列
+   * - 发布时间
+     - 2016
+     - 2020
+     - 2020
+   * - 产品型号
+     - 请参考 `ESP32 技术规格书 (PDF) <https://espressif.com/sites/default/files/documentation/esp32_datasheet_cn.pdf>`_
+     - 请参考 `ESP32-S2 技术规格书 (PDF) <https://www.espressif.com/sites/default/files/documentation/esp32-s2_datasheet_cn.pdf>`_
+     - 请参考 `ESP32-C3 技术规格书 (PDF) <https://www.espressif.com/sites/default/files/documentation/esp32-c3_datasheet_cn.pdf>`_
+   * - 内核
+     - 搭载低功耗 Xtensa® LX6 32 位双核处理器，处理速度总共高达 600 MIPS，其中 ESP32-U4WDH/ESP32-S0WD（单核）处理速度可达 200 MIPS，ESP32-D2WD 可达 400 MIPS。
+     - 搭载低功耗 Xtensa® LX7 32 位单核处理器，处理速度高达 300 MIPS
+     - 搭载 RISC-V 32 位单核处理器
+   * - Wi-Fi 协议
+     - 802.11 b/g/n、2.4 GHz
+     - 802.11 b/g/n、2.4 GHz
+     - 802.11 b/g/n、2.4 GHz
+   * - Bluetooth®
+     - Bluetooth v4.2 BR/EDR 和 Bluetooth Low Energy
+     - ✖️
+     - Bluetooth 5.0
+   * - 主频
+     - 240 MHz（ESP32-S0WD、ESP32-D2WD 和 ESP32-U4WDH 为 160 MHz）
+     - 240 MHz
+     - 160 MHz
+   * - SRAM
+     - 520 KB
+     - 320 KB
+     - 400 KB
+   * - ROM
+     - 448 KB 用于程序启动和内核功能调用
+     - 128 KB 用于程序启动和内核功能调用
+     - 384 KB 用于程序启动和内核功能调用
+   * - 嵌入式 flash
+     - 2 MB、4 MB 或无嵌入式 flash，不同型号有差异
+     - 2 MB、4 MB 或无嵌入式 flash，不同型号有差异
+     - 4 MB 或无嵌入式 flash，不同型号有差异
+   * - 外部 flash
+     - 最大支持 16 MB，一次最多可映射 11 MB + 248 KB
+     - 最大支持 1 GB，一次最多可映射 11.5 MB
+     - 最大支持 16 MB，一次最多可映射 8 MB
+   * - 片外 RAM
+     - 最大支持 8 MB，一次最多可映射 4 MB
+     - 最大支持 1 GB，一次最多可映射 11.5 MB
+     - ✖️
+   * - Cache
+     - ✔️ 2 路组相联
+     - ✔️ 4 路组相联，独立的指令和数据 cache
+     - ✔️ 8 路组相连，32 位数据/指令总线宽度
+   * - **外设**
+     - 
+     -
+     - 
+   * - 模/数转换器 (ADC)
+     - 两个 12 位 SAR ADC，多达 18 个通道
+     - 两个 13 位 SAR ADC，多达 18 个通道
+     - 两个 12 位 SAR ADC，最多支持 6 个通道
+   * - 数/模转换器 (DAC)
+     - 两个 8 位通道
+     - 两个 8 位通道
+     - ✖️ 
+   * - 定时器
+     - 4 个 64 位通用定时器，3 个看门狗定时器
+     - 4 个 64 位通用定时器，3 个看门狗定时器
+     - 2 个 54 位通用定时器，3 个看门狗定时器     
+   * - 温度传感器
+     - ✖️
+     - 1
+     - 1
+   * - 触摸传感器
+     - 10
+     - 14
+     - ✖️
+   * - 霍尔传感器
+     - 1
+     - ✖️
+     - ✖️
+   * - 通用输入/输出接口 (GPIO)
+     - 34
+     - 43
+     - 22
+   * - 串行外设接口 (SPI)
+     - 4
+     - 4 个 SPI，比 ESP32 支持更多模式
+     - 3
+   * - LCD 接口
+     - 1
+     - 1
+     - ✖️
+   * - 通用异步收发器 (UART)
+     - 3
+     - 2 [#one]_
+     - 2 [#one]_
+   * - I2C 接口
+     - 2
+     - 2
+     - 1
+   * - I2S 接口
+     - 2 个，可配置为 8/16/32/40/48 位的输入输出通道
+     - 1 个，可配置为 8/16/24/32/48/64 位的输入输出通道
+     - 1 个，可配置为 8/16/24/32 位的输入输出通道
+   * - Camera 接口
+     - 1
+     - 1
+     - ✖️
+   * - DMA
+     - UART、SPI、I2S、SDIO 从机、SD/MMC 主机、EMAC、BT 和 Wi-Fi 都有专用的 DMA 控制器 
+     - UART、SPI、AES、SHA、I2S 和 ADC 控制器都有专用的 DMA 控制器
+     - 通用 DMA 控制器，3 个接收通道和 3 个发送通道
+   * - 红外遥控器 (RMT)
+     - 支持 8 通道
+     - 支持 4 通道 [#one]_，可配置为红外发射和接收
+     - 支持 4 通道 [#two]_，双通道的红外发射和双通道的红外接收
+   * - 脉冲计数器
+     - 8 通道
+     - 4 通道 [#one]_
+     - ✖️
+   * - LED PWM
+     - 16 通道
+     - 8 通道 [#one]_
+     - 6 通道 [#two]_
+   * - MCPWM
+     - 2，提供六个 PWM 输出
+     - ✖️ 
+     - ✖️ 
+   * - USB OTG
+     - ✖️
+     - 1
+     - ✖️           
+   * - TWAI® 控制器（兼容 ISO 11898-1 协议）
+     - 1
+     - 1
+     - 1
+   * - SD/SDIO/MMC 主机控制器
+     - 1
+     - ✖️
+     - ✖️
+   * - SDIO 从机控制器
+     - 1
+     - ✖️
+     - ✖️
+   * - 以太网 MAC 接口
+     - 1
+     - ✖️
+     - ✖️
+   * - 超低功耗协处理器 (ULP)
+     - ULP FSM
+     - PicoRV32 内核，8 KB SRAM，ULP FSM 支持更多指令
+     - ✖️
+   * - 辅助调试
+     - ✖️
+     - ✖️
+     - 1
+   * - **安全机制**
+     - 
+     -
+     - 
+   * - 安全启动
+     - ✔️
+     - ✔️ 比 ESP32 更快更安全
+     - ✔️ 比 ESP32 更快更安全
+   * - Flash 加密
+     - ✔️
+     - ✔️ 支持 PSRAM 加密，比 ESP32 更安全
+     - ✔️ 比 ESP32 更安全
+   * - OTP
+     - 1024 位
+     - 4096 位
+     - 4096 位
+   * - AES
+     - ✔️ AES-128, AES-192, AES-256 (FIPS PUB 197)
+     - ✔️ AES-128, AES-192, AES-256 (FIPS PUB 197)
+     - ✔️ AES-128, AES-256 (FIPS PUB 197)
+   * - HASH
+     - SHA-1, SHA-256, SHA-384, SHA-512 (FIPS PUB 180-4)
+     - SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256, SHA-512/t (FIPS PUB 180-4); 支持 DMA 
+     - SHA-1, SHA-224, SHA-256 (FIPS PUB 180-4)
+   * - RSA
+     - 高达 4096 位
+     - 高达 4096 位，与 ESP32 相比，改善了加速选项
+     - 高达 3072 位
+   * - 随机数生成器 (RNG)
+     - ✔️
+     - ✔️
+     - ✔️
+   * - HMAC
+     - ✖️
+     - ✔️
+     - ✔️
+   * - 数字签名
+     - ✖️
+     - ✔️
+     - ✔️
+   * - XTS
+     - ✖️
+     - ✔️ XTS-AES-128, XTS-AES-256
+     - ✔️ XTS-AES-128
+   * - **其它**
+     - 
+     -
+     - 
+   * - Deep-sleep 功耗（超低功耗传感器监测方式）
+     - 100 μA（ADC 以 1% 占空比工作时）
+     - 22 μA（触摸传感器以 1% 占空比工作时）
+     - 无此模式
+   * - 封装尺寸
+     - QFN48 5*5、6*6，不同型号有差异
+     - QFN56 7*7 
+     - QFN32 5*5
+
+.. note::
+
+    .. [#one] 与 ESP32 相比，减小了芯片面积 
+
+    .. [#two] 与 ESP32 和 ESP32-S2 相比，减小了芯片面积  
+
+.. note::
+
+    芯片大小 (die size)：ESP32-C3 < ESP32-S2 < ESP32
+
+
+相关文档
+=================
+
+- `ESP32 技术规格书 (PDF) <https://espressif.com/sites/default/files/documentation/esp32_datasheet_cn.pdf>`_
+- ESP32-PICO 技术规格书 (PDF)
+
+    - `ESP32-PICO-D4 <https://www.espressif.com/sites/default/files/documentation/esp32-pico-d4_datasheet_cn.pdf>`_
+    - `ESP32-PICO-V3 <https://www.espressif.com/sites/default/files/documentation/esp32-pico-v3_datasheet_cn.pdf>`_
+    - `ESP32-PICO-V3-02 <https://www.espressif.com/sites/default/files/documentation/esp32-pico-v3-02_datasheet_cn.pdf>`_
+
+- `ESP32-S2 技术规格书 (PDF) <https://www.espressif.com/sites/default/files/documentation/esp32-s2_datasheet_cn.pdf>`_
+- `ESP32-C3 技术规格书 (PDF) <https://www.espressif.com/sites/default/files/documentation/esp32-c3_datasheet_cn.pdf>`_
+- `ESP 产品选型 <http://products.espressif.com:8000/#/>`_
\ No newline at end of file
diff --git a/docs/zh_CN/hw-reference/index.rst b/docs/zh_CN/hw-reference/index.rst
index 034e5d77d9..9ef8e7cd44 100644
--- a/docs/zh_CN/hw-reference/index.rst
+++ b/docs/zh_CN/hw-reference/index.rst
@@ -15,4 +15,4 @@
     模组与开发板（历史版本）<modules-and-boards-previous>
     乐鑫产品订购信息 (PDF) <http://www.espressif.com/sites/default/files/documentation/espressif_products_ordering_information_cn.pdf>
     乐鑫产品证书 <https://www.espressif.com/zh-hans/certificates>
-    Chip Series Comparison <chip-series-comparison>
+    芯片系列对比 <chip-series-comparison>
-- 
2.25.1


From eecf70efd0e1ec2f000b60a1149a0b4796b47c36 Mon Sep 17 00:00:00 2001
From: Angus Gratton <angus@espressif.com>
Date: Thu, 20 May 2021 09:51:29 +1000
Subject: [PATCH 28/43] partition: Replace strlcpy() with strncpy()

Regression in ede477ea652 for host tests only - ESP-IDF supports
strlcpy() but strlcpy & strlcat are currently no-ops in the host
tests (to avoid libbsd dependency).
---
 components/spi_flash/partition.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/components/spi_flash/partition.c b/components/spi_flash/partition.c
index 39675a5da5..506afc6caa 100644
--- a/components/spi_flash/partition.c
+++ b/components/spi_flash/partition.c
@@ -235,8 +235,8 @@ static esp_err_t load_partitions(void)
             item->info.encrypted = true;
         }
 
-        // note: if label in flash is not null terminated, one byte will be truncated here
-        strlcpy(item->info.label, (const char*) entry.label, sizeof(item->info.label));
+        // item->info.label is initialized by calloc, so resulting string will be null terminated
+        strncpy(item->info.label, (const char*) entry.label, sizeof(item->info.label) - 1);
 
         // add it to the list
         if (last == NULL) {
-- 
2.25.1


From 430486678034b4cb50c4301ec31a0d6bb1001be2 Mon Sep 17 00:00:00 2001
From: Fu Hanxi <fuhanxi@espressif.com>
Date: Thu, 20 May 2021 12:18:36 +0800
Subject: [PATCH 29/43] ci: shorter performance test log

---
 tools/ci/python_packages/ttfw_idf/IDFDUT.py | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/tools/ci/python_packages/ttfw_idf/IDFDUT.py b/tools/ci/python_packages/ttfw_idf/IDFDUT.py
index 98a68bc4e3..27996d40b0 100644
--- a/tools/ci/python_packages/ttfw_idf/IDFDUT.py
+++ b/tools/ci/python_packages/ttfw_idf/IDFDUT.py
@@ -33,7 +33,6 @@ except ImportError:
 
 from serial.tools import list_ports
 from tiny_test_fw import DUT, Utility
-from tiny_test_fw.Utility import format_case_id
 
 try:
     import esptool
@@ -72,8 +71,7 @@ class IDFRecvThread(DUT.RecvThread):
     def collect_performance(self, comp_data):
         matches = self.PERFORMANCE_PATTERN.findall(comp_data)
         for match in matches:
-            Utility.console_log('[Performance][{}]: {}'.format(format_case_id(match[0], self.dut.app.target, self.dut.app.config_name), match[1]),
-                                color='orange')
+            Utility.console_log('[Performance][{}]: {}'.format(match[0], match[1]), color='orange')
             self.performance_items.put((match[0], match[1]))
 
     def detect_exception(self, comp_data):
-- 
2.25.1


From bccaab7e6cbbcf3219120df04b8b7276b70f8733 Mon Sep 17 00:00:00 2001
From: Fu Hanxi <fuhanxi@espressif.com>
Date: Thu, 20 May 2021 14:13:49 +0800
Subject: [PATCH 30/43] fix(ci): fix missing [Performance] prefix in junit
 report

---
 tools/ci/python_packages/tiny_test_fw/TinyFW.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/tools/ci/python_packages/tiny_test_fw/TinyFW.py b/tools/ci/python_packages/tiny_test_fw/TinyFW.py
index 6825dd8f69..0c5ba32605 100644
--- a/tools/ci/python_packages/tiny_test_fw/TinyFW.py
+++ b/tools/ci/python_packages/tiny_test_fw/TinyFW.py
@@ -149,7 +149,7 @@ class JunitReport(object):
         assert cls.JUNIT_CURRENT_TEST_CASE
 
         for item in performance_items:
-            cls.JUNIT_CURRENT_TEST_CASE.stdout += '[{}]: {}\n'.format(item[0], item[1])
+            cls.JUNIT_CURRENT_TEST_CASE.stdout += '[Performance][{}]: {}\n'.format(item[0], item[1])
 
 
 def test_method(**kwargs):
-- 
2.25.1


From 5c812742c68d6564061ab195e1e8bc157c0f815a Mon Sep 17 00:00:00 2001
From: Angus Gratton <angus@espressif.com>
Date: Thu, 20 May 2021 17:08:17 +1000
Subject: [PATCH 31/43] docs: Add description for Linux getrandom() function

---
 components/esp_hw_support/include/esp_random.h |  3 ++-
 docs/en/api-reference/system/random.rst        | 17 +++++++++++++++++
 2 files changed, 19 insertions(+), 1 deletion(-)

diff --git a/components/esp_hw_support/include/esp_random.h b/components/esp_hw_support/include/esp_random.h
index 3b939ef132..cf4f408b51 100644
--- a/components/esp_hw_support/include/esp_random.h
+++ b/components/esp_hw_support/include/esp_random.h
@@ -29,7 +29,8 @@ extern "C" {
  * Guide "Random Number Generation" section for necessary prerequisites.
  *
  * This function automatically busy-waits to ensure enough external entropy has been
- * introduced into the hardware RNG state, before returning a new random number.
+ * introduced into the hardware RNG state, before returning a new random number. This delay
+ * is very short (always less than 100 CPU cycles).
  *
  * @return Random value between 0 and UINT32_MAX
  */
diff --git a/docs/en/api-reference/system/random.rst b/docs/en/api-reference/system/random.rst
index a25f65946f..da4cb1e321 100644
--- a/docs/en/api-reference/system/random.rst
+++ b/docs/en/api-reference/system/random.rst
@@ -45,5 +45,22 @@ API Reference
 .. include-build-file:: inc/esp_random.inc
 .. include-build-file:: inc/bootloader_random.inc
 
+getrandom
+---------
+
+A compatible version of the Linux ``getrandom()`` function is also provided for ease of porting:
+
+.. code-block:: c
+
+   #include <sys/random.h>
+
+   ssize_t getrandom(void *buf, size_t buflen, unsigned int flags);
+
+This function is implemented by calling :cpp:func:`esp_fill_random` internally.
+
+The ``flags`` argument is ignored, this function is always non-blocking but the strength of any random numbers is dependent on the same conditions described above.
+
+Return value is -1 (with ``errno`` set to ``EFAULT``) if the ``buf`` argument is NULL, and equal to ``buflen`` otherwise.
+
 .. _Dieharder: https://webhome.phy.duke.edu/~rgb/General/dieharder.php
 
-- 
2.25.1


From 8434c0c731ec7cf8b4ddf7472c8611cf2f0b156e Mon Sep 17 00:00:00 2001
From: He Yin Ling <heyinling@espressif.com>
Date: Thu, 20 May 2021 14:32:18 +0800
Subject: [PATCH 32/43] ttfw: fix DUT exception not added to junit report

---
 tools/ci/python_packages/tiny_test_fw/TinyFW.py | 2 +-
 tools/ci/python_packages/ttfw_idf/IDFDUT.py     | 3 +--
 2 files changed, 2 insertions(+), 3 deletions(-)

diff --git a/tools/ci/python_packages/tiny_test_fw/TinyFW.py b/tools/ci/python_packages/tiny_test_fw/TinyFW.py
index 6825dd8f69..bada70fc04 100644
--- a/tools/ci/python_packages/tiny_test_fw/TinyFW.py
+++ b/tools/ci/python_packages/tiny_test_fw/TinyFW.py
@@ -222,7 +222,7 @@ def test_method(**kwargs):
                 # and raise exception in DUT close to fail test case if reset detected.
                 if close_errors:
                     for error in close_errors:
-                        junit_test_case.add_failure_info(str(error))
+                        junit_test_case.add_failure_info('env close error: {}'.format(error))
                     result = False
                 if not case_info['junit_report_by_case'] or unexpected_error:
                     JunitReport.test_case_finish(junit_test_case)
diff --git a/tools/ci/python_packages/ttfw_idf/IDFDUT.py b/tools/ci/python_packages/ttfw_idf/IDFDUT.py
index 98a68bc4e3..8ab58ce417 100644
--- a/tools/ci/python_packages/ttfw_idf/IDFDUT.py
+++ b/tools/ci/python_packages/ttfw_idf/IDFDUT.py
@@ -506,8 +506,7 @@ class IDFDUT(DUT.SerialDUT):
     def close(self):
         super(IDFDUT, self).close()
         if not self.allow_dut_exception and self.get_exceptions():
-            Utility.console_log('DUT exception detected on {}'.format(self), color='red')
-            raise IDFDUTException()
+            raise IDFDUTException('DUT exception detected on {}'.format(self))
 
 
 class ESP32DUT(IDFDUT):
-- 
2.25.1


From 8cc4cd775ecf0f43796f1ef850d036c25df26df7 Mon Sep 17 00:00:00 2001
From: He Yin Ling <heyinling@espressif.com>
Date: Wed, 12 May 2021 10:16:20 +0800
Subject: [PATCH 33/43] test: support multiple targets for iperf example test

---
 examples/wifi/iperf/iperf_test.py   | 30 +++++++++++++----------------
 examples/wifi/iperf/sdkconfig.ci.99 | 30 -----------------------------
 2 files changed, 13 insertions(+), 47 deletions(-)

diff --git a/examples/wifi/iperf/iperf_test.py b/examples/wifi/iperf/iperf_test.py
index 9ac638dc73..2aad6ebd7b 100644
--- a/examples/wifi/iperf/iperf_test.py
+++ b/examples/wifi/iperf/iperf_test.py
@@ -524,7 +524,7 @@ class IperfTestUtilitySoftap(IperfTestUtility):
         return server_raw_data, rssi, heap_size
 
 
-@ttfw_idf.idf_example_test(env_tag='Example_ShieldBox_Basic', category='stress')
+@ttfw_idf.idf_example_test(env_tag='Example_ShieldBox_Basic', target=['ESP32', 'ESP32S2', 'ESP32C3'], category='stress')
 def test_wifi_throughput_with_different_configs(env, extra_data):
     """
     steps: |
@@ -552,8 +552,7 @@ def test_wifi_throughput_with_different_configs(env, extra_data):
                                                     'sdkconfig.ci.{}'.format(config_name))
 
         # 2. get DUT and download
-        dut = env.get_dut('iperf', 'examples/wifi/iperf', dut_class=ttfw_idf.ESP32DUT,
-                          app_config_name=config_name)
+        dut = env.get_dut('iperf', 'examples/wifi/iperf', app_config_name=config_name)
         dut.start_app()
         dut.expect_any('iperf>', 'esp32>')
 
@@ -585,7 +584,7 @@ def test_wifi_throughput_with_different_configs(env, extra_data):
     report.generate_report()
 
 
-@ttfw_idf.idf_example_test(env_tag='Example_ShieldBox', category='stress')
+@ttfw_idf.idf_example_test(env_tag='Example_ShieldBox', target=['ESP32', 'ESP32S2', 'ESP32C3'], category='stress')
 def test_wifi_throughput_vs_rssi(env, extra_data):
     """
     steps: |
@@ -608,8 +607,7 @@ def test_wifi_throughput_vs_rssi(env, extra_data):
     }
 
     # 1. get DUT and download
-    dut = env.get_dut('iperf', 'examples/wifi/iperf', dut_class=ttfw_idf.ESP32DUT,
-                      app_config_name=BEST_PERFORMANCE_CONFIG)
+    dut = env.get_dut('iperf', 'examples/wifi/iperf', app_config_name=BEST_PERFORMANCE_CONFIG)
     dut.start_app()
     dut.expect_any('iperf>', 'esp32>')
 
@@ -640,7 +638,8 @@ def test_wifi_throughput_vs_rssi(env, extra_data):
     report.generate_report()
 
 
-@ttfw_idf.idf_example_test(env_tag='Example_ShieldBox_Basic')
+@ttfw_idf.idf_example_test(env_tag='Example_ShieldBox_Basic',
+                           target=['ESP32', 'ESP32S2', 'ESP32C3'], ci_target=['ESP32'])
 def test_wifi_throughput_basic(env, extra_data):
     """
     steps: |
@@ -655,8 +654,7 @@ def test_wifi_throughput_basic(env, extra_data):
     }
 
     # 1. get DUT
-    dut = env.get_dut('iperf', 'examples/wifi/iperf', dut_class=ttfw_idf.ESP32DUT,
-                      app_config_name=BEST_PERFORMANCE_CONFIG)
+    dut = env.get_dut('iperf', 'examples/wifi/iperf', app_config_name=BEST_PERFORMANCE_CONFIG)
     dut.start_app()
     dut.expect_any('iperf>', 'esp32>')
 
@@ -693,7 +691,7 @@ def test_wifi_throughput_basic(env, extra_data):
     env.close_dut('iperf')
 
 
-@ttfw_idf.idf_example_test(env_tag='Example_ShieldBox2', category='stress')
+@ttfw_idf.idf_example_test(env_tag='Example_ShieldBox2', target=['ESP32', 'ESP32S2', 'ESP32C3'], category='stress')
 def test_softap_throughput_vs_rssi(env, extra_data):
     """
     steps: |
@@ -712,13 +710,11 @@ def test_softap_throughput_vs_rssi(env, extra_data):
     }
 
     # 1. get DUT and download
-    softap_dut = env.get_dut('softap_iperf', 'examples/wifi/iperf', dut_class=ttfw_idf.ESP32DUT,
-                             app_config_name=BEST_PERFORMANCE_CONFIG)
+    softap_dut = env.get_dut('softap_iperf', 'examples/wifi/iperf')
     softap_dut.start_app()
     softap_dut.expect_any('iperf>', 'esp32>')
 
-    sta_dut = env.get_dut('sta_iperf', 'examples/wifi/iperf', dut_class=ttfw_idf.ESP32DUT,
-                          app_config_name=BEST_PERFORMANCE_CONFIG)
+    sta_dut = env.get_dut('sta_iperf', 'examples/wifi/iperf', app_config_name=BEST_PERFORMANCE_CONFIG)
     sta_dut.start_app()
     sta_dut.expect_any('iperf>', 'esp32>')
 
@@ -741,7 +737,7 @@ def test_softap_throughput_vs_rssi(env, extra_data):
 
 
 if __name__ == '__main__':
-    test_wifi_throughput_basic(env_config_file='EnvConfig.yml')
-    test_wifi_throughput_with_different_configs(env_config_file='EnvConfig.yml')
-    test_wifi_throughput_vs_rssi(env_config_file='EnvConfig.yml')
+    # test_wifi_throughput_basic(env_config_file='EnvConfig.yml')
+    # test_wifi_throughput_with_different_configs(env_config_file='EnvConfig.yml')
+    test_wifi_throughput_vs_rssi(env_config_file='EnvConfig.yml', target='ESP32C3')
     test_softap_throughput_vs_rssi(env_config_file='EnvConfig.yml')
diff --git a/examples/wifi/iperf/sdkconfig.ci.99 b/examples/wifi/iperf/sdkconfig.ci.99
index 52c69eb3da..e69de29bb2 100644
--- a/examples/wifi/iperf/sdkconfig.ci.99
+++ b/examples/wifi/iperf/sdkconfig.ci.99
@@ -1,30 +0,0 @@
-CONFIG_ESP32_DEFAULT_CPU_FREQ_240=y
-CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ=240
-CONFIG_MEMMAP_SMP=y
-
-CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE=4096
-
-CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM=16
-CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM=64
-CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER_NUM=64
-CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED=y
-CONFIG_ESP32_WIFI_TX_BA_WIN=32
-CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED=y
-CONFIG_ESP32_WIFI_RX_BA_WIN=32
-
-CONFIG_FREERTOS_UNICORE=n
-CONFIG_FREERTOS_HZ=1000
-
-CONFIG_ESP_INT_WDT=n
-CONFIG_ESP_TASK_WDT=n
-
-CONFIG_LWIP_TCP_SND_BUF_DEFAULT=65534
-CONFIG_LWIP_TCP_WND_DEFAULT=65534
-CONFIG_LWIP_TCP_RECVMBOX_SIZE=64
-CONFIG_LWIP_UDP_RECVMBOX_SIZE=64
-CONFIG_LWIP_TCPIP_RECVMBOX_SIZE=64
-CONFIG_LWIP_ETHARP_TRUST_IP_MAC=n
-
-CONFIG_ESPTOOLPY_FLASHMODE_QIO=y
-CONFIG_ESPTOOLPY_FLASHFREQ_80M=y
-CONFIG_LWIP_IRAM_OPTIMIZATION=y
-- 
2.25.1


From 016a37c8ad57db5221777c0fbeef1fe9ba1bac03 Mon Sep 17 00:00:00 2001
From: He Yin Ling <heyinling@espressif.com>
Date: Thu, 13 May 2021 16:26:08 +0800
Subject: [PATCH 34/43] ci: save built binaries could be tested locally:

we have some test cases not executed in CI. we need to save those
binaries as artifacts so we can test locally.
---
 tools/ci/mypy_ignore_list.txt                 |  1 -
 .../python_packages/ttfw_idf/CIScanTests.py   | 33 ++++++++++++++-----
 2 files changed, 24 insertions(+), 10 deletions(-)

diff --git a/tools/ci/mypy_ignore_list.txt b/tools/ci/mypy_ignore_list.txt
index 06eecb9cdd..0bfbbe2e9d 100644
--- a/tools/ci/mypy_ignore_list.txt
+++ b/tools/ci/mypy_ignore_list.txt
@@ -190,7 +190,6 @@ tools/ci/python_packages/tiny_test_fw/Utility/TestCase.py
 tools/ci/python_packages/tiny_test_fw/bin/Runner.py
 tools/ci/python_packages/tiny_test_fw/bin/example.py
 tools/ci/python_packages/tiny_test_fw/docs/conf.py
-tools/ci/python_packages/ttfw_idf/CIScanTests.py
 tools/ci/python_packages/ttfw_idf/DebugUtils.py
 tools/ci/python_packages/ttfw_idf/IDFApp.py
 tools/ci/python_packages/ttfw_idf/IDFAssignTest.py
diff --git a/tools/ci/python_packages/ttfw_idf/CIScanTests.py b/tools/ci/python_packages/ttfw_idf/CIScanTests.py
index ed66fc88ad..c1b38f89bb 100644
--- a/tools/ci/python_packages/ttfw_idf/CIScanTests.py
+++ b/tools/ci/python_packages/ttfw_idf/CIScanTests.py
@@ -6,6 +6,11 @@ import os
 from collections import defaultdict
 from copy import deepcopy
 
+try:
+    from typing import Any
+except ImportError:
+    # Only used for type annotations
+    pass
 from find_apps import find_apps
 from find_build_apps import BUILD_SYSTEM_CMAKE, BUILD_SYSTEMS
 from idf_py_actions.constants import PREVIEW_TARGETS, SUPPORTED_TARGETS
@@ -28,14 +33,14 @@ BUILD_ALL_LABELS = [
 ]
 
 
-def _has_build_all_label():
+def _has_build_all_label():  # type: () -> bool
     for label in BUILD_ALL_LABELS:
         if os.getenv(label):
             return True
     return False
 
 
-def _judge_build_or_not(action, build_all):  # type: (str, bool) -> (bool, bool)
+def _judge_build_or_not(action, build_all):  # type: (str, bool) -> tuple[bool, bool]
     """
     :return: (build_or_not_for_test_related_apps, build_or_not_for_non_related_apps)
     """
@@ -45,7 +50,7 @@ def _judge_build_or_not(action, build_all):  # type: (str, bool) -> (bool, bool)
 
     labels = TEST_LABELS[action]
     if not isinstance(labels, list):
-        labels = [labels]
+        labels = [labels]  # type: ignore
 
     for label in labels:
         if os.getenv(label):
@@ -55,13 +60,23 @@ def _judge_build_or_not(action, build_all):  # type: (str, bool) -> (bool, bool)
     return False, False
 
 
-def output_json(apps_dict_list, target, build_system, output_dir):
+def output_json(apps_dict_list, target, build_system, output_dir):  # type: (list, str, str, str) -> None
     output_path = os.path.join(output_dir, 'scan_{}_{}.json'.format(target.lower(), build_system))
     with open(output_path, 'w') as fw:
         fw.writelines([json.dumps(app) + '\n' for app in apps_dict_list])
 
 
-def main():
+# we might need artifacts to run test cases locally.
+# So we need to save artifacts which have test case not executed by CI.
+class _ExampleAssignTest(ExampleAssignTest):
+    DEFAULT_FILTER = {}  # type: dict[str, Any]
+
+
+class _TestAppsAssignTest(TestAppsAssignTest):
+    DEFAULT_FILTER = {}  # type: dict[str, Any]
+
+
+def main():  # type: () -> None
     parser = argparse.ArgumentParser(description='Scan the required build tests')
     parser.add_argument('test_type',
                         choices=TEST_LABELS.keys(),
@@ -101,14 +116,14 @@ def main():
             output_json([], target, args.build_system, args.output_path)
             SystemExit(0)
 
-    paths = set([os.path.join(os.getenv('IDF_PATH'), path) if not os.path.isabs(path) else path for path in args.paths])
+    paths = set([os.path.join(str(os.getenv('IDF_PATH')), path) if not os.path.isabs(path) else path for path in args.paths])
 
     test_cases = []
     for path in paths:
         if args.test_type == 'example_test':
-            assign = ExampleAssignTest(path, args.ci_config_file)
+            assign = _ExampleAssignTest(path, args.ci_config_file)
         elif args.test_type in ['test_apps', 'component_ut']:
-            assign = TestAppsAssignTest(path, args.ci_config_file)
+            assign = _TestAppsAssignTest(path, args.ci_config_file)
         else:
             raise SystemExit(1)  # which is impossible
 
@@ -123,7 +138,7 @@ def main():
         ...
     }
     '''
-    scan_info_dict = defaultdict(dict)
+    scan_info_dict = defaultdict(dict)  # type: dict[str, dict]
     # store the test cases dir, exclude these folders when scan for standalone apps
     default_exclude = args.exclude if args.exclude else []
 
-- 
2.25.1


From 7256cfe5a46731dfdb9d773c91d528ad35807d77 Mon Sep 17 00:00:00 2001
From: yuanjm <yuanjianmin@espressif.com>
Date: Mon, 26 Apr 2021 10:56:01 +0800
Subject: [PATCH 35/43] ppp: Fix disable IPv6 will make esp_netif_lwip_ppp
 build fail

Closes https://github.com/espressif/esp-idf/issues/6935
---
 components/esp_netif/lwip/esp_netif_lwip_ppp.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/components/esp_netif/lwip/esp_netif_lwip_ppp.c b/components/esp_netif/lwip/esp_netif_lwip_ppp.c
index 6513862481..2527795310 100644
--- a/components/esp_netif/lwip/esp_netif_lwip_ppp.c
+++ b/components/esp_netif/lwip/esp_netif_lwip_ppp.c
@@ -73,17 +73,17 @@ static void on_ppp_status_changed(ppp_pcb *pcb, int err_code, void *ctx)
                 ip4_addr_set(&ip_info->netmask, ip_2_ip4(&pppif->netmask));
                 ip4_addr_set(&ip_info->gw, ip_2_ip4(&pppif->gw));
 
-                evt.ip_info.ip.addr = pppif->ip_addr.u_addr.ip4.addr;
-                evt.ip_info.gw.addr = pppif->gw.u_addr.ip4.addr;
-                evt.ip_info.netmask.addr = pppif->netmask.u_addr.ip4.addr;
+                ip4_addr_set(&evt.ip_info.ip, ip_2_ip4(&pppif->ip_addr));
+                ip4_addr_set(&evt.ip_info.gw, ip_2_ip4(&pppif->gw));
+                ip4_addr_set(&evt.ip_info.netmask, ip_2_ip4(&pppif->netmask));
 
                 dest_ip = dns_getserver(0);
                 if(dest_ip != NULL){
-                    ns1.addr = (*dest_ip).u_addr.ip4.addr;
+                    ip4_addr_set(&ns1, ip_2_ip4(dest_ip));
                 }
                 dest_ip = dns_getserver(1);
                 if(dest_ip != NULL){
-                    ns2.addr = (*dest_ip).u_addr.ip4.addr;
+                    ip4_addr_set(&ns2, ip_2_ip4(dest_ip));
                 }
                 ESP_LOGI(TAG, "Name Server1: " IPSTR, IP2STR(&ns1));
                 ESP_LOGI(TAG, "Name Server2: " IPSTR, IP2STR(&ns2));
-- 
2.25.1


From e305f2938278c2a39e75c21a3ed59d8f4d4e62fa Mon Sep 17 00:00:00 2001
From: Angus Gratton <angus@espressif.com>
Date: Thu, 20 May 2021 18:50:02 +1000
Subject: [PATCH 36/43] asio coap: If LWIP IPV6 is disabled, automatically
 don't build asio & coap

- Removes need to manually exclude these components as shown at
  https://github.com/espressif/esp-idf/issues/3781#issuecomment-825742378

- Hide the config for these components if IPV6 is disabled

- The components are still included in the build, but with no source
  files
---
 components/asio/CMakeLists.txt                       | 8 ++++++++
 components/asio/Kconfig                              | 2 ++
 components/asio/component.mk                         | 4 ++++
 components/coap/CMakeLists.txt                       | 8 ++++++++
 components/coap/Kconfig                              | 1 +
 components/coap/component.mk                         | 4 ++++
 components/lwip/Kconfig                              | 5 ++---
 examples/protocols/sockets/tcp_server/CMakeLists.txt | 1 -
 examples/protocols/sockets/tcp_server/Makefile       | 1 -
 9 files changed, 29 insertions(+), 5 deletions(-)

diff --git a/components/asio/CMakeLists.txt b/components/asio/CMakeLists.txt
index c088644f94..e2421fead4 100644
--- a/components/asio/CMakeLists.txt
+++ b/components/asio/CMakeLists.txt
@@ -1,3 +1,11 @@
+if(NOT CONFIG_LWIP_IPV6 AND NOT CMAKE_BUILD_EARLY_EXPANSION)
+    # note: the component is still included in the build so it can become visible again in config
+    # without needing to re-run CMake. However no source or header files are built.
+    message(STATUS "IPV6 support is disabled so the asio component will not be built")
+    idf_component_register()
+    return()
+endif()
+
 set(asio_sources "asio/asio/src/asio.cpp")
 
 if(CONFIG_ASIO_SSL_SUPPORT)
diff --git a/components/asio/Kconfig b/components/asio/Kconfig
index 582410e7ce..3b488a0c3b 100644
--- a/components/asio/Kconfig
+++ b/components/asio/Kconfig
@@ -1,4 +1,6 @@
 menu "ESP-ASIO"
+    visible if LWIP_IPV6
+
     config ASIO_SSL_SUPPORT
         bool "Enable SSL/TLS support of ASIO"
         default n
diff --git a/components/asio/component.mk b/components/asio/component.mk
index 30b2907bbb..c93c8dbb97 100644
--- a/components/asio/component.mk
+++ b/components/asio/component.mk
@@ -1,3 +1,5 @@
+ifdef CONFIG_LWIP_IPV6
+
 COMPONENT_ADD_INCLUDEDIRS := asio/asio/include port/include
 COMPONENT_PRIV_INCLUDEDIRS := private_include
 COMPONENT_SRCDIRS := asio/asio/src port/src
@@ -7,3 +9,5 @@ COMPONENT_OBJEXCLUDE := asio/asio/src/asio_ssl.o port/src/esp_asio_openssl_stubs
 endif
 
 COMPONENT_SUBMODULES += asio
+
+endif # CONFIG_LWIP_IPV6
diff --git a/components/coap/CMakeLists.txt b/components/coap/CMakeLists.txt
index a3dccee5c0..2c3b57e1a2 100644
--- a/components/coap/CMakeLists.txt
+++ b/components/coap/CMakeLists.txt
@@ -1,3 +1,11 @@
+if(NOT CONFIG_LWIP_IPV6 AND NOT CMAKE_BUILD_EARLY_EXPANSION)
+    message(STATUS "IPV6 support is disabled so the coap component will not be built")
+    # note: the component is still included in the build so it can become visible again in config
+    # without needing to re-run CMake. However no source or header files are built.
+    idf_component_register()
+    return()
+endif()
+
 set(include_dirs port/include port/include/coap libcoap/include libcoap/include/coap2)
 
 set(srcs
diff --git a/components/coap/Kconfig b/components/coap/Kconfig
index 2e56938937..a5d613e146 100644
--- a/components/coap/Kconfig
+++ b/components/coap/Kconfig
@@ -1,4 +1,5 @@
 menu "CoAP Configuration"
+    visible if LWIP_IPV6
 
     choice COAP_MBEDTLS_ENCRYPTION_MODE
         prompt "CoAP Encryption method"
diff --git a/components/coap/component.mk b/components/coap/component.mk
index 448a94f6cb..eeec323f0c 100644
--- a/components/coap/component.mk
+++ b/components/coap/component.mk
@@ -2,6 +2,8 @@
 # Component Makefile
 #
 
+ifdef CONFIG_LWIP_IPV6
+
 COMPONENT_ADD_INCLUDEDIRS := port/include port/include/coap libcoap/include libcoap/include/coap2
 
 COMPONENT_OBJS = libcoap/src/address.o libcoap/src/async.o libcoap/src/block.o libcoap/src/coap_event.o libcoap/src/coap_hashkey.o libcoap/src/coap_session.o libcoap/src/coap_time.o port/coap_debug.o libcoap/src/encode.o libcoap/src/mem.o libcoap/src/net.o libcoap/src/option.o libcoap/src/pdu.o libcoap/src/resource.o libcoap/src/str.o libcoap/src/subscribe.o libcoap/src/uri.o port/coap_mbedtls.o libcoap/src/coap_io.o port/coap_notls.o
@@ -12,3 +14,5 @@ COMPONENT_SUBMODULES += libcoap
 
 # Silence format truncation warning, until it is fixed upstream
 port/coap_debug.o: CFLAGS += -Wno-format-truncation
+
+endif  # CONFIG_LWIP_IPV6
diff --git a/components/lwip/Kconfig b/components/lwip/Kconfig
index 714e1a828e..95d61693d1 100644
--- a/components/lwip/Kconfig
+++ b/components/lwip/Kconfig
@@ -324,9 +324,8 @@ menu "LWIP"
         default y
         help
             Enable IPv6 function. If not use IPv6 function, set this option to n.
-            If disable LWIP_IPV6, not adding coap and asio component into the build.
-            Please assign them to EXCLUDE_COMPONENTS in the make or cmake file in your
-            project directory, so that the component will not be compiled.
+            If disabling LWIP_IPV6 then some other components (coap and asio) will
+            no longer be available.
 
     config LWIP_IPV6_AUTOCONFIG
         bool "Enable IPV6 stateless address autoconfiguration (SLAAC)"
diff --git a/examples/protocols/sockets/tcp_server/CMakeLists.txt b/examples/protocols/sockets/tcp_server/CMakeLists.txt
index 5761720556..9865464bd8 100644
--- a/examples/protocols/sockets/tcp_server/CMakeLists.txt
+++ b/examples/protocols/sockets/tcp_server/CMakeLists.txt
@@ -5,7 +5,6 @@ cmake_minimum_required(VERSION 3.5)
 # (Not part of the boilerplate)
 # This example uses an extra component for common functions such as Wi-Fi and Ethernet connection.
 set(EXTRA_COMPONENT_DIRS $ENV{IDF_PATH}/examples/common_components/protocol_examples_common)
-set(EXCLUDE_COMPONENTS "coap" "asio")
 
 include($ENV{IDF_PATH}/tools/cmake/project.cmake)
 project(tcp_server)
diff --git a/examples/protocols/sockets/tcp_server/Makefile b/examples/protocols/sockets/tcp_server/Makefile
index 344b8aa424..318e78a775 100644
--- a/examples/protocols/sockets/tcp_server/Makefile
+++ b/examples/protocols/sockets/tcp_server/Makefile
@@ -6,6 +6,5 @@
 PROJECT_NAME := tcp_server
 
 EXTRA_COMPONENT_DIRS = $(IDF_PATH)/examples/common_components/protocol_examples_common
-EXCLUDE_COMPONENTS = coap asio
 
 include $(IDF_PATH)/make/project.mk
-- 
2.25.1


From 71141a326d079649c89fb9a2a1185b5c0e1d7a25 Mon Sep 17 00:00:00 2001
From: Wang Fang <wangfang@espressif.com>
Date: Tue, 11 May 2021 17:49:31 +0800
Subject: [PATCH 37/43] docs: clarified esp32 timer clk source, updated the
 flash encryption table and esptrace doc

---
 docs/en/api-guides/app_trace.rst              |  2 +-
 docs/en/api-reference/peripherals/timer.rst   | 14 +++---
 docs/en/security/flash-encryption.rst         | 45 +++----------------
 docs/zh_CN/api-guides/app_trace.rst           | 18 ++++----
 .../zh_CN/api-reference/peripherals/timer.rst | 14 +++---
 5 files changed, 33 insertions(+), 60 deletions(-)

diff --git a/docs/en/api-guides/app_trace.rst b/docs/en/api-guides/app_trace.rst
index 1a97c984ca..7dc56daa9c 100644
--- a/docs/en/api-guides/app_trace.rst
+++ b/docs/en/api-guides/app_trace.rst
@@ -393,7 +393,7 @@ Command usage examples:
 
         esp sysview start file://pro-cpu.SVDat file://app-cpu.SVDat
 
-    The tracing data will be retrieved and saved in non-blocking mode. To stop data this process enter ``esp apptrace stop`` command on OpenOCD telnet prompt, optionally pressing Ctrl+C in OpenOCD window.
+    The tracing data will be retrieved and saved in non-blocking mode. To stop data this process enter ``esp sysview stop`` command on OpenOCD telnet prompt, optionally pressing Ctrl+C in OpenOCD window.
 
 2.  Retrieve tracing data and save them indefinitely.
 
diff --git a/docs/en/api-reference/peripherals/timer.rst b/docs/en/api-reference/peripherals/timer.rst
index 6e259f9551..b10ed6b19d 100644
--- a/docs/en/api-reference/peripherals/timer.rst
+++ b/docs/en/api-reference/peripherals/timer.rst
@@ -31,12 +31,14 @@ The two {IDF_TARGET_NAME} timer groups, with two timers in each, provide the tot
 
 First of all, the timer should be initialized by calling the function :cpp:func:`timer_init` and passing a structure :cpp:type:`timer_config_t` to it to define how the timer should operate. In particular, the following timer parameters can be set:
 
-    * **Clock Source**: Select the clock source, which together with the **Divider** define the resolution of the working timer. By default the clock source is APB_CLK (typically 80 MHz).
-    * **Divider**: Sets how quickly the timer's counter is "ticking". The setting :cpp:member:`divider` is used as a divisor of the clock source.
-    * **Mode**: Sets if the counter should be incrementing or decrementing. It can be defined using :cpp:member:`counter_dir` by selecting one of the values from :cpp:type:`timer_count_dir_t`.
-    * **Counter Enable**: If the counter is enabled, it will start incrementing / decrementing immediately after calling :cpp:func:`timer_init`. You can change the behavior with :cpp:member:`counter_en` by selecting one of the values from :cpp:type:`timer_start_t`.
-    * **Alarm Enable**: Can be set using :cpp:member:`alarm_en`.
-    * **Auto Reload**: Sets if the counter should :cpp:member:`auto_reload` the initial counter value on the timer's alarm or continue incrementing or decrementing.
+.. list::
+
+    :not esp32: - **Clock Source**: Select the clock source, which together with the **Divider** define the resolution of the working timer. By default the clock source is APB_CLK (typically 80 MHz).    
+    - **Divider**: Sets how quickly the timer's counter is "ticking". The setting :cpp:member:`divider` is used as a divisor of the clock source.
+    - **Mode**: Sets if the counter should be incrementing or decrementing. It can be defined using :cpp:member:`counter_dir` by selecting one of the values from :cpp:type:`timer_count_dir_t`.
+    - **Counter Enable**: If the counter is enabled, it will start incrementing / decrementing immediately after calling :cpp:func:`timer_init`. You can change the behavior with :cpp:member:`counter_en` by selecting one of the values from :cpp:type:`timer_start_t`.
+    - **Alarm Enable**: Can be set using :cpp:member:`alarm_en`.
+    - **Auto Reload**: Sets if the counter should :cpp:member:`auto_reload` the initial counter value on the timer's alarm or continue incrementing or decrementing.
 
 To get the current values of the timer's settings, use the function :cpp:func:`timer_get_config`.
 
diff --git a/docs/en/security/flash-encryption.rst b/docs/en/security/flash-encryption.rst
index 266059596e..f04e1712f7 100644
--- a/docs/en/security/flash-encryption.rst
+++ b/docs/en/security/flash-encryption.rst
@@ -45,117 +45,86 @@ Other types of data can be encrypted conditionally:
 Relevant eFuses
 ---------------
 
-The flash encryption operation is controlled by various eFuses available on {IDF_TARGET_NAME}. The list of eFuses and their descriptions is given in the table below. The names in eFuse column are also used by espefuse.py tool. For usage in the eFuse API, modify the name by adding ``ESP_EFUSE_``, for example: esp_efuse_read_field_bit(ESP_EFUSE_**DISABLE_DL_ENCRYPT**).
+The flash encryption operation is controlled by various eFuses available on {IDF_TARGET_NAME}. The list of eFuses and their descriptions is given in the table below. The names in eFuse column are also used by espefuse.py tool. For usage in the eFuse API, modify the name by adding ``ESP_EFUSE_``, for example: esp_efuse_read_field_bit(ESP_EFUSE_DISABLE_DL_ENCRYPT).
 
 .. Comment: As text in cells of list-table header rows does not wrap, it is necessary to make 0 header rows and apply bold typeface to the first row. Otherwise, the table goes beyond the html page limits on the right.
 
 .. only:: esp32
 
     .. list-table:: eFuses Used in Flash Encryption
-       :widths: 25 40 10 15 10
+       :widths: 25 40 10
        :header-rows: 0
 
        * - **eFuse**
          - **Description**
          - **Bit Depth**
-         - **R/W Access Control Available**
-         - **Default Value**
        * - ``CODING_SCHEME``
          - Controls actual number of block1 bits used to derive final 256-bit AES key. Possible values: ``0`` for 256 bits, ``1`` for 192 bits, ``2`` for 128 bits. Final AES key is derived based on the ``FLASH_CRYPT_CONFIG`` value.
          - 2
-         - Yes
-         - 0
        * - ``flash_encryption`` (block1)
          - AES key storage.
          - 256
-         - Yes
-         - x
        * - ``FLASH_CRYPT_CONFIG``
          - Controls the AES encryption process.
          - 4
-         - Yes
-         - 0xF
        * - ``DISABLE_DL_ENCRYPT``
          - If set, disables flash encryption operation while running in Firmware Download mode.
          - 1
-         - Yes
-         - 0
        * - ``DISABLE_DL_DECRYPT``
          - If set, disables flash decryption while running in UART Firmware Download mode.
          - 1
-         - Yes
-         - 0
        * - ``{IDF_TARGET_CRYPT_CNT}``
          - Enables/disables encryption at boot time. If even number of bits set (0, 2, 4, 6) - encrypt flash at boot time. If odd number of bits set (1, 3, 5, 7) - do not encrypt flash at boot time.
          - 7
-         - Yes
-         - 0
 
 
 .. only:: esp32s2
 
     .. list-table:: eFuses Used in Flash Encryption
-       :widths: 25 40 10 15 10
+       :widths: 25 40 10
        :header-rows: 0
 
        * - **eFuse**
          - **Description**
          - **Bit Depth**
-         - **R/W Access Control Available**
-         - **Default Value**
        * - ``BLOCK_KEYN``
          - AES key storage. N is between 0 and 5.
          - 256
-         - Yes
-         - x
        * - ``KEY_PURPOSE_N``
          - Controls the purpose of eFuse block ``BLOCK_KEYN``, where N is between 0 and 5. Possible values: ``2`` for ``XTS_AES_256_KEY_1`` , ``3`` for ``XTS_AES_256_KEY_2``, and ``4`` for ``XTS_AES_128_KEY``. Final AES key is derived based on the value of one or two of these purpose eFuses. For a detailed description of the possible combinations, see *{IDF_TARGET_NAME} Technical Reference Manual* > *External Memory Encryption and Decryption (XTS_AES)* [`PDF <{IDF_TARGET_TRM_EN_URL}#extmemencr>`__].
          - 4
-         - Yes
-         - 0
        * - ``DIS_DOWNLOAD_MANUAL_ENCRYPT``
          - If set, disables flash encryption when in download bootmodes.
          - 1
-         - Yes
-         - 0
        * - ``{IDF_TARGET_CRYPT_CNT}``
          - Enables encryption and decryption, when an SPI boot mode is set. Feature is enabled if 1 or 3 bits are set in the eFuse, disabled otherwise.
          - 3
-         - Yes
-         - 0
 
 .. only:: esp32c3
 
     .. list-table:: eFuses Used in Flash Encryption
-       :widths: 25 40 10 15 10
+       :widths: 25 40 10
        :header-rows: 0
 
        * - **eFuse**
          - **Description**
          - **Bit Depth**
-         - **R/W Access Control Available**
-         - **Default Value**
        * - ``BLOCK_KEYN``
          - AES key storage. N is between 0 and 5.
          - 256
-         - Yes
-         - x
        * - ``KEY_PURPOSE_N``
          - Controls the purpose of eFuse block ``BLOCK_KEYN``, where N is between 0 and 5. For flash encryption the only valid value is ``4`` for ``XTS_AES_128_KEY``.
          - 4
-         - Yes
-         - 0
        * - ``DIS_DOWNLOAD_MANUAL_ENCRYPT``
          - If set, disables flash encryption when in download bootmodes.
          - 1
-         - Yes
-         - 0
        * - ``{IDF_TARGET_CRYPT_CNT}``
          - Enables encryption and decryption, when an SPI boot mode is set. Feature is enabled if 1 or 3 bits are set in the eFuse, disabled otherwise.
          - 3
-         - Yes
-         - 0
 
+.. note::
+  * R/W access control is available for all the eFuse bits listed in the table above.
+  * The default value of these bits is 0 afer manufacturing.
 
 Read and write access to eFuse bits is controlled by appropriate fields in the registers ``WR_DIS`` and ``RD_DIS``. For more information on {IDF_TARGET_NAME} eFuses, see :doc:`eFuse manager <../api-reference/system/efuse>`. To change protection bits of eFuse field using espefuse.py, use these two commands: read_protect_efuse and write_protect_efuse. Example ``espefuse.py write_protect_efuse DISABLE_DL_ENCRYPT``.
 
diff --git a/docs/zh_CN/api-guides/app_trace.rst b/docs/zh_CN/api-guides/app_trace.rst
index 254ce63cbb..0629950f86 100644
--- a/docs/zh_CN/api-guides/app_trace.rst
+++ b/docs/zh_CN/api-guides/app_trace.rst
@@ -172,7 +172,7 @@ OpenOCD 应用程序跟踪命令
 
 命令用法：
 
-``esp32 apptrace [start <options>] | [stop] | [status] | [dump <cores_num> <outfile>]``
+``esp apptrace [start <options>] | [stop] | [status] | [dump <cores_num> <outfile>]``
 
 子命令：
 
@@ -215,7 +215,7 @@ Start 子命令的语法：
 
 	::
 
-		esp32 apptrace start file://trace.log 1 2048 5 0 0
+		esp apptrace start file://trace.log 1 2048 5 0 0
 
     	跟踪数据会被检索并以非阻塞的模式保存到文件中，如果收集满 2048 字节的数据或者在 5 秒内都没有新的数据，那么该过程就会停止。
 
@@ -227,15 +227,15 @@ Start 子命令的语法：
 
 	::
 
-		esp32 apptrace start file://trace.log 1 -1 -1 0 0
+		esp apptrace start file://trace.log 1 -1 -1 0 0
 
-    	对收集数据的大小没有限制，并且没有设置任何超时时间。可以通过在 OpenOCD 的 telnet 会话窗口中发送 ``esp32 apptrace stop`` 命令，或者在 OpenOCD 窗口中使用快捷键 Ctrl+C 来停止此过程。
+    	对收集数据的大小没有限制，并且没有设置任何超时时间。可以通过在 OpenOCD 的 telnet 会话窗口中发送 ``esp apptrace stop`` 命令，或者在 OpenOCD 窗口中使用快捷键 Ctrl+C 来停止此过程。
 
 3. 	检索跟踪数据并无限期保存。
 
 	::
 
-		esp32 apptrace start file://trace.log 0 -1 -1 0 0
+		esp apptrace start file://trace.log 0 -1 -1 0 0
 
     	在跟踪停止之前，OpenOCD 的 telnet 会话窗口将不可用。要停止跟踪，请在 OpenOCD 的窗口中使用快捷键 Ctrl+C。
 
@@ -243,7 +243,7 @@ Start 子命令的语法：
 
 	::
 
-		esp32 apptrace start file://trace.log 0 2048 -1 1 0
+		esp apptrace start file://trace.log 0 2048 -1 1 0
 
     	想要复位后立即开始跟踪，请使用 OpenOCD 的 ``reset halt`` 命令。
 
@@ -353,7 +353,7 @@ OpenOCD SystemView 跟踪命令选项
 
 命令用法：
 
-``esp32 sysview [start <options>] | [stop] | [status]``
+``esp sysview [start <options>] | [stop] | [status]``
 
 子命令：
 
@@ -391,9 +391,9 @@ Start 子命令语法：
 
 	::
 
-		esp32 sysview start file://pro-cpu.SVDat file://app-cpu.SVDat
+		esp sysview start file://pro-cpu.SVDat file://app-cpu.SVDat
 
-	跟踪数据被检索并以非阻塞的方式保存，要停止此过程，需要在 OpenOCD 的 telnet 会话窗口输入 ``esp32 apptrace stop`` 命令，或者也可以在 OpenOCD 窗口中按下 Ctrl+C。
+	跟踪数据被检索并以非阻塞的方式保存，要停止此过程，需要在 OpenOCD 的 telnet 会话窗口输入 ``esp sysview stop`` 命令，或者也可以在 OpenOCD 窗口中按下 Ctrl+C。
 
 2.	检索跟踪数据并无限保存。
 
diff --git a/docs/zh_CN/api-reference/peripherals/timer.rst b/docs/zh_CN/api-reference/peripherals/timer.rst
index f303f649b0..8f8622556f 100644
--- a/docs/zh_CN/api-reference/peripherals/timer.rst
+++ b/docs/zh_CN/api-reference/peripherals/timer.rst
@@ -31,12 +31,14 @@
 
 首先调用 :cpp:func:`timer_init` 函数，并将 :cpp:type:`timer_config_t` 结构体传递给此函数，用于定义定时器的工作方式，实现定时器初始化。特别注意以下定时器参数可设置为：
 
-    * **时钟源**: 选择时钟源，它同时钟分频器一起决定了定时器的分辨率。默认的时钟源是 APB_CLK (一般是 80 MHz)。
-    * **分频器**: 设置定时器中计数器计数的速度，:cpp:member:`divider` 的设置将用作输入时钟源的除数。
-    * **模式**: 设置计数器是递增还是递减。可通过从 :cpp:type:`timer_count_dir_t` 中选取一个值，后使用 :cpp:member:`counter_dir` 来选择模式。
-    * **计数器使能**: 如果计数器已使能，则在调用 :cpp:func:`timer_init` 后计数器将立即开始递增/递减。您可通过从 :cpp:type:`timer_start_t` 中选取一个值，后使用 :cpp:member:`counter_en` 改变此行为。
-    * **报警使能**: 可使用 :cpp:member:`alarm_en` 设置。
-    * **自动重载**: 设置计数器是否应该在定时器警报上使用 :cpp:member:`auto_reload` 自动重载首个计数值，还是继续递增或递减。
+.. list::
+
+    :not esp32: - **时钟源**: 选择时钟源，它同时钟分频器一起决定了定时器的分辨率。默认的时钟源是 APB_CLK (一般是 80 MHz)。
+    - **分频器**: 设置定时器中计数器计数的速度，:cpp:member:`divider` 的设置将用作输入时钟源的除数。
+    - **模式**: 设置计数器是递增还是递减。可通过从 :cpp:type:`timer_count_dir_t` 中选取一个值，后使用 :cpp:member:`counter_dir` 来选择模式。
+    - **计数器使能**: 如果计数器已使能，则在调用 :cpp:func:`timer_init` 后计数器将立即开始递增/递减。您可通过从 :cpp:type:`timer_start_t` 中选取一个值，后使用 :cpp:member:`counter_en` 改变此行为。
+    - **报警使能**: 可使用 :cpp:member:`alarm_en` 设置。
+    - **自动重载**: 设置计数器是否应该在定时器警报上使用 :cpp:member:`auto_reload` 自动重载首个计数值，还是继续递增或递减。
 
 要获取定时器设置的当前值，请使用函数 :cpp:func:`timer_get_config`。
 
-- 
2.25.1


From 1abdfee3b7ea9e432bba5eeda36c8a9f4dc1f6ba Mon Sep 17 00:00:00 2001
From: Aditya Patwardhan <aditya.patwardhan@espressif.com>
Date: Mon, 17 May 2021 12:17:20 +0530
Subject: [PATCH 38/43] secure_element: Update esp-cryptoauthlib submodule
 latest version. *This updates the cryptoauthlib version in the
 esp-cryptoauthlib to cryptoauthlib-v3.3.1

---
 components/esp-tls/esp_tls_mbedtls.c                   | 10 ++++++----
 .../atecc608_ecdsa/components/esp-cryptoauthlib        |  2 +-
 .../atecc608_ecdsa/main/ecdsa_example_main.c           |  4 ++--
 3 files changed, 9 insertions(+), 7 deletions(-)

diff --git a/components/esp-tls/esp_tls_mbedtls.c b/components/esp-tls/esp_tls_mbedtls.c
index 53f10d7de1..10db36338a 100644
--- a/components/esp-tls/esp_tls_mbedtls.c
+++ b/components/esp-tls/esp_tls_mbedtls.c
@@ -39,7 +39,7 @@
 #include "mbedtls/atca_mbedtls_wrap.h"
 #include "tng_atca.h"
 #include "cryptoauthlib.h"
-static const atcacert_def_t* cert_def = NULL;
+static const atcacert_def_t *cert_def = NULL;
 /* Prototypes for functions */
 static esp_err_t esp_set_atecc608a_pki_context(esp_tls_t *tls, esp_tls_cfg_t *cfg);
 #endif /* CONFIG_ESP_TLS_USE_SECURE_ELEMENT */
@@ -669,9 +669,9 @@ void esp_mbedtls_free_global_ca_store(void)
 }
 
 #ifdef CONFIG_ESP_TLS_USE_SECURE_ELEMENT
-static esp_err_t esp_init_atecc608a(uint8_t slave_addr)
+static esp_err_t esp_init_atecc608a(uint8_t i2c_addr)
 {
-    cfg_ateccx08a_i2c_default.atcai2c.slave_address = slave_addr;
+    cfg_ateccx08a_i2c_default.atcai2c.address = i2c_addr;
     int ret = atcab_init(&cfg_ateccx08a_i2c_default);
     if(ret != 0) {
         ESP_LOGE(TAG, "Failed\n !atcab_init returned %02x", ret);
@@ -683,8 +683,10 @@ static esp_err_t esp_init_atecc608a(uint8_t slave_addr)
 static esp_err_t esp_set_atecc608a_pki_context(esp_tls_t *tls, esp_tls_cfg_t *cfg)
 {
     int ret = 0;
-    int esp_ret = ESP_FAIL;
+    esp_err_t esp_ret = ESP_FAIL;
     ESP_LOGI(TAG, "Initialize the ATECC interface...");
+    (void)esp_ret;
+    (void)cert_def;
 #if defined(CONFIG_ATECC608A_TNG) || defined(CONFIG_ATECC608A_TFLEX)
 #ifdef CONFIG_ATECC608A_TNG
     esp_ret = esp_init_atecc608a(ATECC608A_TNG_SLAVE_ADDR);
diff --git a/examples/peripherals/secure_element/atecc608_ecdsa/components/esp-cryptoauthlib b/examples/peripherals/secure_element/atecc608_ecdsa/components/esp-cryptoauthlib
index c3d3a69021..bb672b0437 160000
--- a/examples/peripherals/secure_element/atecc608_ecdsa/components/esp-cryptoauthlib
+++ b/examples/peripherals/secure_element/atecc608_ecdsa/components/esp-cryptoauthlib
@@ -1 +1 @@
-Subproject commit c3d3a69021cfec3236ca2c0b63be4048ec6643a4
+Subproject commit bb672b0437485fc7420add178299631692b15ac3
diff --git a/examples/peripherals/secure_element/atecc608_ecdsa/main/ecdsa_example_main.c b/examples/peripherals/secure_element/atecc608_ecdsa/main/ecdsa_example_main.c
index eb8d2ce4a6..be379ff3cc 100644
--- a/examples/peripherals/secure_element/atecc608_ecdsa/main/ecdsa_example_main.c
+++ b/examples/peripherals/secure_element/atecc608_ecdsa/main/ecdsa_example_main.c
@@ -179,10 +179,10 @@ void app_main(void)
     ret = configure_mbedtls_rng();
 #ifdef CONFIG_ATECC608A_TNG
     ESP_LOGI(TAG, "  . Initialize the ATECC interface for Trust & GO ...");
-    cfg_ateccx08a_i2c_default.atcai2c.slave_address = 0x6A;
+    cfg_ateccx08a_i2c_default.atcai2c.address = 0x6A;
 #elif CONFIG_ATECC608A_TFLEX /* CONFIG_ATECC608A_TNGO */
     ESP_LOGI(TAG, "  . Initialize the ATECC interface for TrustFlex ...");
-    cfg_ateccx08a_i2c_default.atcai2c.slave_address = 0x6C;
+    cfg_ateccx08a_i2c_default.atcai2c.address = 0x6C;
 #elif CONFIG_ATECC608A_TCUSTOM /* CONFIG_ATECC608A_TFLEX */
     ESP_LOGI(TAG, "  . Initialize the ATECC interface for TrustCustom ...");
     /* Default slave address is same as that of TCUSTOM ATECC608A chips */
-- 
2.25.1


From 0cd021adb1014f54683acfe69ce76f031c39c9b9 Mon Sep 17 00:00:00 2001
From: David Cermak <cermak@espressif.com>
Date: Fri, 9 Apr 2021 20:36:01 +0200
Subject: [PATCH 39/43] esp_eth: Recover the w5500 driver from missed io
 interrupt

If the GPIO interrupt is re-asserted too quickly it could be missed. If this happens the driver goes silent and never receives any data. Recover by periodic checks of the IO signal level
---
 components/esp_eth/src/esp_eth_mac_w5500.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/components/esp_eth/src/esp_eth_mac_w5500.c b/components/esp_eth/src/esp_eth_mac_w5500.c
index cc46509476..2e74bb4238 100644
--- a/components/esp_eth/src/esp_eth_mac_w5500.c
+++ b/components/esp_eth/src/esp_eth_mac_w5500.c
@@ -314,8 +314,12 @@ static void emac_w5500_task(void *arg)
     uint8_t *buffer = NULL;
     uint32_t length = 0;
     while (1) {
-        // block indefinitely until some task notifies me
-        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
+        // check if the task receives any notification
+        if (ulTaskNotifyTake(pdTRUE, pdMS_TO_TICKS(1000)) == 0 &&    // if no notification ...
+            gpio_get_level(emac->int_gpio_num) != 0) {               // ...and no interrupt asserted
+            continue;                                                // -> just continue to check again
+        }
+
         /* read interrupt status */
         w5500_read(emac, W5500_REG_SOCK_IR(0), &status, sizeof(status));
         /* packet received */
-- 
2.25.1


From 45846f06cffe98b7d5f09527df056c8e3d54a75e Mon Sep 17 00:00:00 2001
From: David Cermak <cermak@espressif.com>
Date: Fri, 9 Apr 2021 21:25:20 +0200
Subject: [PATCH 40/43] esp_eth: Improve GPIO interrupt processing in w5500
 driver

Increase the interrupt reassert level timing so the chances of missing
two consecutive events are minimal.
Enable only SIR_RECV interrupt event, so the SEND events are not used
for GPIO signal.
---
 components/esp_eth/src/esp_eth_mac_w5500.c | 7 +++++--
 components/esp_eth/src/w5500.h             | 1 +
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/components/esp_eth/src/esp_eth_mac_w5500.c b/components/esp_eth/src/esp_eth_mac_w5500.c
index 2e74bb4238..bb35652988 100644
--- a/components/esp_eth/src/esp_eth_mac_w5500.c
+++ b/components/esp_eth/src/esp_eth_mac_w5500.c
@@ -259,9 +259,12 @@ static esp_err_t w5500_setup_default(emac_w5500_t *emac)
     /* Enable MAC RAW mode for SOCK0, enable MAC filter, no blocking broadcast and multicast */
     reg_value = W5500_SMR_MAC_RAW | W5500_SMR_MAC_FILTER;
     ESP_GOTO_ON_ERROR(w5500_write(emac, W5500_REG_SOCK_MR(0), &reg_value, sizeof(reg_value)), err, TAG, "write SMR failed");
-    /* Enable receive and send event for SOCK0 */
-    reg_value = W5500_SIR_RECV | W5500_SIR_SEND;
+    /* Enable receive event for SOCK0 */
+    reg_value = W5500_SIR_RECV;
     ESP_GOTO_ON_ERROR(w5500_write(emac, W5500_REG_SOCK_IMR(0), &reg_value, sizeof(reg_value)), err, TAG, "write SOCK0 IMR failed");
+    /* Set the interrupt re-assert level to maximum (~1.5ms) to lower the chances of missing it */
+    uint16_t int_level = __builtin_bswap16(0xFFFF);
+    ESP_GOTO_ON_ERROR(w5500_write(emac, W5500_REG_INTLEVEL, &int_level, sizeof(int_level)), err, TAG, "write INTLEVEL failed");
 
 err:
     return ret;
diff --git a/components/esp_eth/src/w5500.h b/components/esp_eth/src/w5500.h
index 8e423796fc..4460f7a8de 100644
--- a/components/esp_eth/src/w5500.h
+++ b/components/esp_eth/src/w5500.h
@@ -33,6 +33,7 @@
 
 #define W5500_REG_MR        W5500_MAKE_MAP(0x0000, W5500_BSB_COM_REG) // Mode
 #define W5500_REG_MAC       W5500_MAKE_MAP(0x0009, W5500_BSB_COM_REG) // MAC Address
+#define W5500_REG_INTLEVEL  W5500_MAKE_MAP(0x0013, W5500_BSB_COM_REG) // Interrupt Level Timeout
 #define W5500_REG_IR        W5500_MAKE_MAP(0x0015, W5500_BSB_COM_REG) // Interrupt
 #define W5500_REG_IMR       W5500_MAKE_MAP(0x0016, W5500_BSB_COM_REG) // Interrupt Mask
 #define W5500_REG_SIR       W5500_MAKE_MAP(0x0017, W5500_BSB_COM_REG) // Socket Interrupt
-- 
2.25.1


From 4e2eacdb29843de4bb38aee5cd0f001af5de340b Mon Sep 17 00:00:00 2001
From: Darian Leung <darian@espressif.com>
Date: Thu, 11 Mar 2021 20:50:05 +0800
Subject: [PATCH 41/43] HCD: Add support for interrupt and isochronous pipes

This commit adds support for interrupt and isochronous pipes to the HCD:
- HCD now internally uses double buffering
- Added test cases for interrupt and isochronous transfers
- Reorganized test cases for each transfer type
- Updated API comments and maintainer's notes

Some minor bugs were also fixed
---
 .../esp32s2/include/hal/usb_types_private.h   |   23 +
 components/hal/esp32s2/include/hal/usbh_hal.h |  491 ++---
 components/hal/esp32s2/include/hal/usbh_ll.h  |  111 +-
 components/hal/esp32s2/usbh_hal.c             |  182 +-
 components/usb/CMakeLists.txt                 |    4 +-
 components/usb/hcd.c                          | 1674 ++++++++++++-----
 components/usb/maintainers.md                 |   22 +-
 components/usb/private_include/hcd.h          |   75 +-
 components/usb/private_include/usb.h          |   42 +-
 components/usb/test/CMakeLists.txt            |    4 +-
 components/usb/test/hcd/test_hcd_bulk.c       |  262 +++
 components/usb/test/hcd/test_hcd_common.c     |  350 ++++
 components/usb/test/hcd/test_hcd_common.h     |  151 ++
 components/usb/test/hcd/test_hcd_ctrl.c       |  271 +++
 components/usb/test/hcd/test_hcd_intr.c       |  159 ++
 components/usb/test/hcd/test_hcd_isoc.c       |  114 ++
 components/usb/test/hcd/test_hcd_port.c       |  309 +++
 components/usb/test/test_hcd.c                |  790 --------
 18 files changed, 3363 insertions(+), 1671 deletions(-)
 create mode 100644 components/usb/test/hcd/test_hcd_bulk.c
 create mode 100644 components/usb/test/hcd/test_hcd_common.c
 create mode 100644 components/usb/test/hcd/test_hcd_common.h
 create mode 100644 components/usb/test/hcd/test_hcd_ctrl.c
 create mode 100644 components/usb/test/hcd/test_hcd_intr.c
 create mode 100644 components/usb/test/hcd/test_hcd_isoc.c
 create mode 100644 components/usb/test/hcd/test_hcd_port.c
 delete mode 100644 components/usb/test/test_hcd.c

diff --git a/components/hal/esp32s2/include/hal/usb_types_private.h b/components/hal/esp32s2/include/hal/usb_types_private.h
index 0a50160526..868fdee589 100644
--- a/components/hal/esp32s2/include/hal/usb_types_private.h
+++ b/components/hal/esp32s2/include/hal/usb_types_private.h
@@ -44,6 +44,29 @@ typedef enum {
     USB_PRIV_XFER_TYPE_INTR,
 } usb_priv_xfer_type_t;
 
+/**
+ * @brief Enumeration of different possible lengths of the periodic frame list
+ */
+typedef enum {
+    USB_HAL_FRAME_LIST_LEN_8 = 8,
+    USB_HAL_FRAME_LIST_LEN_16 = 16,
+    USB_HAL_FRAME_LIST_LEN_32 = 32,
+    USB_HAL_FRAME_LIST_LEN_64 = 64,
+} usb_hal_frame_list_len_t;
+
+/**
+ * @brief Support intervals in number of USB frames (i.e., 1ms)
+ */
+typedef enum {
+    USB_HAL_INTERVAL_1 = 1,
+    USB_HAL_INTERVAL_2 = 2,
+    USB_HAL_INTERVAL_4 = 4,
+    USB_HAL_INTERVAL_8 = 8,
+    USB_HAL_INTERVAL_16 = 16,
+    USB_HAL_INTERVAL_32 = 32,
+    USB_HAL_INTERVAL_64 = 64,
+} usb_hal_interval_t;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/components/hal/esp32s2/include/hal/usbh_hal.h b/components/hal/esp32s2/include/hal/usbh_hal.h
index 17afacd7d2..ff0a186c3f 100644
--- a/components/hal/esp32s2/include/hal/usbh_hal.h
+++ b/components/hal/esp32s2/include/hal/usbh_hal.h
@@ -20,7 +20,7 @@ extern "C" {
 
 /*
 NOTE: Thread safety is the responsibility fo the HAL user. All USB Host HAL
-      functions should be called from critical sections unless specified otherwise
+      functions must be called from critical sections unless specified otherwise
 */
 
 #include <stdlib.h>
@@ -30,21 +30,29 @@ NOTE: Thread safety is the responsibility fo the HAL user. All USB Host HAL
 #include "hal/usbh_ll.h"
 #include "hal/usb_types_private.h"
 
-/* -----------------------------------------------------------------------------
-------------------------------- Macros and Types -------------------------------
------------------------------------------------------------------------------ */
+// ------------------------------------------------ Macros and Types ---------------------------------------------------
 
-// ---------------------------- Constants/Configs ------------------------------
+// ------------------ Constants/Configs --------------------
 
 #define USBH_HAL_DMA_MEM_ALIGN              512
+#define USBH_HAL_FRAME_LIST_MEM_ALIGN       512     //The frame list needs to be 512 bytes aligned (contrary to the databook)
 #define USBH_HAL_NUM_CHAN                   8
 #define USBH_HAL_XFER_DESC_SIZE             (sizeof(usbh_ll_dma_qtd_t))
+#define USBH_HAL_FIFO_TOTAL_USABLE_LINES    200     //Although we have a 256 lines, only 200 lines are usuable due to EPINFO_CTL
 
-// ------------------------------- HAL States ----------------------------------
+/**
+ * @brief FIFO size configuration structure
+ */
+typedef struct {
+    uint32_t rx_fifo_lines;                 /**< Size of the RX FIFO in terms the number of FIFO lines */
+    uint32_t nptx_fifo_lines;               /**< Size of the Non-periodic FIFO in terms the number of FIFO lines */
+    uint32_t ptx_fifo_lines;                /**< Size of the Periodic FIFO in terms the number of FIFO lines */
+} usbh_hal_fifo_config_t;
+
+// --------------------- HAL States ------------------------
 
 /**
  * @brief Channel states
- *
  */
 typedef enum {
     USBH_HAL_CHAN_STATE_HALTED = 0,         /**< The channel is halted. No transfer descriptor list is being executed */
@@ -52,7 +60,7 @@ typedef enum {
     USBH_HAL_CHAN_STATE_ERROR,              /**< The channel is in the error state */
 } usbh_hal_chan_state_t;
 
-// ------------------------------- HAL Events ----------------------------------
+// --------------------- HAL Events ------------------------
 
 /**
  * @brief Host port HAL events
@@ -72,48 +80,46 @@ typedef enum {
  * @brief Channel events
  */
 typedef enum {
-    USBH_HAL_CHAN_EVENT_SLOT_DONE,          /**< The channel has completed execution of an entire transfer descriptor list. Channel is now halted */
-    USBH_HAL_CHAN_EVENT_SLOT_HALT,          /**< The channel as completed execution of a single transfer descriptor in a list. Channel is now halted */
+    USBH_HAL_CHAN_EVENT_CPLT,               /**< The channel has completed execution of a transfer descriptor that had the USBH_HAL_XFER_DESC_FLAG_HOC flag set. Channel is now halted */
     USBH_HAL_CHAN_EVENT_ERROR,              /**< The channel has encountered an error. Channel is now halted. */
     USBH_HAL_CHAN_EVENT_HALT_REQ,           /**< The channel has been successfully halted as requested */
+    USBH_HAL_CHAN_EVENT_NONE,               /**< No event (interrupt ran for internal processing) */
 } usbh_hal_chan_event_t;
 
-// ------------------------------- HAL Errors ----------------------------------
+// --------------------- HAL Errors ------------------------
 
 /**
  * @brief Channel errors
  */
 typedef enum {
     USBH_HAL_CHAN_ERROR_XCS_XACT = 0,       /**< Excessive (three consecutive) transaction errors (e.g., no response, bad CRC etc */
-    USBH_HAL_CHAN_ERROR_BNA,                /**< Buffer Not Available error (i.e., transfer slot is unfilled */
+    USBH_HAL_CHAN_ERROR_BNA,                /**< Buffer Not Available error (i.e., An inactive transfer descriptor was tecthed by the channel) */
     USBH_HAL_CHAN_ERROR_PKT_BBL,            /**< Packet babbler error (packet exceeded MPS) */
     USBH_HAL_CHAN_ERROR_STALL,              /**< STALL response received */
 } usbh_hal_chan_error_t;
 
-// ----------------------- Transfer Descriptor Related -------------------------
+// ------------- Transfer Descriptor Related ---------------
 
 /**
  * @brief Flags used to describe the type of transfer descriptor to fill
  */
-#define USBH_HAL_XFER_DESC_FLAG_IN          0x01
-#define USBH_HAL_XFER_DESC_FLAG_SETUP       0x02
-#define USBH_HAL_XFER_DESC_FLAG_NULL        0x04
-#define USBH_HAL_XFER_DESC_FLAG_HALT        0x08
+#define USBH_HAL_XFER_DESC_FLAG_IN          0x01    /**< Indicates this transfer descriptor is of the IN direction */
+#define USBH_HAL_XFER_DESC_FLAG_SETUP       0x02    /**< Indicates this transfer descriptor is an OUT setup */
+#define USBH_HAL_XFER_DESC_FLAG_HOC         0x04    /**< Indicates that the channel will be halted after this transfer descriptor completes */
 
 /**
  * @brief Status value of a transfer descriptor
  *
- * A transfer descriptor's status remains unexecuted until the entire transfer
- * descriptor completes (either successfully or an error). Therefore, if a
- * channel halt is requested before a transfer descriptor completes, the
- * transfer descriptoor remains unexecuted.
+ * A transfer descriptor's status remains unexecuted until the entire transfer descriptor completes (either successfully
+ * or an error). Therefore, if a channel halt is requested before a transfer descriptor completes, the transfer
+ * descriptor remains unexecuted.
  */
 #define USBH_HAL_XFER_DESC_STS_SUCCESS      USBH_LL_QTD_STATUS_SUCCESS
 #define USBH_HAL_XFER_DESC_STS_PKTERR       USBH_LL_QTD_STATUS_PKTERR
 #define USBH_HAL_XFER_DESC_STS_BUFFER_ERR   USBH_LL_QTD_STATUS_BUFFER
 #define USBH_HAL_XFER_DESC_STS_NOT_EXECUTED USBH_LL_QTD_STATUS_NOT_EXECUTED
 
-// ------------------------------ Object Types ---------------------------------
+// -------------------- Object Types -----------------------
 
 /**
  * @brief Endpoint characteristics structure
@@ -131,6 +137,14 @@ typedef struct {
         };
         uint32_t val;
     };
+    union {
+        struct {
+            usb_hal_interval_t interval: 8;     /**< The interval of the endpoint */
+            uint32_t phase_offset_frames: 8;    /**< Phase offset in number of frames */
+            uint32_t reserved16: 16;
+        };
+        uint32_t val;
+    } periodic;                                 /**< Characteristic for periodic (interrupt/isochronous) endpoints only */
 } usbh_hal_ep_char_t;
 
 /**
@@ -143,29 +157,16 @@ typedef struct {
             uint32_t active: 1;             /**< The channel is enabled */
             uint32_t halt_requested: 1;     /**< A halt has been requested */
             uint32_t error_pending: 1;      /**< The channel is waiting for the error to be handled */
+            uint32_t reserved: 1;
             uint32_t chan_idx: 4;           /**< The index number of the channel */
-            uint32_t reserved25: 25;
+            usb_priv_xfer_type_t type: 2;    /**< The transfer type of the channel */
+            uint32_t reserved22: 22;
         };
         uint32_t val;
     } flags;                                /**< Flags regarding channel's status and information */
     usb_host_chan_regs_t *regs;             /**< Pointer to the channel's register set */
     usbh_hal_chan_error_t error;            /**< The last error that occurred on the channel */
     void *chan_ctx;                         /**< Context variable for the owner of the channel */
-    //Transfer Descriptor List Slot
-    struct {
-        union {
-            struct {
-                uint32_t slot_acquired: 1;  /**< The transfer descriptor list slot has been acquired */
-                uint32_t reserved7: 7;
-                uint32_t cur_qtd_idx: 8;    /**< Index of the first QTD in chain of QTDs being executed */
-                uint32_t qtd_list_len: 8;   /**< Length of QTD list in number of QTDs */
-                uint32_t reserved8: 8;
-            };
-            uint32_t val;
-        } flags;
-        void *owner_ctx;                    /**< Context variable for the owner of the slot */
-        usbh_ll_dma_qtd_t *xfer_desc_list;  /**< Pointer to transfer descriptor list */
-    } slot;
 } usbh_hal_chan_t;
 
 /**
@@ -176,10 +177,15 @@ typedef struct {
     usbh_dev_t *dev;                            /**< Pointer to base address of DWC_OTG registers */
     usb_wrap_dev_t *wrap_dev;                   /**< Pointer to base address of USB Wrapper registers */
     //Host Port related
+    uint32_t *periodic_frame_list;              /**< Pointer to scheduling frame list */
     union {
         struct {
-            uint32_t dbnc_lock_enabled: 1;  /**< Debounce lock enabled */
-            uint32_t reserved31: 31;
+            uint32_t dbnc_lock_enabled: 1;      /**< Debounce lock enabled */
+            uint32_t fifo_sizes_set: 1;         /**< Whether the FIFO sizes have been set or not */
+            uint32_t periodic_sched_enabled: 1; /**< Periodic scheduling (for interrupt and isochronous transfers) is enabled */
+            uint32_t reserved: 5;
+            usb_hal_frame_list_len_t frame_list_len: 8; /**< Length of the periodic scheduling frame list */
+            uint32_t reserved16: 16;
         };
         uint32_t val;
     } flags;
@@ -191,9 +197,7 @@ typedef struct {
     } channels;
 } usbh_hal_context_t;
 
-/* -----------------------------------------------------------------------------
---------------------------------- Core (Global) --------------------------------
------------------------------------------------------------------------------ */
+// -------------------------------------------------- Core (Global) ----------------------------------------------------
 
 /**
  * @brief Initialize the HAL context and check if DWC_OTG is alive
@@ -219,7 +223,7 @@ void usbh_hal_init(usbh_hal_context_t *hal);
  * @brief Deinitialize the HAL context
  *
  * Entry:
- * - All channels should be properly disabled, and any pending events handled
+ * - All channels must be properly disabled, and any pending events handled
  * Exit:
  * - DWC_OTG global interrupt disabled
  * - HAL context deinitialized
@@ -231,13 +235,9 @@ void usbh_hal_deinit(usbh_hal_context_t *hal);
 /**
  * @brief Issue a soft reset to the controller
  *
- * This should be called when the host port encounters an error event or has
- * been disconnected. Before calling this, users are responsible for safely
- * freeing all channels as a soft reset will wipe all host port nd channel
- * registers.
- *
- * This function will result in the host port being put back into same state as
- * after calling usbh_hal_init().
+ * This should be called when the host port encounters an error event or has been disconnected. Before calling this,
+ * users are responsible for safely freeing all channels as a soft reset will wipe all host port and channel registers.
+ * This function will result in the host port being put back into same state as after calling usbh_hal_init().
  *
  * @note This has nothing to do with a USB bus reset. It simply resets the peripheral
  *
@@ -245,18 +245,33 @@ void usbh_hal_deinit(usbh_hal_context_t *hal);
  */
 void usbh_hal_core_soft_reset(usbh_hal_context_t *hal);
 
-/* -----------------------------------------------------------------------------
----------------------------------- Host Port ----------------------------------
------------------------------------------------------------------------------ */
+/**
+ * @brief Set FIFO sizes
+ *
+ * This function will set the sizes of each of the FIFOs (RX FIFO, Non-periodic TX FIFO, Periodic TX FIFO) and must be
+ * called at least once before allocating the channel. Based on the type of endpoints (and the endpionts' MPS), there
+ * may be situations where this function may need to be called again to resize the FIFOs. If resizing FIFOs dynamically,
+ * it is the user's responsibility to ensure there are no active channels when this function is called.
+ *
+ * @note The totol size of all the FIFOs must be less than or equal to USBH_HAL_FIFO_TOTAL_USABLE_LINES
+ *
+ * @param hal Context of the HAL layer
+ * @param fifo_config FIFO configuration
+ */
+void usbh_hal_set_fifo_size(usbh_hal_context_t *hal, const usbh_hal_fifo_config_t *fifo_config);
 
-// ---------------------------- Host Port Control ------------------------------
+// ---------------------------------------------------- Host Port ------------------------------------------------------
+
+// ------------------ Host Port Control --------------------
 
 /**
- * @brief Enable the host port's interrupt allowing port and channel events to occur
+ * @brief Initialize the host port
+ *
+ * - Will enable the host port's interrupts allowing port and channel events to occur
  *
  * @param hal Context of the HAL layer
  */
-static inline void usbh_hal_port_start(usbh_hal_context_t *hal)
+static inline void usbh_hal_port_init(usbh_hal_context_t *hal)
 {
     //Configure Host related interrupts
     usbh_ll_haintmsk_dis_chan_intr(hal->dev, 0xFFFFFFFF);   //Disable interrupts for all channels
@@ -264,11 +279,13 @@ static inline void usbh_hal_port_start(usbh_hal_context_t *hal)
 }
 
 /**
- * @brief Disable the host port's interrupt preventing any further port or channel events
+ * @brief Deinitialize the host port
+ *
+ * - Will disable the host port's interrupts preventing further port aand channel events from ocurring
  *
  * @param hal Context of the HAL layer
  */
-static inline void usbh_hal_port_stop(usbh_hal_context_t *hal)
+static inline void usbh_hal_port_deinit(usbh_hal_context_t *hal)
 {
     //Disable Host port and channel interrupts
     usb_ll_dis_intrs(hal->dev, USB_LL_INTR_CORE_PRTINT | USB_LL_INTR_CORE_HCHINT);
@@ -298,9 +315,8 @@ static inline void usbh_hal_port_toggle_power(usbh_hal_context_t *hal, bool powe
  * Exit:
  * - On release of the reset signal, a USBH_HAL_PORT_EVENT_ENABLED will be generated
  *
- * @note If the host port is already enabled, then issuing a reset will cause
- *       it be disabled and generate a USBH_HAL_PORT_EVENT_DISABLED event. The
- *       host port will not be enabled until the reset signal is released (thus
+ * @note If the host port is already enabled, then issuing a reset will cause it be disabled and generate a
+ *       USBH_HAL_PORT_EVENT_DISABLED event. The host port will not be enabled until the reset signal is released (thus
  *       generating the USBH_HAL_PORT_EVENT_ENABLED event)
  *
  * @param hal Context of the HAL layer
@@ -353,8 +369,7 @@ static inline void usbh_hal_port_suspend(usbh_hal_context_t *hal)
  *
  * Hosts should hold the resume signal for at least 20ms
  *
- * @note If a remote wakeup event occurs, the resume signal is driven
- *       and cleared automatically.
+ * @note If a remote wakeup event occurs, the resume signal is driven and cleared automatically.
  *
  * @param hal Context of the HAL layer
  * @param enable Enable/disable resume signal
@@ -371,9 +386,8 @@ static inline void usbh_hal_port_toggle_resume(usbh_hal_context_t *hal, bool ena
 /**
  * @brief Check whether the resume signal is being driven
  *
- * If a remote wakeup event occurs, the core will automatically drive and clear
- * the resume signal for the required amount of time. Call this function to
- * check whether the resume signal has completed.
+ * If a remote wakeup event occurs, the core will automatically drive and clear the resume signal for the required
+ * amount of time. Call this function to check whether the resume signal has completed.
  *
  * @param hal Context of the HAL layer
  * @return true Resume signal is still being driven
@@ -384,18 +398,89 @@ static inline bool usbh_hal_port_check_resume(usbh_hal_context_t *hal)
     return usbh_ll_hprt_get_port_resume(hal->dev);
 }
 
-// -------------------------- Host Port Status/State ---------------------------
+// ---------------- Host Port Scheduling -------------------
+
+/**
+ * @brief Sets the periodic scheduling frame list
+ *
+ * @note This function must be called before attempting configuring any channels to be period via
+ *       usbh_hal_chan_set_ep_char()
+ *
+ * @param hal Context of the HAL layer
+ * @param frame_list Base address of the frame list
+ * @param frame_list_len Number of entries in the frame list (can only be 8, 16, 32, 64)
+ */
+static inline void usbh_hal_port_set_frame_list(usbh_hal_context_t *hal, uint32_t *frame_list, usb_hal_frame_list_len_t len)
+{
+    assert(!hal->flags.periodic_sched_enabled);
+    //Clear and save frame list
+    hal->periodic_frame_list = frame_list;
+    hal->flags.frame_list_len = len;
+}
+
+/**
+ * @brief Get the pointer to the periodic scheduling frame list
+ *
+ * @param hal Context of the HAL layer
+ * @return uint32_t* Base address of the periodic scheduling frame list
+ */
+static inline uint32_t *usbh_hal_port_get_frame_list(usbh_hal_context_t *hal)
+{
+    return hal->periodic_frame_list;
+}
+
+/**
+ * @brief Enable periodic scheduling
+ *
+ * @note The periodic frame list must be set via usbh_hal_port_set_frame_list() should be set before calling this
+ *       function
+ * @note This function must be called before activating any periodic channels
+ *
+ * @param hal Context of the HAL layer
+ */
+static inline void usbh_hal_port_periodic_enable(usbh_hal_context_t *hal)
+{
+    assert(hal->periodic_frame_list != NULL && !hal->flags.periodic_sched_enabled);
+    usbh_ll_set_frame_list_base_addr(hal->dev, (uint32_t)hal->periodic_frame_list);
+    usbh_ll_hcfg_set_num_frame_list_entries(hal->dev, hal->flags.frame_list_len);
+    usbh_ll_hcfg_en_perio_sched(hal->dev);
+    hal->flags.periodic_sched_enabled = 1;
+}
+
+/**
+ * @brief Disable periodic scheduling
+ *
+ * Disabling periodic scheduling will save a bit of DMA bandwith (as the controller will no longer fetch the schedule
+ * from the frame list).
+ *
+ * @note Before disabling periodic scheduling, it is the user's responsibility to ensure that all periodic channels have
+ *       halted safely.
+ *
+ * @param hal Context of the HAL layer
+ */
+static inline void usbh_hal_port_periodic_disable(usbh_hal_context_t *hal)
+{
+    assert(hal->flags.periodic_sched_enabled);
+    usbh_ll_hcfg_dis_perio_sched(hal->dev);
+    hal->flags.periodic_sched_enabled = 0;
+}
+
+static inline uint32_t usbh_hal_port_get_cur_frame_num(usbh_hal_context_t *hal)
+{
+    return usbh_ll_get_frm_num(hal->dev);
+}
+
+// --------------- Host Port Status/State ------------------
 
 /**
  * @brief Check if a device is currently connected to the host port
  *
- * This function is intended to be called after one of the following events
- * followed by an adequate debounce delay
+ * This function is intended to be called after one of the following events followed by an adequate debounce delay
  * - USBH_HAL_PORT_EVENT_CONN
  * - USBH_HAL_PORT_EVENT_DISCONN
  *
- * @note No other connection/disconnection event will occur again until the
- *       debounce lock is disabled via usbh_hal_disable_debounce_lock()
+ * @note No other connection/disconnection event will occur again until the debounce lock is disabled via
+ *       usbh_hal_disable_debounce_lock()
  *
  * @param hal Context of the HAL layer
  * @return true A device is connected to the host port
@@ -409,8 +494,7 @@ static inline bool usbh_hal_port_check_if_connected(usbh_hal_context_t *hal)
 /**
  * @brief Check the speed (LS/FS) of the device connected to the host port
  *
- * @note This function should only be called after confirming that a device is
- *       connected to the host port
+ * @note This function should only be called after confirming that a device is connected to the host port
  *
  * @param hal Context of the HAL layer
  * @return usb_priv_speed_t Speed of the connected device (FS or LS only on the esp32-s2)
@@ -423,9 +507,8 @@ static inline usb_priv_speed_t usbh_hal_port_get_conn_speed(usbh_hal_context_t *
 /**
  * @brief Disable the debounce lock
  *
- * This function should be called after calling usbh_hal_port_check_if_connected()
- * and will allow connection/disconnection events to occur again. Any pending
- * connection or disconenction interrupts are cleared.
+ * This function must be called after calling usbh_hal_port_check_if_connected() and will allow connection/disconnection
+ * events to occur again. Any pending connection or disconenction interrupts are cleared.
  *
  * @param hal Context of the HAL layer
  */
@@ -439,11 +522,9 @@ static inline void usbh_hal_disable_debounce_lock(usbh_hal_context_t *hal)
     usb_ll_en_intrs(hal->dev, USB_LL_INTR_CORE_PRTINT | USB_LL_INTR_CORE_DISCONNINT);
 }
 
-/* -----------------------------------------------------------------------------
------------------------------------ Channel ------------------------------------
-------------------------------------------------------------------------------*/
+// ----------------------------------------------------- Channel -------------------------------------------------------
 
-// --------------------------- Channel Allocation ------------------------------
+// ----------------- Channel Allocation --------------------
 
 /**
  * @brief Allocate a channel
@@ -464,6 +545,8 @@ bool usbh_hal_chan_alloc(usbh_hal_context_t *hal, usbh_hal_chan_t *chan_obj, voi
  */
 void usbh_hal_chan_free(usbh_hal_context_t *hal, usbh_hal_chan_t *chan_obj);
 
+// ---------------- Channel Configuration ------------------
+
 /**
  * @brief Get the context variable of the channel
  *
@@ -475,8 +558,6 @@ static inline void *usbh_hal_chan_get_context(usbh_hal_chan_t *chan_obj)
     return chan_obj->chan_ctx;
 }
 
-// ---------------------------- Channel Control --------------------------------
-
 /**
  * @brief Get the current state of a channel
  *
@@ -502,10 +583,11 @@ static inline usbh_hal_chan_state_t usbh_hal_chan_get_state(usbh_hal_chan_t *cha
  * @note the channel must be in the disabled state in order to change its EP
  *       information
  *
+ * @param hal Context of the HAL layer
  * @param chan_obj Channel object
  * @param ep_char Endpoint characteristics
  */
-void usbh_hal_chan_set_ep_char(usbh_hal_chan_t *chan_obj, usbh_hal_ep_char_t *ep_char);
+void usbh_hal_chan_set_ep_char(usbh_hal_context_t *hal, usbh_hal_chan_t *chan_obj, usbh_hal_ep_char_t *ep_char);
 
 /**
  * @brief Set the direction of the channel
@@ -514,8 +596,7 @@ void usbh_hal_chan_set_ep_char(usbh_hal_chan_t *chan_obj, usbh_hal_ep_char_t *ep
  * needing to reconfigure all of the channel's EP info. This is used primarily
  * for control transfers.
  *
- * @note This function should only be called when the channel is in the disabled
- *       state or is halted from a USBH_HAL_CHAN_EVENT_SLOT_HALT event
+ * @note This function should only be called when the channel is halted
  *
  * @param chan_obj Channel object
  * @param is_in Whether the direction is IN
@@ -563,6 +644,51 @@ static inline uint32_t usbh_hal_chan_get_pid(usbh_hal_chan_t *chan_obj)
     return usbh_ll_chan_get_pid(chan_obj->regs);
 }
 
+// ------------------- Channel Control ---------------------
+
+/**
+ * @brief Activate a channel
+ *
+ * Activating a channel will cause the channel to start executing transfer descriptors.
+ *
+ * @note This function should only be called on channels that were previously halted
+ * @note An event will be generated when the channel is halted
+ *
+ * @param chan_obj Channel object
+ * @param xfer_desc_list A filled transfer descriptor list
+ * @param desc_list_len Transfer descriptor list length
+ * @param start_idx Index of the starting transfer descriptor in the list
+ */
+void usbh_hal_chan_activate(usbh_hal_chan_t *chan_obj, void *xfer_desc_list, int desc_list_len, int start_idx);
+
+/**
+ * @brief Get the index of the current transfer descriptor
+ *
+ * @param chan_obj Channel object
+ * @return int Descriptor index
+ */
+static inline int usbh_hal_chan_get_qtd_idx(usbh_hal_chan_t *chan_obj)
+{
+    return usbh_ll_chan_get_ctd(chan_obj->regs);
+}
+
+/**
+ * @brief Request to halt a channel
+ *
+ * This function should be called in order to halt a channel. If the channel is already halted, this function will
+ * return true. If the channel is still active, this function will return false and users must wait for the
+ * USBH_HAL_CHAN_EVENT_HALT_REQ event before treating the channel as halted.
+ *
+ * @note When a transfer is in progress (i.e., the channel is active) and a halt is requested, the channel will halt
+ *       after the next USB packet is completed. If the transfer has more pending packets, the transfer will just be
+ *       marked as USBH_HAL_XFER_DESC_STS_NOT_EXECUTED.
+ *
+ * @param chan_obj Channel object
+ * @return true The channel is already halted
+ * @return false The halt was requested, wait for USBH_HAL_CHAN_EVENT_HALT_REQ
+ */
+bool usbh_hal_chan_request_halt(usbh_hal_chan_t *chan_obj);
+
 /**
  * @brief Get a channel's error
  *
@@ -587,178 +713,74 @@ static inline void usbh_hal_chan_clear_error(usbh_hal_chan_t *chan_obj)
     chan_obj->flags.error_pending = 0;
 }
 
-/* -----------------------------------------------------------------------------
--------------------------- Transfer Descriptor List ----------------------------
-------------------------------------------------------------------------------*/
+// -------------------------------------------- Transfer Descriptor List -----------------------------------------------
 
 /**
  * @brief Fill a single entry in a transfer descriptor list
  *
- * - A single entry corresponds to a USB transfer in a particular direction
- *   (e.g., a BULK OUT).
- * - The channel will automatically split the transfer into multiple MPS sized
- *   packets of the endpoint.
- * - For multi direction transfers (such as the various stages of a control transfer),
- *   the direction and PID of channel must be managed manually. Set the
- *   USBH_HAL_XFER_DESC_FLAG_HALT flag to halt on each entry to flip the direction
- *   and PID of the channel.
- * - For IN transfer entries, set the USBH_HAL_XFER_DESC_FLAG_IN. The transfer
- *   size must also be an integer multiple of the endpoint's MPS
- *
- * @note The USBH_HAL_XFER_DESC_FLAG_HALT must be set on the last descriptor of
- *       the list so that an interrupt is generated at the end of the list
- * @note The USBH_HAL_XFER_DESC_FLAG_HALT can be set on every descriptor if users
- *       prefer to manually step through the list (such as change EP directions in between)
+ * - Depending on the transfer type, a single transfer descriptor may corresponds
+ *      - A stage of a transfer (for control transfers)
+ *      - A frame of a transfer interval (for interrupt and isoc)
+ *      - An entire transfer (for bulk transfers)
+ * - Check the various USBH_HAL_XFER_DESC_FLAG_ flags for filling a specific type of descriptor
+ * - For IN transfer entries, set the USBH_HAL_XFER_DESC_FLAG_IN. The transfer size must also be an integer multiple of
+ *   the endpoint's MPS
+ *
  * @note Critical section is not required for this function
  *
- * @param xfer_desc_list Transfer descriptor list
- * @param xfer_desc_idx Transfer descriptor index
+ * @param desc_list Transfer descriptor list
+ * @param desc_idx Transfer descriptor index
  * @param xfer_data_buff Transfer data buffer
  * @param xfer_len Transfer length
  * @param flags Transfer flags
  */
-static inline void usbh_hal_xfer_desc_fill(void *xfer_desc_list, int xfer_desc_idx, uint8_t *xfer_data_buff, int xfer_len, uint32_t flags)
+static inline void usbh_hal_xfer_desc_fill(void *desc_list, uint32_t desc_idx, uint8_t *xfer_data_buff, int xfer_len, uint32_t flags)
 {
-    //Check if the channel should be halted on completion of this xfer descriptor
-    bool halt_on_xfer_cplt = flags & USBH_HAL_XFER_DESC_FLAG_HALT;
-    usbh_ll_dma_qtd_t *qtd_list = (usbh_ll_dma_qtd_t *)xfer_desc_list;
-    if (flags & USBH_HAL_XFER_DESC_FLAG_NULL) {
-        usbh_ll_set_qtd_null(&qtd_list[xfer_desc_idx]);
-    } else if (flags & USBH_HAL_XFER_DESC_FLAG_IN) {
-        usbh_ll_set_qtd_in(&qtd_list[xfer_desc_idx], xfer_data_buff, xfer_len, halt_on_xfer_cplt);
+    usbh_ll_dma_qtd_t *qtd_list = (usbh_ll_dma_qtd_t *)desc_list;
+    if (flags & USBH_HAL_XFER_DESC_FLAG_IN) {
+        usbh_ll_set_qtd_in(&qtd_list[desc_idx],
+                           xfer_data_buff, xfer_len,
+                           flags & USBH_HAL_XFER_DESC_FLAG_HOC);
     } else {
-        usbh_ll_set_qtd_out(&qtd_list[xfer_desc_idx], xfer_data_buff, xfer_len, halt_on_xfer_cplt, (flags & USBH_HAL_XFER_DESC_FLAG_SETUP));
+        usbh_ll_set_qtd_out(&qtd_list[desc_idx],
+                            xfer_data_buff,
+                            xfer_len,
+                            flags & USBH_HAL_XFER_DESC_FLAG_HOC,
+                            flags & USBH_HAL_XFER_DESC_FLAG_SETUP);
     }
 }
 
 /**
- * @brief Parse a transfer decriptors results
- *
- * @param xfer_desc_list Transfer descriptor list
- * @param xfer_desc_idx Transfer descriptor index
- * @param[out] xfer_rem_len Remaining length of the transfer in bytes
- * @param[out] xfer_status Status of the transfer
- *
- * @note Critical section is not required for this function
- */
-static inline void usbh_hal_xfer_desc_parse(void *xfer_desc_list, int xfer_desc_idx, int *xfer_rem_len, int *xfer_status)
-{
-    usbh_ll_dma_qtd_t *qtd_list = (usbh_ll_dma_qtd_t *)xfer_desc_list;
-    usbh_ll_get_qtd_status(&qtd_list[xfer_desc_idx], xfer_rem_len, xfer_status);
-}
-
-/* -----------------------------------------------------------------------------
--------------------------------- Channel Slot ----------------------------------
-------------------------------------------------------------------------------*/
-
-/**
- * @brief Acquire a slot
- *
- * Acquiring a channel's transfer descriptor list slot will cause a give ownership
- * of the channel to the acquirer. The transfer descriptor list to be executed
- * when the channel is activated.
- *
- * @param chan_obj Channel object
- * @param xfer_desc_list A filled transfer descriptor list
- * @param desc_list_len Length of the descriptor list
- * @param owner_ctx Context variable of the owner
- */
-static inline void usbh_hal_chan_slot_acquire(usbh_hal_chan_t *chan_obj, void *xfer_desc_list, int desc_list_len, void *owner_ctx)
-{
-    assert(!chan_obj->slot.flags.slot_acquired);
-    chan_obj->slot.xfer_desc_list = (usbh_ll_dma_qtd_t *)xfer_desc_list;
-    chan_obj->slot.owner_ctx = owner_ctx;
-    chan_obj->slot.flags.cur_qtd_idx = 0;   //Start from the first descriptor
-    chan_obj->slot.flags.qtd_list_len = desc_list_len;
-    chan_obj->slot.flags.slot_acquired = 1;
-    //Store the descriptor list length in the HCTSIZ register. Address of desc list is set when channel is activated
-    usbh_ll_chan_set_qtd_list_len(chan_obj->regs, desc_list_len);
-}
-
-/**
- * @brief Get current owner of a slot
- *
- * This function reqturns a slot's context variable that was set when the slot
- * was acquired
- *
- * @param chan_obj Channel object
- * @return void* Context variable of the owner of the slot
- */
-static inline void *usbh_hal_chan_slot_get_owner(usbh_hal_chan_t *chan_obj)
-{
-    assert(chan_obj->slot.flags.slot_acquired);
-    return chan_obj->slot.owner_ctx;
-}
-
-/**
- * @brief Release a slot
+ * @brief Clear a transfer descriptor (sets all its fields to NULL)
  *
- * @note This should only be called after confirming that the transfer descriptor
- *       list has completed execution.
- * @note Users should parse the completed transfer descriptor list to check the
- *       results of each transfer.
- *
- * @param[in] chan_obj Channel object
- * @param[out] xfer_desc_list A completed transfer descriptor list
- * @param[out] desc_list_len Length of the descriptor list
+ * @param desc_list Transfer descriptor list
+ * @param desc_idx Transfer descriptor index
  */
-static inline void usbh_hal_chan_slot_release(usbh_hal_chan_t *chan_obj, void **xfer_desc_list, int *desc_list_len)
+static inline void usbh_hal_xfer_desc_clear(void *desc_list, uint32_t desc_idx)
 {
-    assert(chan_obj->slot.flags.slot_acquired);
-    *xfer_desc_list = (void *)chan_obj->slot.xfer_desc_list;
-    *desc_list_len = chan_obj->slot.flags.qtd_list_len;
-    chan_obj->slot.flags.slot_acquired = 0;
+    usbh_ll_dma_qtd_t *qtd_list = (usbh_ll_dma_qtd_t *)desc_list;
+    usbh_ll_set_qtd_null(&qtd_list[desc_idx]);
 }
 
 /**
- * @brief Activate a channel
- *
- * Activating a channel will cause it to start executing the transfer descriptor
- * list in its slot starting from its next descriptor index. When a transfer
- * descriptor completes execution and has the HALT flag set, an event will be
- * generated.
- *
- * @param chan_obj Channel object
- * @param num_to_skip Number of transfer descriptors to skip over
- */
-void usbh_hal_chan_activate(usbh_hal_chan_t *chan_obj, int num_to_skip);
-
-/**
- * @brief Get next transfer descriptor index
+ * @brief Parse a transfer decriptor's results
  *
- * This function returns the index of the next descriptor that will be executed
- * in the transfer descriptor list.
+ * @param desc_list Transfer descriptor list
+ * @param desc_idx Transfer descriptor index
+ * @param[out] xfer_rem_len Remaining length of the transfer in bytes
+ * @param[out] xfer_status Status of the transfer
  *
- * @param chan_obj Channel object
- * @return int Descriptor index
+ * @note Critical section is not required for this function
  */
-static inline int usbh_hal_chan_get_next_desc_index(usbh_hal_chan_t *chan_obj)
+static inline void usbh_hal_xfer_desc_parse(void *desc_list, uint32_t desc_idx, int *xfer_rem_len, int *xfer_status)
 {
-    return chan_obj->slot.flags.cur_qtd_idx;
+    usbh_ll_dma_qtd_t *qtd_list = (usbh_ll_dma_qtd_t *)desc_list;
+    usbh_ll_get_qtd_status(&qtd_list[desc_idx], xfer_rem_len, xfer_status);
+    //Clear the QTD to prevent it from being read again
+    usbh_ll_set_qtd_null(&qtd_list[desc_idx]);
 }
 
-/**
- * @brief Request to halt a channel
- *
- * This function should be called in order to halt a channel. If the channel is
- * already halted, this function will return true. If the channel is still
- * active, this function will return false and users must wait for the
- * USBH_HAL_CHAN_EVENT_HALT_REQ event before treating the channel as halted.
- *
- * @note When a transfer is in progress (i.e., the channel is active) and a halt
- *       is requested, the channel will halt after the next USB packet is completed.
- *       If the transfer has more pending packets, the transfer will just be
- *       marked as USBH_HAL_XFER_DESC_STS_NOT_EXECUTED.
- *
- * @param chan_obj Channel object
- * @return true The channel is already halted
- * @return false The halt was requested, wait for USBH_HAL_CHAN_EVENT_HALT_REQ
- */
-bool usbh_hal_chan_slot_request_halt(usbh_hal_chan_t *chan_obj);
-
-/* -----------------------------------------------------------------------------
--------------------------------- Event Handling --------------------------------
------------------------------------------------------------------------------ */
+// ------------------------------------------------- Event Handling ----------------------------------------------------
 
 /**
  * @brief Decode global and host port interrupts
@@ -776,13 +798,8 @@ usbh_hal_port_event_t usbh_hal_decode_intr(usbh_hal_context_t *hal);
 /**
  * @brief Gets the next channel with a pending interrupt
  *
- * If no channel is pending an interrupt, this function will return NULL. If one
- * or more channels are pending an interrupt, this function returns one of the
- * channel's objects. Call this function repeatedly until it returns NULL.
- *
- * @note If a channel error event occurs, or a Slot halt/done event occurs, the
- *       channel is immediately halted and no further channel interrupt or errors
- *       can occur until it is reactivated.
+ * If no channel is pending an interrupt, this function will return NULL. If one or more channels are pending an
+ * interrupt, this function returns one of the channel's objects. Call this function repeatedly until it returns NULL.
  *
  * @param hal Context of the HAL layer
  * @return usbh_hal_chan_t* Channel object. NULL if no channel are pending an interrupt.
diff --git a/components/hal/esp32s2/include/hal/usbh_ll.h b/components/hal/esp32s2/include/hal/usbh_ll.h
index 6e7a9a0695..dcab42c0a4 100644
--- a/components/hal/esp32s2/include/hal/usbh_ll.h
+++ b/components/hal/esp32s2/include/hal/usbh_ll.h
@@ -159,16 +159,6 @@ typedef struct {
     uint8_t *buffer;
 } usbh_ll_dma_qtd_t;
 
-/*
- * Enumeration of different possible lengths of the periodic frame list
- */
-typedef enum {
-    USBH_LL_FRAME_LIST_LEN_8 = 0,
-    USBH_LL_FRAME_LIST_LEN_16,
-    USBH_LL_FRAME_LIST_LEN_32,
-    USBH_LL_FRAME_LIST_LEN_64,
-} usbh_ll_frame_list_len_t;
-
 /* -----------------------------------------------------------------------------
 ------------------------------ USB Wrap Registers ------------------------------
 ----------------------------------------------------------------------------- */
@@ -249,18 +239,33 @@ static inline bool usb_ll_check_dma_req_in_progress(usbh_dev_t *hw)
     return hw->grstctl_reg.dmareq;
 }
 
-static inline void usb_ll_flush_tx_fifo(usbh_dev_t *hw, uint32_t chan_num)
+static inline void usb_ll_flush_nptx_fifo(usbh_dev_t *hw)
+{
+    hw->grstctl_reg.txfnum = 0;     //Set the TX FIFO number to 0 to select the non-periodic TX FIFO
+    hw->grstctl_reg.txfflsh = 1;    //Flush the selected TX FIFO
+    //Wait for the flushing to complete
+    while (hw->grstctl_reg.txfflsh) {
+        ;
+    }
+}
+
+static inline void usb_ll_flush_ptx_fifo(usbh_dev_t *hw)
 {
-    usb_grstctl_reg_t grstctl;
-    grstctl.val = hw->grstctl_reg.val;
-    grstctl.txfnum = chan_num;      //Set channel number to flush
-    grstctl.txfflsh = 1;            //Flush that channel's TX FIFO
-    hw->grstctl_reg.val = grstctl.val;
+    hw->grstctl_reg.txfnum = 1;     //Set the TX FIFO number to 1 to select the periodic TX FIFO
+    hw->grstctl_reg.txfflsh = 1;    //FLush the select TX FIFO
+    //Wait for the flushing to complete
+    while (hw->grstctl_reg.txfflsh) {
+        ;
+    }
 }
 
 static inline void usb_ll_flush_rx_fifo(usbh_dev_t *hw)
 {
     hw->grstctl_reg.rxfflsh = 1;
+    //Wait for the flushing to complete
+    while (hw->grstctl_reg.rxfflsh) {
+        ;
+    }
 }
 
 static inline void usb_ll_reset_frame_counter(usbh_dev_t *hw)
@@ -320,20 +325,20 @@ static inline void usb_ll_dis_intrs(usbh_dev_t *hw, uint32_t intr_mask)
 
 // --------------------------- GRXFSIZ Register --------------------------------
 
-static inline void usb_ll_set_rx_fifo_size(usbh_dev_t *hw, uint32_t size)
+static inline void usb_ll_set_rx_fifo_size(usbh_dev_t *hw, uint32_t num_lines)
 {
     //Set size in words
-    hw->grxfsiz_reg.rxfdep = size;
+    hw->grxfsiz_reg.rxfdep = num_lines;
 }
 
 // -------------------------- GNPTXFSIZ Register -------------------------------
 
-static inline void usb_ll_set_nptx_fifo_size(usbh_dev_t *hw, uint32_t addr, uint32_t size)
+static inline void usb_ll_set_nptx_fifo_size(usbh_dev_t *hw, uint32_t addr, uint32_t num_lines)
 {
     usb_gnptxfsiz_reg_t gnptxfsiz;
     gnptxfsiz.val = hw->gnptxfsiz_reg.val;
     gnptxfsiz.nptxfstaddr = addr;
-    gnptxfsiz.nptxfdep = size;
+    gnptxfsiz.nptxfdep = num_lines;
     hw->gnptxfsiz_reg.val = gnptxfsiz.val;
 }
 
@@ -364,12 +369,12 @@ static inline void usb_ll_get_hardware_config(usbh_dev_t *hw, uint32_t *ghwcfg1,
 
 // --------------------------- HPTXFSIZ Register -------------------------------
 
-static inline void usbh_ll_set_ptx_fifo_size(usbh_dev_t *hw, uint32_t addr, uint32_t size)
+static inline void usbh_ll_set_ptx_fifo_size(usbh_dev_t *hw, uint32_t addr, uint32_t num_lines)
 {
     usb_hptxfsiz_reg_t hptxfsiz;
     hptxfsiz.val = hw->hptxfsiz_reg.val;
     hptxfsiz.ptxfstaddr = addr;
-    hptxfsiz.ptxfsize = size;
+    hptxfsiz.ptxfsize = num_lines;
     hw->hptxfsiz_reg.val = hptxfsiz.val;
 }
 
@@ -394,9 +399,24 @@ static inline void usbh_ll_hcfg_dis_perio_sched(usbh_dev_t *hw)
  *
  * @param num_entires Number of entires in the frame list
  */
-static inline void usbh_ll_hcfg_set_num_frame_list_entries(usbh_dev_t *hw, usbh_ll_frame_list_len_t num_entries)
+static inline void usbh_ll_hcfg_set_num_frame_list_entries(usbh_dev_t *hw, usb_hal_frame_list_len_t num_entries)
 {
-    hw->hcfg_reg.frlisten = num_entries;
+    uint32_t frlisten;
+    switch (num_entries) {
+        case USB_HAL_FRAME_LIST_LEN_8:
+            frlisten = 0;
+            break;
+        case USB_HAL_FRAME_LIST_LEN_16:
+            frlisten = 1;
+            break;
+        case USB_HAL_FRAME_LIST_LEN_32:
+            frlisten = 2;
+            break;
+        default: //USB_HAL_FRAME_LIST_LEN_64
+            frlisten = 3;
+            break;
+    }
+    hw->hcfg_reg.frlisten = frlisten;
 }
 
 static inline void usbh_ll_hcfg_en_scatt_gatt_dma(usbh_dev_t *hw)
@@ -417,7 +437,8 @@ static inline void usbh_ll_hcfg_set_fsls_pclk_sel(usbh_dev_t *hw)
 /**
  * @brief Sets some default values to HCFG to operate in Host mode with scatter/gather DMA
  *
- * @param hw
+ * @param hw Start address of the USB Wrap registers
+ * @param speed Speed to initialize the host port at
  */
 static inline void usbh_ll_hcfg_set_defaults(usbh_dev_t *hw, usb_priv_speed_t speed)
 {
@@ -498,11 +519,27 @@ static inline void usbh_ll_haintmsk_dis_chan_intr(usbh_dev_t *hw, uint32_t mask)
 
 // --------------------------- HFLBAddr Register -------------------------------
 
+/**
+ * @brief Set the base address of the scheduling frame list
+ *
+ * @note For some reason, this address must be 512 bytes aligned or else a bunch of frames will not be scheduled when
+ *       the frame list rolls over. However, according to the databook, there is no mention of the HFLBAddr needing to
+ *       be aligned.
+ *
+ * @param hw Start address of the DWC_OTG registers
+ * @param addr Base address of the scheduling frame list
+ */
 static inline void usbh_ll_set_frame_list_base_addr(usbh_dev_t *hw, uint32_t addr)
 {
     hw->hflbaddr_reg.hflbaddr = addr;
 }
 
+/**
+ * @brief Get the base address of the scheduling frame list
+ *
+ * @param hw Start address of the DWC_OTG registers
+ * @return uint32_t Base address of the scheduling frame list
+ */
 static inline uint32_t usbh_ll_get_frame_list_base_addr(usbh_dev_t *hw)
 {
     return hw->hflbaddr_reg.hflbaddr;
@@ -529,6 +566,7 @@ static inline uint32_t usbh_ll_hprt_get_test_ctl(usbh_dev_t *hw)
 {
     return hw->hprt_reg.prttstctl;
 }
+
 static inline void usbh_ll_hprt_set_test_ctl(usbh_dev_t *hw, uint32_t test_mode)
 {
     usb_hprt_reg_t hprt;
@@ -604,6 +642,7 @@ static inline bool usbh_ll_hprt_get_port_resume(usbh_dev_t *hw)
 {
     return hw->hprt_reg.prtres;
 }
+
 static inline bool usbh_ll_hprt_get_port_overcur(usbh_dev_t *hw)
 {
     return hw->hprt_reg.prtovrcurract;
@@ -780,9 +819,7 @@ static inline void usbh_ll_chan_set_dma_addr_non_iso(volatile usb_host_chan_regs
 
 static inline void usbh_ll_chan_set_dma_addr_iso(volatile usb_host_chan_regs_t *chan,
                                                 void *dmaaddr,
-                                                uint32_t ntd,
-                                                uint32_t pktcnt,
-                                                uint32_t ctd)
+                                                uint32_t ntd)
 {
     int n;
     if (ntd == 2) {
@@ -861,15 +898,15 @@ static inline usb_host_chan_regs_t *usbh_ll_get_chan_regs(usbh_dev_t *dev, int c
  * @param data_buff Pointer to buffer containing the data to transfer
  * @param xfer_len Number of bytes in transfer. Setting 0 will do a zero length IN transfer.
  *                 Non zero length must be mulitple of the endpoint's MPS.
- * @param halt_on_cplt Generate a channel halted interrupt on completion of QTD
+ * @param hoc Halt on complete (will generate an interrupt and halt the channel)
  */
-static inline void usbh_ll_set_qtd_in(usbh_ll_dma_qtd_t *qtd, uint8_t *data_buff, int xfer_len, bool halt_on_cplt)
+static inline void usbh_ll_set_qtd_in(usbh_ll_dma_qtd_t *qtd, uint8_t *data_buff, int xfer_len, bool hoc)
 {
     qtd->buffer = data_buff;        //Set pointer to data buffer
     qtd->buffer_status_val = 0;     //Reset all flags to zero
     qtd->in_non_iso.xfer_size = xfer_len;
-    if (halt_on_cplt) {
-        qtd->in_non_iso.intr_cplt = 1;  //Used to indicate successful completion
+    if (hoc) {
+        qtd->in_non_iso.intr_cplt = 1;  //We need to set this to distinguish between a halt due to a QTD
         qtd->in_non_iso.eol = 1;        //Used to halt the channel at this qtd
     }
     qtd->in_non_iso.active = 1;
@@ -882,11 +919,11 @@ static inline void usbh_ll_set_qtd_in(usbh_ll_dma_qtd_t *qtd, uint8_t *data_buff
  * @param data_buff Pointer to buffer containing the data to transfer
  * @param xfer_len Number of bytes to transfer. Setting 0 will do a zero length transfer.
  *                 For ctrl setup packets, this should be set to 8.
- * @param halt_on_cplt Generate a channel halted interrupt on completion of QTD.
+ * @param hoc Halt on complete (will generate an interrupt)
  * @param is_setup Indicates whether this is a control transfer setup packet or a normal OUT Data transfer.
  *                 (As per the USB protocol, setup packets cannot be STALLd or NAKd by the device)
  */
-static inline void usbh_ll_set_qtd_out(usbh_ll_dma_qtd_t *qtd, uint8_t *data_buff, int xfer_len, bool halt_on_cplt, bool is_setup)
+static inline void usbh_ll_set_qtd_out(usbh_ll_dma_qtd_t *qtd, uint8_t *data_buff, int xfer_len, bool hoc, bool is_setup)
 {
     qtd->buffer = data_buff;        //Set pointer to data buffer
     qtd->buffer_status_val = 0;     //Reset all flags to zero
@@ -894,9 +931,9 @@ static inline void usbh_ll_set_qtd_out(usbh_ll_dma_qtd_t *qtd, uint8_t *data_buf
     if (is_setup) {
         qtd->out_non_iso.is_setup = 1;
     }
-    if (halt_on_cplt) {
-        qtd->out_non_iso.intr_cplt = 1;  //Used to indicate successful completion
-        qtd->out_non_iso.eol = 1;        //Used to halt the channel at this qtd
+    if (hoc) {
+        qtd->in_non_iso.intr_cplt = 1;  //We need to set this to distinguish between a halt due to a QTD
+        qtd->in_non_iso.eol = 1;        //Used to halt the channel at this qtd
     }
     qtd->out_non_iso.active = 1;
 }
diff --git a/components/hal/esp32s2/usbh_hal.c b/components/hal/esp32s2/usbh_hal.c
index a24f965ef4..f1aaaabcb3 100644
--- a/components/hal/esp32s2/usbh_hal.c
+++ b/components/hal/esp32s2/usbh_hal.c
@@ -19,11 +19,9 @@
 #include "hal/usbh_hal.h"
 #include "hal/usbh_ll.h"
 
-/* -----------------------------------------------------------------------------
-------------------------------- Macros and Types -------------------------------
------------------------------------------------------------------------------ */
+// ------------------------------------------------ Macros and Types ---------------------------------------------------
 
-// -------------------------------- Constants ----------------------------------
+// ---------------------- Constants ------------------------
 
 #define BENDPOINTADDRESS_NUM_MSK     0x0F   //Endpoint number mask of the bEndpointAddress field of an endpoint descriptor
 #define BENDPOINTADDRESS_DIR_MSK     0x80   //Endpoint direction mask of the bEndpointAddress field of an endpoint descriptor
@@ -34,32 +32,7 @@
 #define CORE_REG_GHWCFG3    0x00C804B5
 #define CORE_REG_GHWCFG4    0xD3F0A030
 
-// ------------------------------ Configurable ---------------------------------
-
-#define CHAN_MAX_SLOTS      16
-
-/*
-FIFO lengths configured as follows:
-
-RXFIFO (Receive FIFO)
- - Recommended: (((LPS/4) + 2) * NUM_PACKETS)  + (NUM_CHAN * 2) + (NUM_BULK_CTRL * 1)
- - Actual: Assume (LPS = 64), (NUM_CHAN = 8), (NUM_BULK_CTRL = 8):
-NPTXFIFO (Non-periodic TX FIFO)
- - Recommended: (((LPS/4) + 2) * 2) Fit two largest packet sizes (and each packets overhead info)
- - Actual: Assume LPS is 64 (is the MPS for CTRL/BULK/INTR in FS)
-PTXFIFO (Periodic TX FIFO)
- - Recommended: ((LPS/4) + 2) * NUM_PACKETS
- - Actual: Assume a single LPS of 64 (quarter of ISO MPS), then 2 packets worth of overhead
-REGFIFO (Register storage)
- - Recommended: 4 * NUM_CHAN
- - Actual: Assume NUM_CHAN is 8
-*/
-#define HW_FIFO_LEN         256
-#define RX_FIFO_LEN         92
-#define NPTX_FIFO_LEN       36
-#define PTX_FIFO_LEN        72
-#define REG_FIFO_LEN        32
-_Static_assert((RX_FIFO_LEN + NPTX_FIFO_LEN + PTX_FIFO_LEN + REG_FIFO_LEN) <= HW_FIFO_LEN, "Sum of FIFO lengths not equal to HW_FIFO_LEN");
+// -------------------- Configurable -----------------------
 
 /**
  * The following core interrupts will be enabled (listed LSB to MSB). Some of these
@@ -114,18 +87,14 @@ _Static_assert((RX_FIFO_LEN + NPTX_FIFO_LEN + PTX_FIFO_LEN + REG_FIFO_LEN) <= HW
                                USBH_LL_INTR_CHAN_BNAINTR | \
                                USBH_LL_INTR_CHAN_XCS_XACT_ERR)
 
-/* -----------------------------------------------------------------------------
---------------------------------- Core (Global) --------------------------------
------------------------------------------------------------------------------ */
-
-// ---------------------------- Private Functions ------------------------------
+// -------------------------------------------------- Core (Global) ----------------------------------------------------
 
 static void set_defaults(usbh_hal_context_t *hal)
 {
     usbh_ll_internal_phy_conf(hal->wrap_dev);   //Enable and configure internal PHY
     //GAHBCFG register
     usb_ll_en_dma_mode(hal->dev);
-    usb_ll_set_hbstlen(hal->dev, 0);    //INCR16 AHB burst length
+    usb_ll_set_hbstlen(hal->dev, 1);    //Use INCR AHB burst. MUST DO SO IN ESP32-S2 DUE TO ARBITER ERRATA.
     //GUSBCFG register
     usb_ll_dis_hnp_cap(hal->dev);       //Disable HNP
     usb_ll_dis_srp_cap(hal->dev);       //Disable SRP
@@ -138,16 +107,13 @@ static void set_defaults(usbh_hal_context_t *hal)
     usb_ll_set_host_mode(hal->dev);
 }
 
-// ---------------------------- Public Functions -------------------------------
-
 void usbh_hal_init(usbh_hal_context_t *hal)
 {
     //Check if a peripheral is alive by reading the core ID registers
     usbh_dev_t *dev = &USBH;
-#ifndef NDEBUG
     uint32_t core_id = usb_ll_get_controller_core_id(dev);
     assert(core_id == CORE_REG_GSNPSID);
-#endif
+    (void) core_id;     //Suppress unused variable warning if asserts are disabled
     //Initialize HAL context
     memset(hal, 0, sizeof(usbh_hal_context_t));
     hal->dev = dev;
@@ -177,15 +143,34 @@ void usbh_hal_core_soft_reset(usbh_hal_context_t *hal)
     //Set the default bits
     set_defaults(hal);
     //Clear all the flags and channels
+    hal->periodic_frame_list = NULL;
     hal->flags.val = 0;
     hal->channels.num_allocd = 0;
     hal->channels.chan_pend_intrs_msk = 0;
     memset(hal->channels.hdls, 0, sizeof(usbh_hal_chan_t *) * USBH_HAL_NUM_CHAN);
 }
 
-/* -----------------------------------------------------------------------------
----------------------------------- Host Port ----------------------------------
------------------------------------------------------------------------------ */
+void usbh_hal_set_fifo_size(usbh_hal_context_t *hal, const usbh_hal_fifo_config_t *fifo_config)
+{
+    assert((fifo_config->rx_fifo_lines + fifo_config->nptx_fifo_lines + fifo_config->ptx_fifo_lines) <= USBH_HAL_FIFO_TOTAL_USABLE_LINES);
+    //Check that none of the channels are active
+    for (int i = 0; i < USBH_HAL_NUM_CHAN; i++) {
+        if (hal->channels.hdls[i] != NULL) {
+            assert(!hal->channels.hdls[i]->flags.active);
+        }
+    }
+    //Set the new FIFO lengths
+    usb_ll_set_rx_fifo_size(hal->dev, fifo_config->rx_fifo_lines);
+    usb_ll_set_nptx_fifo_size(hal->dev, fifo_config->rx_fifo_lines, fifo_config->nptx_fifo_lines);
+    usbh_ll_set_ptx_fifo_size(hal->dev, fifo_config->rx_fifo_lines + fifo_config->nptx_fifo_lines, fifo_config->ptx_fifo_lines);
+    //Flush the FIFOs
+    usb_ll_flush_nptx_fifo(hal->dev);
+    usb_ll_flush_ptx_fifo(hal->dev);
+    usb_ll_flush_rx_fifo(hal->dev);
+    hal->flags.fifo_sizes_set = 1;
+}
+
+// ---------------------------------------------------- Host Port ------------------------------------------------------
 
 static inline void debounce_lock_enable(usbh_hal_context_t *hal)
 {
@@ -199,24 +184,17 @@ void usbh_hal_port_enable(usbh_hal_context_t *hal)
     usb_priv_speed_t speed = usbh_ll_hprt_get_speed(hal->dev);
     //Host Configuration
     usbh_ll_hcfg_set_defaults(hal->dev, speed);
-    //Todo: Set frame list entries and ena per sched
     //Configure HFIR
     usbh_ll_hfir_set_defaults(hal->dev, speed);
-    //Config FIFO sizes
-    usb_ll_set_rx_fifo_size(hal->dev, RX_FIFO_LEN);
-    usb_ll_set_nptx_fifo_size(hal->dev, RX_FIFO_LEN, NPTX_FIFO_LEN);
-    usbh_ll_set_ptx_fifo_size(hal->dev, RX_FIFO_LEN + NPTX_FIFO_LEN, PTX_FIFO_LEN);
 }
 
-/* -----------------------------------------------------------------------------
------------------------------------ Channel ------------------------------------
-------------------------------------------------------------------------------*/
+// ----------------------------------------------------- Channel -------------------------------------------------------
 
-// --------------------------- Channel Allocation ------------------------------
+// ----------------- Channel Allocation --------------------
 
-//Allocate a channel
 bool usbh_hal_chan_alloc(usbh_hal_context_t *hal, usbh_hal_chan_t *chan_obj, void *chan_ctx)
 {
+    assert(hal->flags.fifo_sizes_set);  //FIFO sizes should be set befor attempting to allocate a channel
     //Attempt to allocate channel
     if (hal->channels.num_allocd == USBH_HAL_NUM_CHAN) {
         return false;    //Out of free channels
@@ -246,22 +224,25 @@ bool usbh_hal_chan_alloc(usbh_hal_context_t *hal, usbh_hal_chan_t *chan_obj, voi
     return true;
 }
 
-//Returns object memory
 void usbh_hal_chan_free(usbh_hal_context_t *hal, usbh_hal_chan_t *chan_obj)
 {
+    if (chan_obj->flags.type == USB_PRIV_XFER_TYPE_INTR || chan_obj->flags.type == USB_PRIV_XFER_TYPE_ISOCHRONOUS) {
+        //Unschedule this channel
+        for (int i = 0; i < hal->flags.frame_list_len; i++) {
+            hal->periodic_frame_list[i] &= ~(1 << chan_obj->flags.chan_idx);
+        }
+    }
     //Can only free a channel when in the disabled state and descriptor list released
-    assert(!chan_obj->slot.flags.slot_acquired
-           && !chan_obj->flags.active
-           && !chan_obj->flags.error_pending);
+    assert(!chan_obj->flags.active && !chan_obj->flags.error_pending);
     //Deallocate channel
     hal->channels.hdls[chan_obj->flags.chan_idx] = NULL;
     hal->channels.num_allocd--;
     assert(hal->channels.num_allocd >= 0);
 }
 
-// ---------------------------- Channel Control --------------------------------
+// ---------------- Channel Configuration ------------------
 
-void usbh_hal_chan_set_ep_char(usbh_hal_chan_t *chan_obj, usbh_hal_ep_char_t *ep_char)
+void usbh_hal_chan_set_ep_char(usbh_hal_context_t *hal, usbh_hal_chan_t *chan_obj, usbh_hal_ep_char_t *ep_char)
 {
     //Cannot change ep_char whilst channel is still active or in error
     assert(!chan_obj->flags.active && !chan_obj->flags.error_pending);
@@ -273,29 +254,34 @@ void usbh_hal_chan_set_ep_char(usbh_hal_chan_t *chan_obj, usbh_hal_ep_char_t *ep
                              ep_char->type,
                              ep_char->bEndpointAddress & BENDPOINTADDRESS_DIR_MSK,
                              ep_char->ls_via_fs_hub);
+    //Save channel type
+    chan_obj->flags.type = ep_char->type;
+    //If this is a periodic endpoint/channel, set its schedule in the frame list
+    if (ep_char->type == USB_PRIV_XFER_TYPE_ISOCHRONOUS || ep_char->type == USB_PRIV_XFER_TYPE_INTR) {
+        assert((int)ep_char->periodic.interval <= (int)hal->flags.frame_list_len);    //Interval cannot exceed the length of the frame list
+        //Find the effective offset in the frame list (in case the phase_offset_frames > interval)
+        int offset = ep_char->periodic.phase_offset_frames % ep_char->periodic.interval;
+        //Schedule the channel in the frame list
+        for (int i = offset; i < hal->flags.frame_list_len; i+= ep_char->periodic.interval) {
+            hal->periodic_frame_list[i] |= 1 << chan_obj->flags.chan_idx;
+        }
+    }
 }
 
-/* -----------------------------------------------------------------------------
-------------------------------- Transfers Slots --------------------------------
-------------------------------------------------------------------------------*/
+// ------------------- Channel Control ---------------------
 
-void usbh_hal_chan_activate(usbh_hal_chan_t *chan_obj, int num_to_skip)
+void usbh_hal_chan_activate(usbh_hal_chan_t *chan_obj, void *xfer_desc_list, int desc_list_len, int start_idx)
 {
-    //Cannot enable a channel that has already been enabled or is pending error handling
+    //Cannot activate a channel that has already been enabled or is pending error handling
     assert(!chan_obj->flags.active && !chan_obj->flags.error_pending);
-    assert(chan_obj->slot.flags.slot_acquired);
-    //Update the descriptor list index and check if it's within bounds
-    chan_obj->slot.flags.cur_qtd_idx += num_to_skip;
-    assert(chan_obj->slot.flags.cur_qtd_idx < chan_obj->slot.flags.qtd_list_len);
-    chan_obj->flags.active = 1;
-
     //Set start address of the QTD list and starting QTD index
-    usbh_ll_chan_set_dma_addr_non_iso(chan_obj->regs, chan_obj->slot.xfer_desc_list, chan_obj->slot.flags.cur_qtd_idx);
-    //Start the channel
-    usbh_ll_chan_start(chan_obj->regs);
+    usbh_ll_chan_set_dma_addr_non_iso(chan_obj->regs, xfer_desc_list, start_idx);
+    usbh_ll_chan_set_qtd_list_len(chan_obj->regs, desc_list_len);
+    usbh_ll_chan_start(chan_obj->regs); //Start the channel
+    chan_obj->flags.active = 1;
 }
 
-bool usbh_hal_chan_slot_request_halt(usbh_hal_chan_t *chan_obj)
+bool usbh_hal_chan_request_halt(usbh_hal_chan_t *chan_obj)
 {
     //Cannot request halt on a channel that is pending error handling
     assert(!chan_obj->flags.error_pending);
@@ -307,9 +293,7 @@ bool usbh_hal_chan_slot_request_halt(usbh_hal_chan_t *chan_obj)
     return true;
 }
 
-/* -----------------------------------------------------------------------------
--------------------------------- Event Handling --------------------------------
------------------------------------------------------------------------------ */
+// ------------------------------------------------- Event Handling ----------------------------------------------------
 
 //When a device on the port is no longer valid (e.g., disconnect, port error). All channels are no longer valid
 static void chan_all_halt(usbh_hal_context_t *hal)
@@ -386,12 +370,9 @@ usbh_hal_chan_event_t usbh_hal_chan_decode_intr(usbh_hal_chan_t *chan_obj)
 {
     uint32_t chan_intrs = usbh_ll_chan_intr_read_and_clear(chan_obj->regs);
     usbh_hal_chan_event_t chan_event;
-    //Currently, all cases where channel interrupts occur will also halt the channel, except for BNA
-    assert(chan_intrs & (USBH_LL_INTR_CHAN_CHHLTD | USBH_LL_INTR_CHAN_BNAINTR));
-    chan_obj->flags.active = 0;
-    //Note: Do not change the current checking order of checks. Certain interrupts (e.g., errors) have precedence over others
-    if (chan_intrs & CHAN_INTRS_ERROR_MSK) {  //One of the error interrupts has occurred.
-        //Note: Errors are uncommon, so we check against the entire interrupt mask to reduce frequency of entering this call path
+
+    if (chan_intrs & CHAN_INTRS_ERROR_MSK) {    //Note: Errors are uncommon, so we check against the entire interrupt mask to reduce frequency of entering this call path
+        assert(chan_intrs & USBH_LL_INTR_CHAN_CHHLTD);  //An error should have halted the channel
         //Store the error in hal context
         usbh_hal_chan_error_t error;
         if (chan_intrs & USBH_LL_INTR_CHAN_STALL) {
@@ -405,25 +386,34 @@ usbh_hal_chan_event_t usbh_hal_chan_decode_intr(usbh_hal_chan_t *chan_obj)
         }
         //Update flags
         chan_obj->error = error;
+        chan_obj->flags.active = 0;
         chan_obj->flags.error_pending = 1;
         //Save the error to be handled later
         chan_event = USBH_HAL_CHAN_EVENT_ERROR;
-    } else if (chan_obj->flags.halt_requested) {    //A halt was previously requested and has not been fulfilled
-        chan_obj->flags.halt_requested = 0;
-        chan_event = USBH_HAL_CHAN_EVENT_HALT_REQ;
-    } else if (chan_intrs & USBH_LL_INTR_CHAN_XFERCOMPL) {
-        int cur_qtd_idx = usbh_ll_chan_get_ctd(chan_obj->regs);
-        //Store current qtd index
-        chan_obj->slot.flags.cur_qtd_idx = cur_qtd_idx;
-        if (cur_qtd_idx == 0) {
-            //If the transfer descriptor list has completed, the CTD index should be 0 (wrapped around)
-            chan_event = USBH_HAL_CHAN_EVENT_SLOT_DONE;
+    } else if (chan_intrs & USBH_LL_INTR_CHAN_CHHLTD) {
+        if (chan_obj->flags.halt_requested) {
+            chan_obj->flags.halt_requested = 0;
+            chan_event = USBH_HAL_CHAN_EVENT_HALT_REQ;
         } else {
-            chan_event = USBH_HAL_CHAN_EVENT_SLOT_HALT;
+            //Must have been halted due to QTD HOC
+            chan_event = USBH_HAL_CHAN_EVENT_CPLT;
         }
+        chan_obj->flags.active = 0;
+    } else if (chan_intrs & USBH_LL_INTR_CHAN_XFERCOMPL) {
+        /*
+        A transfer complete interrupt WITHOUT the channel halting only occurs when receiving a short interrupt IN packet
+        and the underlying QTD does not have the HOC bit set. This signifies the last packet of the Interrupt transfer
+        as all interrupt packets must MPS sized except the last.
+        */
+        //The channel isn't halted yet, so we need to halt it manually to stop the execution of the next QTD/packet
+        usbh_ll_chan_halt(chan_obj->regs);
+        /*
+        After setting the halt bit, this will generate another channel halted interrupt. We treat this interrupt as
+        a NONE event, then cycle back with the channel halted interrupt to handle the CPLT event.
+        */
+        chan_event = USBH_HAL_CHAN_EVENT_NONE;
     } else {
-        //Should never reach this point
-        abort();
+        abort();    //Should never reach this point
     }
     return chan_event;
 }
diff --git a/components/usb/CMakeLists.txt b/components/usb/CMakeLists.txt
index cfaf84d4e1..8d22022222 100644
--- a/components/usb/CMakeLists.txt
+++ b/components/usb/CMakeLists.txt
@@ -7,6 +7,4 @@ endif()
 
 idf_component_register(SRCS "hcd.c"
                     INCLUDE_DIRS ""
-                    PRIV_INCLUDE_DIRS "private_include"
-                    PRIV_REQUIRES "hal"
-                    REQUIRES "")
+                    PRIV_INCLUDE_DIRS "private_include")
diff --git a/components/usb/hcd.c b/components/usb/hcd.c
index 4a2541f842..9dc6c30673 100644
--- a/components/usb/hcd.c
+++ b/components/usb/hcd.c
@@ -12,6 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+#include <stdint.h>
 #include <string.h>
 #include <sys/queue.h>
 #include "freertos/FreeRTOS.h"
@@ -34,29 +35,117 @@
 
 // --------------------- Constants -------------------------
 
+#define INIT_DELAY_MS                           30  //A delay of at least 25ms to enter Host mode. Make it 30ms to be safe
+#define DEBOUNCE_DELAY_MS                       250 //A debounce delay of 250ms
+#define RESET_HOLD_MS                           30  //Spec requires at least 10ms. Make it 30ms to be safe
+#define RESET_RECOVERY_MS                       30  //Reset recovery delay of 10ms (make it 30 ms to be safe) to allow for connected device to recover (and for port enabled interrupt to occur)
+#define RESUME_HOLD_MS                          30  //Spec requires at least 20ms, Make it 30ms to be safe
+#define RESUME_RECOVERY_MS                      20  //Resume recovery of at least 10ms. Make it 20 ms to be safe. This will include the 3 LS bit times of the EOP
+
+#define CTRL_EP_MAX_MPS_LS                      8   //Largest Maximum Packet Size for Low Speed control endpoints
+#define CTRL_EP_MAX_MPS_FS                      64  //Largest Maximum Packet Size for Full Speed control endpoints
+
+#define NUM_PORTS                               1   //The controller only has one port.
+
+// ----------------------- Configs -------------------------
+
+typedef struct {
+    int in_mps;
+    int non_periodic_out_mps;
+    int periodic_out_mps;
+} fifo_mps_limits_t;
+
+/**
+ * @brief Default FIFO sizes (see 2.1.2.4 for programming guide)
+ *
+ * RXFIFO
+ * - Recommended: ((LPS/4) * 2) + 2
+ * - Actual: Whatever leftover size: USBH_HAL_FIFO_TOTAL_USABLE_LINES(200) - 48 - 48 = 104
+ * - Worst case can accommodate two packets of 204 bytes, or one packet of 408
+ * NPTXFIFO
+ * - Recommended: (LPS/4) * 2
+ * - Actual: Assume LPS is 64, and 3 packets: (64/4) * 3 = 48
+ * - Worst case can accommodate three packets of 64 bytes or one packet of 192
+ * PTXFIFO
+ * - Recommended: (LPS/4) * 2
+ * - Actual: Assume LPS is 64, and 3 packets: (64/4) * 3 = 48
+ * - Worst case can accommodate three packets of 64 bytes or one packet of 192
+ */
+const usbh_hal_fifo_config_t fifo_config_default = {
+    .rx_fifo_lines = 104,
+    .nptx_fifo_lines = 48,
+    .ptx_fifo_lines = 48,
+};
+
+const fifo_mps_limits_t mps_limits_default = {
+    .in_mps = 408,
+    .non_periodic_out_mps = 192,
+    .periodic_out_mps = 192,
+};
+
+/**
+ * @brief FIFO sizes that bias to giving RX FIFO more capacity
+ *
+ * RXFIFO
+ * - Recommended: ((LPS/4) * 2) + 2
+ * - Actual: Whatever leftover size: USBH_HAL_FIFO_TOTAL_USABLE_LINES(200) - 32 - 16 = 152
+ * - Worst case can accommodate two packets of 300 bytes or one packet of 600 bytes
+ * NPTXFIFO
+ * - Recommended: (LPS/4) * 2
+ * - Actual: Assume LPS is 64, and 1 packets: (64/4) * 1 = 16
+ * - Worst case can accommodate one packet of 64 bytes
+ * PTXFIFO
+ * - Recommended: (LPS/4) * 2
+ * - Actual: Assume LPS is 64, and 3 packets: (64/4) * 2 = 32
+ * - Worst case can accommodate two packets of 64 bytes or one packet of 128
+ */
+const usbh_hal_fifo_config_t fifo_config_bias_rx = {
+    .rx_fifo_lines = 152,
+    .nptx_fifo_lines = 16,
+    .ptx_fifo_lines = 32,
+};
+
+const fifo_mps_limits_t mps_limits_bias_rx = {
+    .in_mps = 600,
+    .non_periodic_out_mps = 64,
+    .periodic_out_mps = 128,
+};
+
 /**
- * @brief Number of transfer descriptors per transfer for various transfer types
+ * @brief FIFO sizes that bias to giving Periodic TX FIFO more capacity (i.e., ISOC OUT)
  *
- * Control: Requires 3 transfer descriptors for a single transfer
- *          corresponding to each stage of a control transfer
- * Bulk: Requires 1 transfer descriptor for each transfer
+ * RXFIFO
+ * - Recommended: ((LPS/4) * 2) + 2
+ * - Actual: Assume LPS is 64, and 2 packets: ((64/4) * 2) + 2 = 34
+ * - Worst case can accommodate two packets of 64 bytes or one packet of 128
+ * NPTXFIFO
+ * - Recommended: (LPS/4) * 2
+ * - Actual: Assume LPS is 64, and 1 packets: (64/4) * 1 = 16
+ * - Worst case can accommodate one packet of 64 bytes
+ * PTXFIFO
+ * - Recommended: (LPS/4) * 2
+ * - Actual: Whatever leftover size: USBH_HAL_FIFO_TOTAL_USABLE_LINES(200) - 34 - 16 = 150
+ * - Worst case can accommodate two packets of 300 bytes or one packet of 600 bytes
  */
-#define NUM_DESC_PER_XFER_CTRL      3
-#define NUM_DESC_PER_XFER_BULK      1
-#define XFER_LIST_LEN_CTRL          1
-#define XFER_LIST_LEN_BULK          1
+const usbh_hal_fifo_config_t fifo_config_bias_ptx = {
+    .rx_fifo_lines = 34,
+    .nptx_fifo_lines = 16,
+    .ptx_fifo_lines = 150,
+};
 
-#define INIT_DELAY_MS               30      //A delay of at least 25ms to enter Host mode. Make it 30ms to be safe
-#define DEBOUNCE_DELAY_MS           250     //A debounce delay of 250ms
-#define RESET_HOLD_MS               30      //Spec requires at least 10ms. Make it 30ms to be safe
-#define RESET_RECOVERY_MS           30      //Reset recovery delay of 10ms (make it 30 ms to be safe) to allow for connected device to recover (and for port enabled interrupt to occur)
-#define RESUME_HOLD_MS              30      //Spec requires at least 20ms, Make it 30ms to be safe
-#define RESUME_RECOVERY_MS          20      //Resume recovery of at least 10ms. Make it 20 ms to be safe. This will include the 3 LS bit times of the EOP
+const fifo_mps_limits_t mps_limits_bias_ptx = {
+    .in_mps = 128,
+    .non_periodic_out_mps = 64,
+    .periodic_out_mps = 600,
+};
 
-#define CTRL_EP_MAX_MPS_LS          8       //Largest Maximum Packet Size for Low Speed control endpoints
-#define CTRL_EP_MAX_MPS_FS          64      //Largest Maximum Packet Size for Full Speed control endpoints
+#define FRAME_LIST_LEN                          USB_HAL_FRAME_LIST_LEN_32
+#define NUM_BUFFERS                             2
 
-#define NUM_PORTS                   1       //The controller only has one port.
+#define XFER_LIST_LEN_CTRL                      3   //One descriptor for each stage
+#define XFER_LIST_LEN_BULK                      2   //One descriptor for transfer, one to support an extra zero length packet
+#define XFER_LIST_LEN_INTR                      32
+#define XFER_LIST_LEN_ISOC                      FRAME_LIST_LEN  //Same length as the frame list makes it easier to schedule. Must be power of 2
 
 // ------------------------ Flags --------------------------
 
@@ -66,21 +155,20 @@
  * The IRP object has a reserved_flags member for host stack's internal use. The following flags will be set in
  * reserved_flags in order to keep track of state of an IRP within the HCD.
  */
-#define IRP_STATE_IDLE         0x0     //The IRP is not enqueued in an HCD pipe
-#define IRP_STATE_PENDING      0x1     //The IRP is enqueued and pending execution
-#define IRP_STATE_INFLIGHT     0x2     //The IRP is currently in flight
-#define IRP_STATE_DONE         0x3     //The IRP has completed execution or is retired, and is waiting to be dequeued
-#define IRP_STATE_MASK         0x3     //Bit mask of all the IRP state flags
+#define IRP_STATE_IDLE                          0x0 //The IRP is not enqueued in an HCD pipe
+#define IRP_STATE_PENDING                       0x1 //The IRP is enqueued and pending execution
+#define IRP_STATE_INFLIGHT                      0x2 //The IRP is currently in flight
+#define IRP_STATE_DONE                          0x3 //The IRP has completed execution or is retired, and is waiting to be dequeued
+#define IRP_STATE_MASK                          0x3 //Bit mask of all the IRP state flags
 #define IRP_STATE_SET(reserved_flags, state)    (reserved_flags = (reserved_flags & ~IRP_STATE_MASK) | state)
 #define IRP_STATE_GET(reserved_flags)           (reserved_flags & IRP_STATE_MASK)
 
-
 // -------------------- Convenience ------------------------
 
-#define HCD_ENTER_CRITICAL_ISR()    portENTER_CRITICAL_ISR(&hcd_lock)
-#define HCD_EXIT_CRITICAL_ISR()     portEXIT_CRITICAL_ISR(&hcd_lock)
-#define HCD_ENTER_CRITICAL()        portENTER_CRITICAL(&hcd_lock)
-#define HCD_EXIT_CRITICAL()         portEXIT_CRITICAL(&hcd_lock)
+#define HCD_ENTER_CRITICAL_ISR()                portENTER_CRITICAL_ISR(&hcd_lock)
+#define HCD_EXIT_CRITICAL_ISR()                 portEXIT_CRITICAL_ISR(&hcd_lock)
+#define HCD_ENTER_CRITICAL()                    portENTER_CRITICAL(&hcd_lock)
+#define HCD_EXIT_CRITICAL()                     portEXIT_CRITICAL(&hcd_lock)
 
 #define HCD_CHECK(cond, ret_val) ({                                         \
             if (!(cond)) {                                                  \
@@ -99,6 +187,49 @@
 typedef struct pipe_obj pipe_t;
 typedef struct port_obj port_t;
 
+/**
+ * @brief Object representing a single buffer of a pipe's multi buffer implementation
+ */
+typedef struct {
+    void *xfer_desc_list;
+    usb_irp_t *irp;
+    union {
+        struct {
+            uint32_t data_stg_in: 1;        //Data stage of the control transfer is IN
+            uint32_t data_stg_skip: 1;      //Control transfer has no data stage
+            uint32_t cur_stg: 2;            //Index of the current stage (e.g., 0 is setup stage, 2 is status stage)
+            uint32_t reserved28: 28;
+        } ctrl;                             //Control transfer related
+        struct {
+            uint32_t zero_len_packet: 1;    //Bulk transfer should add a zero length packet at the end regardless
+            uint32_t reserved31: 31;
+        } bulk;                             //Bulk transfer related
+        struct {
+            uint32_t num_qtds: 8;           //Number of transfer descriptors filled
+            uint32_t reserved24: 24;
+        } intr;                             //Interrupt transfer related
+        struct {
+            uint32_t num_qtds: 8;           //Number of transfer descriptors filled (including NULL descriptors)
+            uint32_t interval: 8;           //Interval (in number of SOF i.e., ms)
+            uint32_t irp_start_idx: 8;      //Index of the first transfer descriptor in the list
+            uint32_t next_irp_start_idx: 8; //Index for the first descriptor of the next buffer
+        } isoc;
+        uint32_t val;
+    } flags;
+    union {
+        struct {
+            uint32_t stop_idx: 8;           //The descriptor index when the channel was halted
+            uint32_t executing: 1;          //The buffer is currently executing
+            uint32_t error_occurred: 1;     //An error occurred
+            uint32_t cancelled: 1;          //The buffer was actively cancelled
+            uint32_t reserved5: 5;
+            hcd_pipe_state_t pipe_state: 8; //The pipe's state when the error occurred
+            hcd_pipe_event_t pipe_event: 8; //The pipe event when the error occurred
+        };
+        uint32_t val;
+    } status_flags;                         //Status flags for the buffer
+} dma_buffer_block_t;
+
 /**
  * @brief Object representing a pipe in the HCD layer
  */
@@ -108,15 +239,29 @@ struct pipe_obj {
     TAILQ_HEAD(tailhead_irp_done, usb_irp_obj) done_irp_tailq;
     int num_irp_pending;
     int num_irp_done;
-    usb_irp_t *inflight_irp;  //Pointer to the in-flight IRP (i.e., the IRP currently being executed). NULL if none.
-    //Port related
-    port_t *port;                       //The port to which this pipe is routed through
-    TAILQ_ENTRY(pipe_obj) tailq_entry;  //TailQ entry for port's list of pipes
-    //HAl channel related
-    void *xfer_desc_list;
+    //Multi-buffer control
+    dma_buffer_block_t *buffers[NUM_BUFFERS];  //Double buffering scheme
+    union {
+        struct {
+            uint32_t buffer_num_to_fill: 2; //Number of buffers that can be filled
+            uint32_t buffer_num_to_exec: 2; //Number of buffers that are filled and need to be executed
+            uint32_t buffer_num_to_parse: 2;//Number of buffers completed execution and waiting to be parsed
+            uint32_t reserved2: 2;
+            uint32_t wr_idx: 1;             //Index of the next buffer to fill. Bit width must allow NUM_BUFFERS to wrap automatically
+            uint32_t rd_idx: 1;             //Index of the current buffer in-flight. Bit width must allow NUM_BUFFERS to wrap automatically
+            uint32_t fr_idx: 1;             //Index of the next buffer to parse. Bit width must allow NUM_BUFFERS to wrap automatically
+            uint32_t buffer_is_executing: 1;//One of the buffers is in flight
+            uint32_t reserved20: 20;
+        };
+        uint32_t val;
+    } multi_buffer_flags;
+    //HAL related
     usbh_hal_chan_t *chan_obj;
     usbh_hal_ep_char_t ep_char;
-    //Pipe status, state, and events
+    //Port related
+    port_t *port;                           //The port to which this pipe is routed through
+    TAILQ_ENTRY(pipe_obj) tailq_entry;      //TailQ entry for port's list of pipes
+    //Pipe status/state/events related
     hcd_pipe_state_t state;
     hcd_pipe_event_t last_event;
     TaskHandle_t task_waiting_pipe_notif;   //Task handle used for internal pipe events
@@ -125,15 +270,11 @@ struct pipe_obj {
             uint32_t waiting_xfer_done: 1;
             uint32_t paused: 1;
             uint32_t pipe_cmd_processing: 1;
-            //Flags only used by control transfers
-            uint32_t ctrl_data_stg_in: 1;
-            uint32_t ctrl_data_stg_skip: 1;
-            uint32_t reserved3: 3;
-            uint32_t xfer_desc_list_len: 8;
-            uint32_t reserved16: 16;
+            uint32_t is_active: 1;
+            uint32_t reserved28: 28;
         };
         uint32_t val;
-    } flags;
+    } cs_flags;
     //Pipe callback and context
     hcd_pipe_isr_callback_t callback;
     void *callback_arg;
@@ -145,6 +286,7 @@ struct pipe_obj {
  */
 struct port_obj {
     usbh_hal_context_t *hal;
+    void *frame_list;
     //Pipes routed through this port
     TAILQ_HEAD(tailhead_pipes_idle, pipe_obj) pipes_idle_tailq;
     TAILQ_HEAD(tailhead_pipes_queued, pipe_obj) pipes_active_tailq;
@@ -154,21 +296,23 @@ struct port_obj {
     hcd_port_state_t state;
     usb_speed_t speed;
     hcd_port_event_t last_event;
-    TaskHandle_t task_waiting_port_notif;   //Task handle used for internal port events
+    TaskHandle_t task_waiting_port_notif;           //Task handle used for internal port events
     union {
         struct {
-            uint32_t event_pending: 1;      //The port has an event that needs to be handled
-            uint32_t event_processing: 1;   //The port is current processing (handling) an event
-            uint32_t cmd_processing: 1;     //Used to indicate command handling is ongoing
+            uint32_t event_pending: 1;              //The port has an event that needs to be handled
+            uint32_t event_processing: 1;           //The port is current processing (handling) an event
+            uint32_t cmd_processing: 1;             //Used to indicate command handling is ongoing
             uint32_t waiting_all_pipes_pause: 1;    //Waiting for all pipes routed through this port to be paused
             uint32_t disable_requested: 1;
-            uint32_t conn_devc_ena: 1;      //Used to indicate the port is connected to a device that has been reset
-            uint32_t reserved10: 10;
+            uint32_t conn_devc_ena: 1;              //Used to indicate the port is connected to a device that has been reset
+            uint32_t periodic_scheduling_enabled: 1;
+            uint32_t reserved9: 9;
             uint32_t num_pipes_waiting_pause: 16;
         };
         uint32_t val;
     } flags;
     bool initialized;
+    hcd_port_fifo_bias_t fifo_bias;
     //Port callback and context
     hcd_port_isr_callback_t callback;
     void *callback_arg;
@@ -190,46 +334,213 @@ static hcd_obj_t *s_hcd_obj = NULL;     //Note: "s_" is for the static pointer
 
 // ------------------------------------------------- Forward Declare ---------------------------------------------------
 
-// ----------------------- Events --------------------------
+// ------------------- Buffer Control ----------------------
 
 /**
- * @brief Wait for an internal event from a port
+ * @brief Check if an inactive buffer can be filled with a pending IRP
  *
- * @note For each port, there can only be one thread/task waiting for an internal port event
- * @note This function is blocking (will exit and re-enter the critical section to do so)
+ * @param pipe Pipe object
+ * @return true There are one or more pending IRPs, and the inactive buffer is yet to be filled
+ * @return false Otherwise
+ */
+static inline bool _buffer_can_fill(pipe_t *pipe)
+{
+    //We can only fill if there are pending IRPs and at least one unfilled buffer
+    if (pipe->num_irp_pending > 0 && pipe->multi_buffer_flags.buffer_num_to_fill > 0) {
+        return true;
+    } else {
+        return false;
+    }
+}
+
+/**
+ * @brief Fill an empty buffer with
  *
- * @param port Port object
+ * This function will:
+ * - Remove an IRP from the pending tailq
+ * - Fill that IRP into the inactive buffer
+ *
+ * @note _buffer_can_fill() must return true before calling this function
+ *
+ * @param pipe Pipe object
  */
-static void _internal_port_event_wait(port_t *port);
+static void _buffer_fill(pipe_t *pipe);
 
 /**
- * @brief Notify (from an ISR context) the thread/task waiting for the internal port event
+ * @brief Check if there are more filled buffers than can be executed
  *
- * @param port Port object
- * @return true A yield is required
- * @return false Whether a yield is required or not
+ * @param pipe Pipe object
+ * @return true There are more filled buffers to be executed
+ * @return false No more buffers to execute
  */
-static bool _internal_port_event_notify_from_isr(port_t *port);
+static inline bool _buffer_can_exec(pipe_t *pipe)
+{
+    //We can only execute if there is not already a buffer executing and if there are filled buffers awaiting execution
+    if (!pipe->multi_buffer_flags.buffer_is_executing && pipe->multi_buffer_flags.buffer_num_to_exec > 0) {
+        return true;
+    } else {
+        return false;
+    }
+}
 
 /**
- * @brief Wait for an internal event from a particular pipe
+ * @brief Execute the next filled buffer
+ *
+ * - Must have called _buffer_can_exec() before calling this function
+ * - Will start the execution of the buffer
+ *
+ * @param pipe Pipe object
+ */
+static void _buffer_exec(pipe_t *pipe);
+
+/**
+ * @brief Check if a buffer as completed execution
+ *
+ * This should only be called after receiving a USBH_HAL_CHAN_EVENT_CPLT event to check if a buffer is actually
+ * done. Buffers that aren't complete (such as Control transfers) will be continued automatically.
+ *
+ * @param pipe Pipe object
+ * @return true Buffer complete
+ * @return false Buffer not complete
+ */
+static bool _buffer_check_done(pipe_t *pipe);
+
+/**
+ * @brief Marks the last executed buffer as complete
+ *
+ * This should be called on a pipe that has confirmed that a buffer is completed via _buffer_check_done()
+ *
+ * @param pipe Pipe object
+ * @param stop_idx Descriptor index when the buffer stopped execution
+ */
+static inline void _buffer_done(pipe_t *pipe, int stop_idx)
+{
+    //Store the stop_idx for later parsing
+    dma_buffer_block_t *buffer_done = pipe->buffers[pipe->multi_buffer_flags.rd_idx];
+    buffer_done->status_flags.executing = 0;
+    buffer_done->status_flags.error_occurred = 0;
+    buffer_done->status_flags.stop_idx = stop_idx;
+    pipe->multi_buffer_flags.rd_idx++;
+    pipe->multi_buffer_flags.buffer_num_to_exec--;
+    pipe->multi_buffer_flags.buffer_num_to_parse++;
+    pipe->multi_buffer_flags.buffer_is_executing = 0;
+}
+
+/**
+ * @brief Marks the last executed buffer as complete due to an error
+ *
+ * This should be called on a pipe that has received a USBH_HAL_CHAN_EVENT_ERROR event
+ *
+ * @param pipe Pipe object
+ * @param stop_idx Descriptor index when the buffer stopped execution
+ * @param pipe_state State of the pipe after the error
+ * @param pipe_event Error event
+ * @param cancelled Whether the pipe stopped due to cancellation
+ */
+static inline void _buffer_done_error(pipe_t *pipe, int stop_idx, hcd_pipe_state_t pipe_state, hcd_pipe_event_t pipe_event, bool cancelled)
+{
+    //Mark the buffer as erroneous for later parsing
+    dma_buffer_block_t *buffer_done = pipe->buffers[pipe->multi_buffer_flags.rd_idx];
+    buffer_done->status_flags.executing = 0;
+    buffer_done->status_flags.error_occurred = 1;
+    buffer_done->status_flags.cancelled = cancelled;
+    buffer_done->status_flags.stop_idx = stop_idx;
+    buffer_done->status_flags.pipe_state = pipe_state;
+    buffer_done->status_flags.pipe_event = pipe_event;
+    pipe->multi_buffer_flags.rd_idx++;
+    pipe->multi_buffer_flags.buffer_num_to_exec--;
+    pipe->multi_buffer_flags.buffer_num_to_parse++;
+    pipe->multi_buffer_flags.buffer_is_executing = 0;
+}
+
+/**
+ * @brief Checks if a pipe has one or more completed buffers to parse
+ *
+ * @param pipe Pipe object
+ * @return true There are one or more buffers to parse
+ * @return false There are no more buffers to parse
+ */
+static inline bool _buffer_can_parse(pipe_t *pipe)
+{
+    if (pipe->multi_buffer_flags.buffer_num_to_parse > 0) {
+        return true;
+    } else {
+        return false;
+    }
+}
+
+/**
+ * @brief Parse a completed buffer
+ *
+ * This function will:
+ * - Parse the results of an IRP from a completed buffer
+ * - Put the IRP into the done tailq
+ *
+ * @note This function should only be called on the completion of a buffer
+ *
+ * @param pipe Pipe object
+ * @param stop_idx (For INTR pipes only) The index of the descriptor that follows the last descriptor of the IRP. Set to 0 otherwise
+ */
+static void _buffer_parse(pipe_t *pipe);
+
+/**
+ * @brief Marks all buffers pending execution as completed, then parses those buffers
+ *
+ * @note This should only be called on pipes do not have any currently executing buffers.
+ *
+ * @param pipe Pipe object
+ * @param cancelled Whether this flush is due to cancellation
+ */
+static void _buffer_flush_all(pipe_t *pipe, bool cancelled);
+
+// ------------------------ Pipe ---------------------------
+
+/**
+ * @brief Wait until a pipe's in-flight IRP is done
+ *
+ * If the pipe has an in-flight IRP, this function will block until it is done (via a internal pipe event).
+ * If the pipe has no in-flight IRP, this function do nothing and return immediately.
+ * If the pipe's state changes unexpectedly, this function will return false.
+ *
+ * Also parses all buffers on exit
  *
- * @note For each pipe, there can only be one thread/task waiting for an internal port event
  * @note This function is blocking (will exit and re-enter the critical section to do so)
  *
  * @param pipe Pipe object
+ * @return true Pipes in-flight IRP is done
+ * @return false Pipes state unexpectedly changed
  */
-static void _internal_pipe_event_wait(pipe_t *pipe);
+static bool _pipe_wait_done(pipe_t *pipe);
 
 /**
- * @brief Notify (from an ISR context) the thread/task waiting for an internal pipe event
+ * @brief Retires all IRPs (those that were previously in-flight or pending)
+ *
+ * Retiring all IRPs will result in any pending IRP being moved to the done tailq. This function will update the IPR
+ * status of each IRP.
+ *  - If the retiring is self-initiated (i.e., due to a pipe command), the IRP status will be set to USB_TRANSFER_STATUS_CANCELED.
+ *  - If the retiring is NOT self-initiated (i.e., the pipe is no longer valid), the IRP status will be set to USB_TRANSFER_STATUS_NO_DEVICE
+ *
+ * Entry:
+ * - There can be no in-flight IRP (must already be parsed and returned to done queue)
+ * - All buffers must be parsed
+ * Exit:
+ * - If there was an in-flight IRP, it is parsed and returned to the done queue
+ * - If there are any pending IRPs:
+ *      - They are moved to the done tailq
  *
  * @param pipe Pipe object
- * @param from_isr Whether this is called from an ISR or not
- * @return true A yield is required
- * @return false Whether a yield is required or not. Always false when from_isr is also false
+ * @param cancelled Are we actively Pipe retire is initialized by the user due to a command, thus IRP are
+ *                  actively cancelled.
  */
-static bool _internal_pipe_event_notify(pipe_t *pipe, bool from_isr);
+static void _pipe_retire(pipe_t *pipe, bool self_initiated);
+
+/**
+ * @brief Decode a HAL channel error to the corresponding pipe event
+ *
+ * @param chan_error The HAL channel error
+ * @return hcd_pipe_event_t The corresponding pipe error event
+ */
+static inline hcd_pipe_event_t pipe_decode_error_event(usbh_hal_chan_error_t chan_error);
 
 // ------------------------ Port ---------------------------
 
@@ -364,119 +675,46 @@ static bool _port_disable(port_t *port);
  */
 static bool _port_debounce(port_t *port);
 
-// ------------------------ Pipe ---------------------------
-
-/**
- * @brief Get the next pending IRP from the pending tailq
- *
- * Entry:
- * - The in-flight IRP must be set to NULL (indicating the pipe currently has no in-flight IRP)
- * Exit:
- * - If (num_irp_pending > 0), the first IRP is removed from pending_irp_tailq and and
- *   inflight_irp is set to that IRP.
- * - If there are no more queued IRPs, inflight_irp is left as NULL
- *
- * @param pipe Pipe object
- * @return true A pending IRP is now set as the in-flight IRP
- * @return false No more pending IRPs
- */
-static bool _pipe_get_next_irp(pipe_t *pipe);
-
-/**
- * @brief Return the pipe's current IRP (inflight_irp) to the done tailq
- *
- * Entry:
- *  - The inflight_irp must already have been parsed (i.e., results have been checked)
- * Exit:
- * - The IRP is returned to the done tailq and inflight_irp is set to NULL
- *
- * @param pipe Pipe object
- */
-static void _pipe_return_cur_irp(pipe_t *pipe);
+// ----------------------- Events --------------------------
 
 /**
- * @brief Wait until a pipe's in-flight IRP is done
- *
- * If the pipe has an in-flight IRP, this function will block until it is done (via a internal pipe event).
- * If the pipe has no in-flight IRP, this function do nothing and return immediately.
- * If the pipe's state changes unexpectedely, this function will return false.
+ * @brief Wait for an internal event from a port
  *
+ * @note For each port, there can only be one thread/task waiting for an internal port event
  * @note This function is blocking (will exit and re-enter the critical section to do so)
  *
- * @param pipe Pipe object
- * @return true Pipes in-flight IRP is done
- * @return false Pipes state unexpectedly changed
- */
-static bool _pipe_wait_done(pipe_t *pipe);
-
-/**
- * @brief Retires all IRPs (those that were previously in-flight or pending)
- *
- * Retiring all IRPs will result in any pending IRP being moved to the done tailq. This
- * function will update the IPR status of each IRP.
- *  - If the retiring is self-initiated (i.e., due to a pipe command), the IRP status will be set to USB_TRANSFER_STATUS_CANCELLED.
- *  - If the retiring is NOT self-initiated (i.e., the pipe is no longer valid), the IRP status will be set to USB_TRANSFER_STATUS_NO_DEVICE
- *
- * Entry:
- * - There can be no in-flight IRP (must already be parsed and returned to done queue)
- * Exit:
- * - If there was an in-flight IRP, it is parsed and returned to the done queue
- * - If there are any pending IRPs:
- *      - They are moved to the done tailq
- *
- * @param pipe Pipe object
- * @param cancelled Are we actively Pipe retire is initialized by the user due to a command, thus IRP are
- *                  actively cancelled.
- */
-static void _pipe_retire(pipe_t *pipe, bool self_initiated);
-
-/**
- * @brief Decode a HAL channel error to the corresponding pipe event
- *
- * @param chan_error The HAL channel error
- * @return hcd_pipe_event_t The corresponding pipe error event
+ * @param port Port object
  */
-static inline hcd_pipe_event_t pipe_decode_error_event(usbh_hal_chan_error_t chan_error);
-
-// ----------------- Transfer Descriptors ------------------
+static void _internal_port_event_wait(port_t *port);
 
 /**
- * @brief Fill the inflight_irp into the pipe's transfer descriptor list
- *
- * Entry:
- *  - The pipe's inflight_irp must be set to the next IRP
- * Exit:
- *  - inflight_irp filled into the pipe's transfer descriptor list
- *  - Starting PIDs and directions set
- *  - Channel slot acquired. Will need to call usbh_hal_chan_activate() to actually start execution
+ * @brief Notify (from an ISR context) the thread/task waiting for the internal port event
  *
- * @param pipe Pipe where inflight_irp is already set to the next IRP
+ * @param port Port object
+ * @return true A yield is required
+ * @return false Whether a yield is required or not
  */
-static void _xfer_desc_list_fill(pipe_t *pipe);
+static bool _internal_port_event_notify_from_isr(port_t *port);
 
 /**
- * @brief Continue the execution of the transfer descriptor list
+ * @brief Wait for an internal event from a particular pipe
  *
- * @note This is currently only used for control transfers
+ * @note For each pipe, there can only be one thread/task waiting for an internal port event
+ * @note This function is blocking (will exit and re-enter the critical section to do so)
  *
  * @param pipe Pipe object
  */
-static void _xfer_desc_list_continue(pipe_t *pipe);
+static void _internal_pipe_event_wait(pipe_t *pipe);
 
 /**
- * @brief Parse the pipe's transfer descriptor list to fill the result of the transfers into the pipe's IRP
- *
- * Entry:
- *  - The pipe must have stop transferring either due a channel event or a port disconnection.
- *  - The pipe's state and last_event must be updated before parsing the IRP as they will used to determine the result
- *    of the IRP
- * Exit:
- *  - The pipe's inflight_irp is filled with result of the IRP (i.e., the underlying IRP has its status set)
+ * @brief Notify (from an ISR context) the thread/task waiting for an internal pipe event
  *
  * @param pipe Pipe object
- * @param error_occurred Are we parsing after the pipe had an error (or has become invalid)
+ * @param from_isr Whether this is called from an ISR or not
+ * @return true A yield is required
+ * @return false Whether a yield is required or not. Always false when from_isr is also false
  */
-static void _xfer_desc_list_parse(pipe_t *pipe, bool error_occurred);
+static bool _internal_pipe_event_notify(pipe_t *pipe, bool from_isr);
 
 // ----------------------------------------------- Interrupt Handling --------------------------------------------------
 
@@ -632,42 +870,30 @@ static hcd_pipe_event_t _intr_hdlr_chan(pipe_t *pipe, usbh_hal_chan_t *chan_obj,
     if (!pipe->port->flags.conn_devc_ena) {
         return event;   //Treat as a no event.
     }
-
+    bool handle_waiting_xfer_done = false;
     switch (chan_event) {
-        case USBH_HAL_CHAN_EVENT_SLOT_DONE: {
-            //An entire transfer descriptor list has completed execution
+        case USBH_HAL_CHAN_EVENT_CPLT: {
+            if (!_buffer_check_done(pipe)) {
+                break;
+            }
             pipe->last_event = HCD_PIPE_EVENT_IRP_DONE;
-            event = HCD_PIPE_EVENT_IRP_DONE;
-            _xfer_desc_list_parse(pipe, false);    //Parse results of IRP
-            _pipe_return_cur_irp(pipe);    //Return the IRP to the pipe's done tailq
-            if (pipe->flags.waiting_xfer_done) {
-                //A port/pipe command is waiting for this pipe to complete its transfer. So don't load the next transfer
-                pipe->flags.waiting_xfer_done = 0;
-                if (pipe->port->flags.waiting_all_pipes_pause) {
-                    //Port command is waiting for all pipes to be paused
-                    pipe->flags.paused = 1;
-                    pipe->port->flags.num_pipes_waiting_pause--;
-                    if (pipe->port->flags.num_pipes_waiting_pause == 0) {
-                        //All pipes have finished pausing, Notify the blocked port command
-                        pipe->port->flags.waiting_all_pipes_pause = 0;
-                        *yield |= _internal_port_event_notify_from_isr(pipe->port);
-                    }
-                } else {
-                    //Pipe command is waiting for transfer to complete
-                    *yield |= _internal_pipe_event_notify(pipe, true);
-                }
-            } else if (_pipe_get_next_irp(pipe)) {
-                //Fill the descriptor list with the IRP and start the transfer
-                _xfer_desc_list_fill(pipe);
-                usbh_hal_chan_activate(chan_obj, 0);  //Start with the first descriptor
+            event = pipe->last_event;
+            //Mark the buffer as done
+            int stop_idx = usbh_hal_chan_get_qtd_idx(chan_obj);
+            _buffer_done(pipe, stop_idx);
+            //First check if there is another buffer we can execute
+            if (_buffer_can_exec(pipe) && !pipe->cs_flags.waiting_xfer_done) {
+                //If the next buffer is filled and ready to execute, execute it
+                _buffer_exec(pipe);
+            }
+            //Handle the previously done buffer
+            _buffer_parse(pipe);
+            if (pipe->cs_flags.waiting_xfer_done) {
+                handle_waiting_xfer_done = true;
+            } else if (_buffer_can_fill(pipe)) {
+                //Now that we've parsed a buffer, see if another IRP can be filled in its place
+                _buffer_fill(pipe);
             }
-            break;
-        }
-        case USBH_HAL_CHAN_EVENT_SLOT_HALT: {
-            //A transfer descriptor list has partially completed. This currently only happens on control pipes
-            assert(pipe->ep_char.type == USB_PRIV_XFER_TYPE_CTRL);
-            _xfer_desc_list_continue(pipe);     //Continue the transfer request.
-            //We are continuing a transfer, so no event has occurred
             break;
         }
         case USBH_HAL_CHAN_EVENT_ERROR: {
@@ -677,17 +903,41 @@ static hcd_pipe_event_t _intr_hdlr_chan(pipe_t *pipe, usbh_hal_chan_t *chan_obj,
             pipe->last_event = pipe_decode_error_event(chan_error);
             event = pipe->last_event;
             pipe->state = HCD_PIPE_STATE_HALTED;
-            //Parse the failed IRP and update it's IRP status
-            _xfer_desc_list_parse(pipe, true);
-            _pipe_return_cur_irp(pipe);    //Return the IRP to the pipe's done tailq
+            //Mark the buffer as done with an error
+            int stop_idx = usbh_hal_chan_get_qtd_idx(chan_obj);
+            _buffer_done_error(pipe, stop_idx, pipe->state, pipe->last_event, false);
+            //Parse the buffer
+            _buffer_parse(pipe);
+            if (pipe->cs_flags.waiting_xfer_done) {
+                handle_waiting_xfer_done = true;
+            }
             break;
         }
+        case USBH_HAL_CHAN_EVENT_NONE: {
+            break;  //Nothing to do
+        }
         case USBH_HAL_CHAN_EVENT_HALT_REQ:  //We currently don't halt request so this event should never occur
         default:
             abort();
             break;
     }
-
+    if (handle_waiting_xfer_done) {
+        //A port/pipe command is waiting for this pipe to complete its transfer. So don't load the next transfer
+        pipe->cs_flags.waiting_xfer_done = 0;
+        if (pipe->port->flags.waiting_all_pipes_pause) {
+            //Port command is waiting for all pipes to be paused
+            pipe->cs_flags.paused = 1;
+            pipe->port->flags.num_pipes_waiting_pause--;
+            if (pipe->port->flags.num_pipes_waiting_pause == 0) {
+                //All pipes have finished pausing, Notify the blocked port command
+                pipe->port->flags.waiting_all_pipes_pause = 0;
+                *yield |= _internal_port_event_notify_from_isr(pipe->port);
+            }
+        } else {
+            //Pipe command is waiting for transfer to complete
+            *yield |= _internal_pipe_event_notify(pipe, true);
+        }
+    }
     return event;
 }
 
@@ -699,7 +949,8 @@ static hcd_pipe_event_t _intr_hdlr_chan(pipe_t *pipe, usbh_hal_chan_t *chan_obj,
  * - If any channels (pipes) have pending interrupts, handle them one by one
  * - The HCD has not blocking functions, so the user's ISR callback is run to
  *   allow the users to send whatever OS primitives they need.
- * @param arg
+ *
+ * @param arg Interrupt handler argument
  */
 static void intr_hdlr_main(void *arg)
 {
@@ -748,16 +999,19 @@ static port_t *port_obj_alloc(void)
 {
     port_t *port = calloc(1, sizeof(port_t));
     usbh_hal_context_t *hal = malloc(sizeof(usbh_hal_context_t));
+    void *frame_list = heap_caps_aligned_calloc(USBH_HAL_FRAME_LIST_MEM_ALIGN, FRAME_LIST_LEN,sizeof(uint32_t), MALLOC_CAP_DMA);
     SemaphoreHandle_t port_mux = xSemaphoreCreateMutex();
-    if (port == NULL || hal == NULL || port_mux == NULL) {
+    if (port == NULL || hal == NULL || frame_list == NULL || port_mux == NULL) {
         free(port);
         free(hal);
+        free(frame_list);
         if (port_mux != NULL) {
             vSemaphoreDelete(port_mux);
         }
         return NULL;
     }
     port->hal = hal;
+    port->frame_list = frame_list;
     port->port_mux = port_mux;
     return port;
 }
@@ -768,6 +1022,7 @@ static void port_obj_free(port_t *port)
         return;
     }
     vSemaphoreDelete(port->port_mux);
+    free(port->frame_list);
     free(port->hal);
     free(port);
 }
@@ -817,7 +1072,7 @@ esp_err_t hcd_install(const hcd_config_t *config)
         - Forces ID to GND for A side
         - Forces B Valid to GND as we are A side host
         - Forces VBUS Valid to HIGH
-        - Froces A Valid to HIGH
+        - Forces A Valid to HIGH
     */
     esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ZERO_INPUT, USB_OTG_IDDIG_IN_IDX, false);
     esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ZERO_INPUT, USB_SRP_BVALID_IN_IDX, false);
@@ -825,6 +1080,7 @@ esp_err_t hcd_install(const hcd_config_t *config)
     esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ONE_INPUT, USB_OTG_AVALID_IN_IDX, false);
     HCD_EXIT_CRITICAL();
     return ESP_OK;
+
 err:
     if (intr_alloc_ret == ESP_OK) {
         esp_intr_free(p_hcd_obj_dmy->isr_hdl);
@@ -868,12 +1124,9 @@ static void _port_invalidate_all_pipes(port_t *port)
         //Mark the pipe as invalid and set an invalid event
         pipe->state = HCD_PIPE_STATE_INVALID;
         pipe->last_event = HCD_PIPE_EVENT_INVALID;
-        //If the pipe had an in-flight transfer, parse and return it
-        if (pipe->inflight_irp != NULL) {
-            _xfer_desc_list_parse(pipe, true);
-            _pipe_return_cur_irp(pipe);
-        }
-        //Retire any remaining IRPs
+        //Flush all buffers that are still awaiting exec
+        _buffer_flush_all(pipe, false);
+        //Retire any remaining IRPs in the pending tailq
         _pipe_retire(pipe, false);
         if (pipe->task_waiting_pipe_notif != NULL) {
             //Unblock the thread/task waiting for a notification from the pipe as the pipe is no longer valid.
@@ -905,18 +1158,19 @@ static bool _port_pause_all_pipes(port_t *port)
     int num_pipes_waiting_done = 0;
     //Process all pipes that have queued IRPs
     TAILQ_FOREACH(pipe, &port->pipes_active_tailq, tailq_entry) {
-        if (pipe->inflight_irp != NULL) {
-            //Pipe has an in-flight transfer. Indicate to the pipe we are waiting the transfer to complete
-            pipe->flags.waiting_xfer_done = 1;
+        //Check if pipe is currently executing
+        if (pipe->multi_buffer_flags.buffer_is_executing) {
+            //Pipe is executing a buffer. Indicate to the pipe we are waiting the buffer's transfer to complete
+            pipe->cs_flags.waiting_xfer_done = 1;
             num_pipes_waiting_done++;
         } else {
-            //No in-flight transfer so no need to wait
-            pipe->flags.paused = 1;
+            //No buffer is being executed so need to wait
+            pipe->cs_flags.paused = 1;
         }
     }
     //Process all idle pipes. They don't have queue transfer so just mark them as paused
     TAILQ_FOREACH(pipe, &port->pipes_idle_tailq, tailq_entry) {
-        pipe->flags.paused = 1;
+        pipe->cs_flags.paused = 1;
     }
     if (num_pipes_waiting_done > 0) {
         //Indicate we need to wait for one or more pipes to complete their transfers
@@ -933,15 +1187,16 @@ static void _port_unpause_all_pipes(port_t *port)
     pipe_t *pipe;
     //Process all idle pipes. They don't have queue transfer so just mark them as un-paused
     TAILQ_FOREACH(pipe, &port->pipes_idle_tailq, tailq_entry) {
-        pipe->flags.paused = 0;
+        pipe->cs_flags.paused = 0;
     }
     //Process all pipes that have queued IRPs
     TAILQ_FOREACH(pipe, &port->pipes_active_tailq, tailq_entry) {
-        pipe->flags.paused = 0;
-        //If the pipe has more pending IRP, start them.
-        if (_pipe_get_next_irp(pipe)) {
-            _xfer_desc_list_fill(pipe);
-            usbh_hal_chan_activate(pipe->chan_obj, 0);
+        pipe->cs_flags.paused = 0;
+        if (_buffer_can_fill(pipe)) {
+            _buffer_fill(pipe);
+        }
+        if (_buffer_can_exec(pipe)) {
+            _buffer_exec(pipe);
         }
     }
 }
@@ -1005,14 +1260,14 @@ static bool _port_bus_resume(port_t *port)
     //Return and hold the bus to the J state (as port of the LS EOP)
     usbh_hal_port_toggle_resume(port->hal, false);
     if (port->state != HCD_PORT_STATE_RESUMING || !port->flags.conn_devc_ena) {
-        //Port state unexpectedley changed
+        //Port state unexpectedly changed
         goto bailout;
     }
     HCD_EXIT_CRITICAL();
     vTaskDelay(pdMS_TO_TICKS(RESUME_RECOVERY_MS));
     HCD_ENTER_CRITICAL();
     if (port->state != HCD_PORT_STATE_RESUMING || !port->flags.conn_devc_ena) {
-        //Port state unexpectedley changed
+        //Port state unexpectedly changed
         goto bailout;
     }
     port->state = HCD_PORT_STATE_ENABLED;
@@ -1031,7 +1286,7 @@ static bool _port_disable(port_t *port)
             //Need to wait for some pipes to pause. Wait for notification from ISR
             _internal_port_event_wait(port);
             if (port->state != HCD_PORT_STATE_ENABLED || !port->flags.conn_devc_ena) {
-                //Port state unexpectedley changed
+                //Port state unexpectedly changed
                 goto bailout;
             }
         }
@@ -1041,7 +1296,7 @@ static bool _port_disable(port_t *port)
     usbh_hal_port_disable(port->hal);
     _internal_port_event_wait(port);
     if (port->state != HCD_PORT_STATE_DISABLED) {
-        //Port state unexpectedley changed
+        //Port state unexpectedly changed
         goto bailout;
     }
     _port_invalidate_all_pipes(port);
@@ -1130,7 +1385,7 @@ esp_err_t hcd_port_command(hcd_port_handle_t port_hdl, hcd_port_cmd_t command)
                 //Port can only be powered on if currently unpowered
                 if (port->state == HCD_PORT_STATE_NOT_POWERED) {
                     port->state = HCD_PORT_STATE_DISCONNECTED;
-                    usbh_hal_port_start(port->hal);
+                    usbh_hal_port_init(port->hal);
                     usbh_hal_port_toggle_power(port->hal, true);
                     ret = ESP_OK;
                 }
@@ -1140,7 +1395,7 @@ esp_err_t hcd_port_command(hcd_port_handle_t port_hdl, hcd_port_cmd_t command)
                 //Port can only be unpowered if already powered
                 if (port->state != HCD_PORT_STATE_NOT_POWERED) {
                     port->state = HCD_PORT_STATE_NOT_POWERED;
-                    usbh_hal_port_stop(port->hal);
+                    usbh_hal_port_deinit(port->hal);
                     usbh_hal_port_toggle_power(port->hal, false);
                     //If a device is currently connected, this should trigger a disconnect event
                     ret = ESP_OK;
@@ -1150,7 +1405,18 @@ esp_err_t hcd_port_command(hcd_port_handle_t port_hdl, hcd_port_cmd_t command)
             case HCD_PORT_CMD_RESET: {
                 //Port can only a reset when it is in the enabled or disabled states (in case of new connection)
                 if (port->state == HCD_PORT_STATE_ENABLED || port->state == HCD_PORT_STATE_DISABLED) {
-                    ret = (_port_bus_reset(port)) ? ESP_OK : ESP_ERR_INVALID_RESPONSE;
+                    if (_port_bus_reset(port)) {
+                        //Set FIFO sizes to default
+                        usbh_hal_set_fifo_size(port->hal, &fifo_config_default);
+                        port->fifo_bias = HCD_PORT_FIFO_BIAS_BALANCED;
+                        //Reset frame list and enable periodic scheduling
+                        memset(port->frame_list, 0, FRAME_LIST_LEN * sizeof(uint32_t));
+                        usbh_hal_port_set_frame_list(port->hal, port->frame_list, FRAME_LIST_LEN);
+                        usbh_hal_port_periodic_enable(port->hal);
+                        ret = ESP_OK;
+                    } else {
+                        ret = ESP_ERR_INVALID_RESPONSE;
+                    }
                 }
                 break;
             }
@@ -1198,7 +1464,7 @@ esp_err_t hcd_port_get_speed(hcd_port_handle_t port_hdl, usb_speed_t *speed)
     port_t *port = (port_t *)port_hdl;
     HCD_CHECK(speed != NULL, ESP_ERR_INVALID_ARG);
     HCD_ENTER_CRITICAL();
-    //Device speed is only valid if there is a resetted device connected to the port
+    //Device speed is only valid if there is device connected to the port that has been reset
     HCD_CHECK_FROM_CRIT(port->flags.conn_devc_ena, ESP_ERR_INVALID_STATE);
     usb_priv_speed_t hal_speed = usbh_hal_port_get_conn_speed(port->hal);
     if (hal_speed == USB_PRIV_SPEED_FULL) {
@@ -1233,7 +1499,7 @@ hcd_port_event_t hcd_port_handle_event(hcd_port_handle_t port_hdl)
                     port->state = HCD_PORT_STATE_DISABLED;
                     ret = HCD_PORT_EVENT_NONE;
                 } else {
-                    //No device conencted after debounce delay. This is an actual disconenction
+                    //No device connected after debounce delay. This is an actual disconnection
                     port->state = HCD_PORT_STATE_DISCONNECTED;
                     ret = HCD_PORT_EVENT_DISCONNECTION;
                 }
@@ -1276,7 +1542,7 @@ esp_err_t hcd_port_recover(hcd_port_handle_t port_hdl)
     return ESP_OK;
 }
 
-void *hcd_port_get_ctx(hcd_port_handle_t port_hdl)
+void *hcd_port_get_context(hcd_port_handle_t port_hdl)
 {
     port_t *port = (port_t *)port_hdl;
     void *ret;
@@ -1286,53 +1552,58 @@ void *hcd_port_get_ctx(hcd_port_handle_t port_hdl)
     return ret;
 }
 
-// --------------------------------------------------- HCD Pipes -------------------------------------------------------
-
-// ----------------------- Private -------------------------
-
-static bool _pipe_get_next_irp(pipe_t *pipe)
+esp_err_t hcd_port_set_fifo_bias(hcd_port_handle_t port_hdl, hcd_port_fifo_bias_t bias)
 {
-    assert(pipe->inflight_irp == NULL);
-    bool ret;
-    //This function assigns the next pending IRP to the inflight_irp
-    if (pipe->num_irp_pending > 0) {
-        //Set inflight_irp to the next pending IRP
-        pipe->inflight_irp = TAILQ_FIRST(&pipe->pending_irp_tailq);
-        TAILQ_REMOVE(&pipe->pending_irp_tailq, pipe->inflight_irp, tailq_entry);
-        pipe->num_irp_pending--;
-        //Update the IRP's current state
-        IRP_STATE_SET(pipe->inflight_irp->reserved_flags, IRP_STATE_INFLIGHT);
-        ret =  true;
+    esp_err_t ret;
+    port_t *port = (port_t *)port_hdl;
+    xSemaphoreTake(port->port_mux, portMAX_DELAY);
+    HCD_ENTER_CRITICAL();
+    //Check that port is in the correct state to update FIFO sizes
+    if (port->initialized && !port->flags.event_pending && port->num_pipes_idle == 0 && port->num_pipes_queued == 0) {
+        port_t *port = (port_t *)port_hdl;
+        const usbh_hal_fifo_config_t *fifo_config;
+        switch (bias) {
+            case HCD_PORT_FIFO_BIAS_BALANCED:
+                fifo_config = &fifo_config_default;
+                break;
+            case HCD_PORT_FIFO_BIAS_RX:
+                fifo_config = &fifo_config_bias_rx;
+                break;
+            case HCD_PORT_FIFO_BIAS_PTX:
+                fifo_config = &fifo_config_bias_ptx;
+                break;
+            default:
+                fifo_config = NULL;
+                abort();
+        }
+        usbh_hal_set_fifo_size(port->hal, fifo_config);
+        port->fifo_bias = bias;
+        ret = ESP_OK;
     } else {
-        ret = false;
+        ret = ESP_ERR_INVALID_STATE;
     }
+    HCD_EXIT_CRITICAL();
+    xSemaphoreGive(port->port_mux);
     return ret;
 }
 
-static void _pipe_return_cur_irp(pipe_t *pipe)
-{
-    assert(pipe->inflight_irp != NULL);
-    //Add the IRP to the pipe's done tailq
-    TAILQ_INSERT_TAIL(&pipe->done_irp_tailq, pipe->inflight_irp, tailq_entry);
-    //Update the IRP's current state
-    IRP_STATE_SET(pipe->inflight_irp->reserved_flags, IRP_STATE_DONE);
-    pipe->inflight_irp = NULL;
-    pipe->num_irp_done++;
-}
+// --------------------------------------------------- HCD Pipes -------------------------------------------------------
+
+// ----------------------- Private -------------------------
 
 static bool _pipe_wait_done(pipe_t *pipe)
 {
-    //Check if there is a currently in-flight IRP
-    if (pipe->inflight_irp != NULL) {
+    //Check if the pipe has a currently executing buffer
+    if (pipe->multi_buffer_flags.buffer_is_executing) {
         //Wait for pipe to complete its transfer
-        pipe->flags.waiting_xfer_done = 1;
+        pipe->cs_flags.waiting_xfer_done = 1;
         _internal_pipe_event_wait(pipe);
         if (pipe->state == HCD_PIPE_STATE_INVALID) {
             //The pipe become invalid whilst waiting for its internal event
-            pipe->flags.waiting_xfer_done = 0;  //Need to manually reset this bit in this case
+            pipe->cs_flags.waiting_xfer_done = 0;  //Need to manually reset this bit in this case
             return false;
         }
-        bool chan_halted = usbh_hal_chan_slot_request_halt(pipe->chan_obj);
+        bool chan_halted = usbh_hal_chan_request_halt(pipe->chan_obj);
         assert(chan_halted);
         (void) chan_halted;
     }
@@ -1341,16 +1612,16 @@ static bool _pipe_wait_done(pipe_t *pipe)
 
 static void _pipe_retire(pipe_t *pipe, bool self_initiated)
 {
-    //Cannot have any in-flight IRP
-    assert(pipe->inflight_irp == NULL);
+    //Cannot have a currently executing buffer
+    assert(!pipe->multi_buffer_flags.buffer_is_executing);
     if (pipe->num_irp_pending > 0) {
         //Process all remaining pending IRPs
         usb_irp_t *irp;
         TAILQ_FOREACH(irp, &pipe->pending_irp_tailq, tailq_entry) {
             //Update the IRP's current state
             IRP_STATE_SET(irp->reserved_flags, IRP_STATE_DONE);
-            //If we are initiating the retire, mark the IRP as cancelled
-            irp->status = (self_initiated) ? USB_TRANSFER_STATUS_CANCELLED : USB_TRANSFER_STATUS_NO_DEVICE;
+            //If we are initiating the retire, mark the IRP as canceled
+            irp->status = (self_initiated) ? USB_TRANSFER_STATUS_CANCELED : USB_TRANSFER_STATUS_NO_DEVICE;
         }
         //Concatenated pending tailq to the done tailq
         TAILQ_CONCAT(&pipe->done_irp_tailq, &pipe->pending_irp_tailq, tailq_entry);
@@ -1379,6 +1650,154 @@ static inline hcd_pipe_event_t pipe_decode_error_event(usbh_hal_chan_error_t cha
     return event;
 }
 
+static dma_buffer_block_t *buffer_block_alloc(usb_transfer_type_t type)
+{
+    int desc_list_len;
+    switch (type) {
+    case USB_TRANSFER_TYPE_CTRL:
+        desc_list_len = XFER_LIST_LEN_CTRL;
+        break;
+    case USB_TRANSFER_TYPE_ISOCHRONOUS:
+        desc_list_len = XFER_LIST_LEN_ISOC;
+        break;
+    case USB_TRANSFER_TYPE_BULK:
+        desc_list_len = XFER_LIST_LEN_BULK;
+        break;
+    default:    //USB_TRANSFER_TYPE_INTR:
+        desc_list_len = XFER_LIST_LEN_INTR;
+        break;
+    }
+    dma_buffer_block_t *buffer = calloc(1, sizeof(dma_buffer_block_t));
+    void *xfer_desc_list = heap_caps_aligned_calloc(USBH_HAL_DMA_MEM_ALIGN, desc_list_len, sizeof(usbh_ll_dma_qtd_t), MALLOC_CAP_DMA);
+    if (buffer == NULL || xfer_desc_list == NULL) {
+        free(buffer);
+        heap_caps_free(xfer_desc_list);
+        return NULL;
+    }
+    buffer->xfer_desc_list = xfer_desc_list;
+    return buffer;
+}
+
+static void buffer_block_free(dma_buffer_block_t *buffer)
+{
+    if (buffer == NULL) {
+        return;
+    }
+    heap_caps_free(buffer->xfer_desc_list);
+    free(buffer);
+}
+
+static bool pipe_alloc_check_args(const hcd_pipe_config_t *pipe_config, usb_speed_t port_speed, hcd_port_fifo_bias_t fifo_bias, usb_transfer_type_t type, bool is_default_pipe)
+{
+    //Check if pipe can be supported
+    if (port_speed == USB_SPEED_LOW && pipe_config->dev_speed == USB_SPEED_FULL) {
+        //Low speed port does not supported full speed pipe
+        return false;
+    }
+    if (pipe_config->dev_speed == USB_SPEED_LOW && (type == USB_TRANSFER_TYPE_BULK || type == USB_TRANSFER_TYPE_ISOCHRONOUS)) {
+        //Low speed does not support Bulk or Isochronous pipes
+        return false;
+    }
+    //Check interval of pipe
+    if (type == USB_TRANSFER_TYPE_INTR &&
+        (pipe_config->ep_desc->bInterval > 0 && pipe_config->ep_desc->bInterval > 32)) {
+        //Interval not supported for interrupt pipe
+        return false;
+    }
+    if (type == USB_TRANSFER_TYPE_ISOCHRONOUS &&
+        (pipe_config->ep_desc->bInterval > 0 && pipe_config->ep_desc->bInterval > 6)) {
+        //Interval not supported for isochronous pipe (where 0 < 2^(bInterval - 1) <= 32)
+        return false;
+    }
+
+    if (is_default_pipe) {
+        return true;
+    }
+    //Check if MPS is within FIFO limits
+    const fifo_mps_limits_t *mps_limits;
+    switch (fifo_bias) {
+        case HCD_PORT_FIFO_BIAS_BALANCED:
+            mps_limits = &mps_limits_default;
+            break;
+        case HCD_PORT_FIFO_BIAS_RX:
+            mps_limits = &mps_limits_bias_rx;
+            break;
+        default:    //HCD_PORT_FIFO_BIAS_PTX
+            mps_limits = &mps_limits_bias_ptx;
+            break;
+    }
+    int limit;
+    if (USB_DESC_EP_GET_EP_DIR(pipe_config->ep_desc)) { //IN
+        limit = mps_limits->in_mps;
+    } else {    //OUT
+        if (type == USB_TRANSFER_TYPE_CTRL || type == USB_TRANSFER_TYPE_BULK) {
+            limit = mps_limits->non_periodic_out_mps;
+        } else {
+            limit = mps_limits->periodic_out_mps;
+        }
+    }
+    return (pipe_config->ep_desc->wMaxPacketSize <= limit);
+}
+
+static void pipe_set_ep_char(const hcd_pipe_config_t *pipe_config, usb_transfer_type_t type, bool is_default_pipe, int pipe_idx, usb_speed_t port_speed, usbh_hal_ep_char_t *ep_char)
+{
+    //Initialize EP characteristics
+    usb_priv_xfer_type_t hal_xfer_type;
+    switch (type) {
+        case USB_TRANSFER_TYPE_CTRL:
+            hal_xfer_type = USB_PRIV_XFER_TYPE_CTRL;
+            break;
+        case USB_TRANSFER_TYPE_ISOCHRONOUS:
+            hal_xfer_type = USB_PRIV_XFER_TYPE_ISOCHRONOUS;
+            break;
+        case USB_TRANSFER_TYPE_BULK:
+            hal_xfer_type = USB_PRIV_XFER_TYPE_BULK;
+            break;
+        default:    //USB_TRANSFER_TYPE_INTR
+            hal_xfer_type = USB_PRIV_XFER_TYPE_INTR;
+            break;
+    }
+    ep_char->type = hal_xfer_type;
+    if (is_default_pipe) {
+        ep_char->bEndpointAddress = 0;
+        //Set the default pipe's MPS to the worst case MPS for the device's speed
+        ep_char->mps = (pipe_config->dev_speed == USB_SPEED_FULL) ? CTRL_EP_MAX_MPS_FS : CTRL_EP_MAX_MPS_LS;
+    } else {
+        ep_char->bEndpointAddress = pipe_config->ep_desc->bEndpointAddress;
+        ep_char->mps = pipe_config->ep_desc->wMaxPacketSize;
+    }
+    ep_char->dev_addr = pipe_config->dev_addr;
+    ep_char->ls_via_fs_hub = (port_speed == USB_SPEED_FULL && pipe_config->dev_speed == USB_SPEED_LOW);
+    //Calculate the pipe's interval in terms of USB frames
+    if (type == USB_TRANSFER_TYPE_INTR || type == USB_TRANSFER_TYPE_ISOCHRONOUS) {
+        int interval_frames;
+        if (type == USB_TRANSFER_TYPE_INTR) {
+            interval_frames = pipe_config->ep_desc->bInterval;
+        } else {
+            interval_frames = (1 << (pipe_config->ep_desc->bInterval - 1));
+        }
+        //Round down interval to nearest power of 2
+        if (interval_frames >= 32) {
+            interval_frames = 32;
+        } else if (interval_frames >= 16) {
+            interval_frames = 16;
+        } else if (interval_frames >= 8) {
+            interval_frames = 8;
+        } else if (interval_frames >= 4) {
+            interval_frames = 4;
+        } else if (interval_frames >= 2) {
+            interval_frames = 2;
+        } else if (interval_frames >= 1) {
+            interval_frames = 1;
+        }
+        ep_char->periodic.interval = interval_frames;
+        //We are the Nth pipe to be allocated. Use N as a phase offset
+        ep_char->periodic.phase_offset_frames = pipe_idx & (XFER_LIST_LEN_ISOC - 1);
+    }else {
+        ep_char->periodic.val = 0;
+    }
+}
+
 // ----------------------- Public --------------------------
 
 esp_err_t hcd_pipe_alloc(hcd_port_handle_t port_hdl, const hcd_pipe_config_t *pipe_config, hcd_pipe_handle_t *pipe_hdl)
@@ -1386,85 +1805,56 @@ esp_err_t hcd_pipe_alloc(hcd_port_handle_t port_hdl, const hcd_pipe_config_t *pi
     HCD_CHECK(port_hdl != NULL && pipe_config != NULL && pipe_hdl != NULL, ESP_ERR_INVALID_ARG);
     port_t *port = (port_t *)port_hdl;
     HCD_ENTER_CRITICAL();
-    //Can only allocate a pipe if the targeted port is initialized and connected to an enabled device
+    //Can only allocate a pipe if the target port is initialized and connected to an enabled device
     HCD_CHECK_FROM_CRIT(port->initialized && port->flags.conn_devc_ena, ESP_ERR_INVALID_STATE);
     usb_speed_t port_speed = port->speed;
+    hcd_port_fifo_bias_t port_fifo_bias = port->fifo_bias;
+    int pipe_idx = port->num_pipes_idle + port->num_pipes_queued;
     HCD_EXIT_CRITICAL();
-    //Cannot connect to a FS device if the port is LS
-    HCD_CHECK(port_speed == USB_SPEED_FULL || (port_speed == USB_SPEED_LOW && pipe_config->dev_speed == USB_SPEED_LOW), ESP_ERR_NOT_SUPPORTED);
 
-    esp_err_t ret = ESP_OK;
-    //Get the type of pipe to allocate
     usb_transfer_type_t type;
-    bool is_default_pipe;
-    if (pipe_config->ep_desc == NULL) {  //A NULL ep_desc indicates we are allocating a default pipe
-        type = USB_XFER_TYPE_CTRL;
-        is_default_pipe = true;
+    bool is_default;
+    if (pipe_config->ep_desc == NULL) {
+        type = USB_TRANSFER_TYPE_CTRL;
+        is_default = true;
     } else {
         type = USB_DESC_EP_GET_XFERTYPE(pipe_config->ep_desc);
-        is_default_pipe = false;
+        is_default = false;
     }
-    size_t num_xfer_desc = 0;
-    switch (type) {
-        case USB_XFER_TYPE_CTRL: {
-            num_xfer_desc = XFER_LIST_LEN_CTRL * NUM_DESC_PER_XFER_CTRL;
-            break;
-        }
-        case USB_XFER_TYPE_BULK: {
-            if (pipe_config->dev_speed == USB_SPEED_LOW) {
-                return ESP_ERR_NOT_SUPPORTED;   //Low speed devices do not support bulk transfers
-            }
-            num_xfer_desc = XFER_LIST_LEN_BULK * NUM_DESC_PER_XFER_BULK;
-            break;
-        }
-        default: {
-            //Isochronous and Interrupt pipes currently not supported
-            return ESP_ERR_NOT_SUPPORTED;
-        }
+    //Check if pipe configuration can be supported
+    if (!pipe_alloc_check_args(pipe_config, port_speed, port_fifo_bias, type, is_default)) {
+        return ESP_ERR_NOT_SUPPORTED;
     }
 
+    esp_err_t ret;
     //Allocate the pipe resources
     pipe_t *pipe = calloc(1, sizeof(pipe_t));
-    usbh_hal_chan_t *chan_obj = malloc(sizeof(usbh_hal_chan_t));
-    void *xfer_desc_list = heap_caps_aligned_calloc(USBH_HAL_DMA_MEM_ALIGN, num_xfer_desc, USBH_HAL_XFER_DESC_SIZE, MALLOC_CAP_DMA);
-    if (pipe == NULL|| chan_obj == NULL || xfer_desc_list == NULL) {
+    usbh_hal_chan_t *chan_obj = calloc(1, sizeof(usbh_hal_chan_t));
+    dma_buffer_block_t *buffers[NUM_BUFFERS] = {0};
+    if (pipe == NULL|| chan_obj == NULL) {
         ret = ESP_ERR_NO_MEM;
         goto err;
     }
+    for (int i = 0; i < NUM_BUFFERS; i++) {
+        buffers[i] = buffer_block_alloc(type);
+        if (buffers[i] == NULL) {
+            ret = ESP_ERR_NO_MEM;
+            goto err;
+        }
+    }
 
     //Initialize pipe object
     TAILQ_INIT(&pipe->pending_irp_tailq);
     TAILQ_INIT(&pipe->done_irp_tailq);
+    for (int i = 0; i < NUM_BUFFERS; i++) {
+        pipe->buffers[i] = buffers[i];
+    }
+    pipe->multi_buffer_flags.buffer_num_to_fill = NUM_BUFFERS;
     pipe->port = port;
-    pipe->xfer_desc_list = xfer_desc_list;
-    pipe->flags.xfer_desc_list_len = num_xfer_desc;
     pipe->chan_obj = chan_obj;
-    usb_priv_xfer_type_t hal_type;
-    switch (type) {
-        case USB_XFER_TYPE_CTRL:
-            hal_type = USB_PRIV_XFER_TYPE_CTRL;
-            break;
-        case USB_XFER_TYPE_ISOCHRONOUS:
-            hal_type = USB_PRIV_XFER_TYPE_ISOCHRONOUS;
-            break;
-        case USB_XFER_TYPE_BULK:
-            hal_type = USB_PRIV_XFER_TYPE_ISOCHRONOUS;
-            break;
-        default:    //USB_XFER_TYPE_INTR
-            hal_type = USB_PRIV_XFER_TYPE_INTR;
-            break;
-    }
-    pipe->ep_char.type = hal_type;
-    if (is_default_pipe) {
-        pipe->ep_char.bEndpointAddress = 0;
-        //Set the default pipe's MPS to the worst case MPS for the device's speed
-        pipe->ep_char.mps = (pipe_config->dev_speed == USB_SPEED_FULL) ? CTRL_EP_MAX_MPS_FS : CTRL_EP_MAX_MPS_LS;
-    } else {
-        pipe->ep_char.bEndpointAddress = pipe_config->ep_desc->bEndpointAddress;
-        pipe->ep_char.mps = pipe_config->ep_desc->wMaxPacketSize;
-    }
-    pipe->ep_char.dev_addr = pipe_config->dev_addr;
-    pipe->ep_char.ls_via_fs_hub = (port_speed == USB_SPEED_FULL && pipe_config->dev_speed == USB_SPEED_LOW);
+    usbh_hal_ep_char_t ep_char;
+    pipe_set_ep_char(pipe_config, type, is_default, pipe_idx, port_speed, &ep_char);
+    memcpy(&pipe->ep_char, &ep_char, sizeof(usbh_hal_ep_char_t));
     pipe->state = HCD_PIPE_STATE_ACTIVE;
     pipe->callback = pipe_config->callback;
     pipe->callback_arg = pipe_config->callback_arg;
@@ -1483,17 +1873,19 @@ esp_err_t hcd_pipe_alloc(hcd_port_handle_t port_hdl, const hcd_pipe_config_t *pi
         ret = ESP_ERR_NOT_SUPPORTED;
         goto err;
     }
-    usbh_hal_chan_set_ep_char(pipe->chan_obj, &pipe->ep_char);
-
+    usbh_hal_chan_set_ep_char(port->hal, pipe->chan_obj, &pipe->ep_char);
     //Add the pipe to the list of idle pipes in the port object
     TAILQ_INSERT_TAIL(&port->pipes_idle_tailq, pipe, tailq_entry);
     port->num_pipes_idle++;
     HCD_EXIT_CRITICAL();
+
     *pipe_hdl = (hcd_pipe_handle_t)pipe;
-    return ret;
+    return ESP_OK;
 
 err:
-    free(xfer_desc_list);
+    for (int i = 0; i < NUM_BUFFERS; i++) {
+        buffer_block_free(buffers[i]);
+    }
     free(chan_obj);
     free(pipe);
     return ret;
@@ -1504,7 +1896,9 @@ esp_err_t hcd_pipe_free(hcd_pipe_handle_t pipe_hdl)
     pipe_t *pipe = (pipe_t *)pipe_hdl;
     HCD_ENTER_CRITICAL();
     //Check that all IRPs have been removed and pipe has no pending events
-    HCD_CHECK_FROM_CRIT(pipe->inflight_irp == NULL
+    HCD_CHECK_FROM_CRIT(!pipe->multi_buffer_flags.buffer_is_executing
+                        && pipe->multi_buffer_flags.buffer_num_to_parse == 0
+                        && pipe->multi_buffer_flags.buffer_num_to_exec == 0
                         && pipe->num_irp_pending == 0
                         && pipe->num_irp_done == 0,
                         ESP_ERR_INVALID_STATE);
@@ -1515,31 +1909,49 @@ esp_err_t hcd_pipe_free(hcd_pipe_handle_t pipe_hdl)
     HCD_EXIT_CRITICAL();
 
     //Free pipe resources
-    free(pipe->xfer_desc_list);
+    for (int i = 0; i < NUM_BUFFERS; i++) {
+        buffer_block_free(pipe->buffers[i]);
+    }
     free(pipe->chan_obj);
     free(pipe);
     return ESP_OK;
 }
 
-esp_err_t hcd_pipe_update(hcd_pipe_handle_t pipe_hdl, uint8_t dev_addr, int mps)
+esp_err_t hcd_pipe_update_mps(hcd_pipe_handle_t pipe_hdl, int mps)
 {
     pipe_t *pipe = (pipe_t *)pipe_hdl;
     HCD_ENTER_CRITICAL();
     //Check if pipe is in the correct state to be updated
     HCD_CHECK_FROM_CRIT(pipe->state != HCD_PIPE_STATE_INVALID
-                        && !pipe->flags.pipe_cmd_processing
+                        && !pipe->cs_flags.pipe_cmd_processing
                         && pipe->num_irp_pending == 0
                         && pipe->num_irp_done == 0,
                         ESP_ERR_INVALID_STATE);
-    //Check that all IRPs have been removed and pipe has no pending events
-    pipe->ep_char.dev_addr = dev_addr;
     pipe->ep_char.mps = mps;
-    usbh_hal_chan_set_ep_char(pipe->chan_obj, &pipe->ep_char);
+    //Update the underlying channel's registers
+    usbh_hal_chan_set_ep_char(pipe->port->hal, pipe->chan_obj, &pipe->ep_char);
     HCD_EXIT_CRITICAL();
     return ESP_OK;
 }
 
-void *hcd_pipe_get_ctx(hcd_pipe_handle_t pipe_hdl)
+esp_err_t hcd_pipe_update_dev_addr(hcd_pipe_handle_t pipe_hdl, uint8_t dev_addr)
+{
+    pipe_t *pipe = (pipe_t *)pipe_hdl;
+    HCD_ENTER_CRITICAL();
+    //Check if pipe is in the correct state to be updated
+    HCD_CHECK_FROM_CRIT(pipe->state != HCD_PIPE_STATE_INVALID
+                        && !pipe->cs_flags.pipe_cmd_processing
+                        && pipe->num_irp_pending == 0
+                        && pipe->num_irp_done == 0,
+                        ESP_ERR_INVALID_STATE);
+    pipe->ep_char.dev_addr = dev_addr;
+    //Update the underlying channel's registers
+    usbh_hal_chan_set_ep_char(pipe->port->hal, pipe->chan_obj, &pipe->ep_char);
+    HCD_EXIT_CRITICAL();
+    return ESP_OK;
+}
+
+void *hcd_pipe_get_context(hcd_pipe_handle_t pipe_hdl)
 {
     pipe_t *pipe = (pipe_t *)pipe_hdl;
     void *ret;
@@ -1573,17 +1985,17 @@ esp_err_t hcd_pipe_command(hcd_pipe_handle_t pipe_hdl, hcd_pipe_cmd_t command)
 
     HCD_ENTER_CRITICAL();
     //Cannot execute pipe commands the pipe is already executing a command, or if the pipe or its port are no longer valid
-    if (pipe->flags.pipe_cmd_processing || !pipe->port->flags.conn_devc_ena || pipe->state == HCD_PIPE_STATE_INVALID) {
+    if (pipe->cs_flags.pipe_cmd_processing || !pipe->port->flags.conn_devc_ena || pipe->state == HCD_PIPE_STATE_INVALID) {
         ret = ESP_ERR_INVALID_STATE;
     } else {
-        pipe->flags.pipe_cmd_processing = 1;
+        pipe->cs_flags.pipe_cmd_processing = 1;
         switch (command) {
             case HCD_PIPE_CMD_ABORT: {
                 //Retire all scheduled IRPs. Pipe's state remains unchanged
                 if (!_pipe_wait_done(pipe)) {   //Stop any on going transfers
                     ret = ESP_ERR_INVALID_RESPONSE;
-                    break;
                 }
+                _buffer_flush_all(pipe, true);  //Some buffers might still be filled. Flush them
                 _pipe_retire(pipe, true);  //Retire any pending transfers
                 break;
             }
@@ -1593,6 +2005,7 @@ esp_err_t hcd_pipe_command(hcd_pipe_handle_t pipe_hdl, hcd_pipe_cmd_t command)
                     ret = ESP_ERR_INVALID_RESPONSE;
                     break;
                 }
+                _buffer_flush_all(pipe, true);  //Some buffers might still be filled. Flush them
                 _pipe_retire(pipe, true);  //Retire any pending transfers
                 pipe->state = HCD_PIPE_STATE_ACTIVE;
                 break;
@@ -1602,10 +2015,11 @@ esp_err_t hcd_pipe_command(hcd_pipe_handle_t pipe_hdl, hcd_pipe_cmd_t command)
                 if (pipe->state == HCD_PIPE_STATE_HALTED) {
                     pipe->state = HCD_PIPE_STATE_ACTIVE;
                     //Start the next pending transfer if it exists
-                    if (_pipe_get_next_irp(pipe)) {
-                        //Fill the descriptor list with the IRP and start the transfer
-                        _xfer_desc_list_fill(pipe);
-                        usbh_hal_chan_activate(pipe->chan_obj, 0);  //Start with the first descriptor
+                    if (_buffer_can_fill(pipe)) {
+                        _buffer_fill(pipe);
+                    }
+                    if (_buffer_can_exec(pipe)) {
+                        _buffer_exec(pipe);
                     }
                 }
                 break;
@@ -1620,7 +2034,7 @@ esp_err_t hcd_pipe_command(hcd_pipe_handle_t pipe_hdl, hcd_pipe_cmd_t command)
                 break;
             }
         }
-        pipe->flags.pipe_cmd_processing = 0;
+        pipe->cs_flags.pipe_cmd_processing = 0;
     }
     HCD_EXIT_CRITICAL();
     return ret;
@@ -1637,160 +2051,471 @@ hcd_pipe_event_t hcd_pipe_get_event(hcd_pipe_handle_t pipe_hdl)
     return ret;
 }
 
-// ---------------------------------------------- HCD Transfer Descriptors ---------------------------------------------
+// ------------------------------------------------- Buffer Control ----------------------------------------------------
 
-// ----------------------- Private -------------------------
+static inline void _buffer_fill_ctrl(dma_buffer_block_t *buffer, usb_irp_t *irp)
+{
+    //Get information about the control transfer by analyzing the setup packet (the first 8 bytes of the IRP's data)
+    usb_ctrl_req_t *ctrl_req = (usb_ctrl_req_t *)irp->data_buffer;
+    bool data_stg_in = (ctrl_req->bRequestType & USB_B_REQUEST_TYPE_DIR_IN);
+    bool data_stg_skip = (irp->num_bytes == 0);
+    //Fill setup stage
+    usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, 0, irp->data_buffer, sizeof(usb_ctrl_req_t),
+                            USBH_HAL_XFER_DESC_FLAG_SETUP | USBH_HAL_XFER_DESC_FLAG_HOC);
+    //Fill data stage
+    if (data_stg_skip) {
+        //Not data stage. Fill with an empty descriptor
+        usbh_hal_xfer_desc_clear(buffer->xfer_desc_list, 1);
+    } else {
+        //Fill data stage
+        usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, 1, irp->data_buffer + sizeof(usb_ctrl_req_t), irp->num_bytes,
+                                ((data_stg_in) ? USBH_HAL_XFER_DESC_FLAG_IN : 0) | USBH_HAL_XFER_DESC_FLAG_HOC);
+    }
+    //Fill status stage (i.e., a zero length packet). If data stage is skipped, the status stage is always IN.
+    usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, 2, NULL, 0,
+                            ((data_stg_in && !data_stg_skip) ? 0 : USBH_HAL_XFER_DESC_FLAG_IN) | USBH_HAL_XFER_DESC_FLAG_HOC);
+    //Update buffer flags
+    buffer->flags.ctrl.data_stg_in = data_stg_in;
+    buffer->flags.ctrl.data_stg_skip = data_stg_skip;
+    buffer->flags.ctrl.cur_stg = 0;
+}
+
+static inline void _buffer_fill_bulk(dma_buffer_block_t *buffer, usb_irp_t *irp, bool is_in)
+{
+    if (is_in) {
+        usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, 0, irp->data_buffer, irp->num_bytes,
+                                USBH_HAL_XFER_DESC_FLAG_IN | USBH_HAL_XFER_DESC_FLAG_HOC);
+    } else if (irp->flags & USB_IRP_FLAG_ZERO_PACK) {
+        //We need to add an extra zero length packet, so two descriptors are used
+        usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, 0, irp->data_buffer, irp->num_bytes, 0);
+        usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, 1, NULL, 0, USBH_HAL_XFER_DESC_FLAG_HOC);
+    } else {
+        usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, 0, irp->data_buffer, irp->num_bytes, USBH_HAL_XFER_DESC_FLAG_HOC);
+    }
+    //Update buffer flags
+    buffer->flags.bulk.zero_len_packet = (is_in && (irp->flags & USB_IRP_FLAG_ZERO_PACK)) ? 1 : 0;
+}
+
+static inline void _buffer_fill_intr(dma_buffer_block_t *buffer, usb_irp_t *irp, bool is_in, int mps)
+{
+    int num_qtds;
+    if (is_in) {
+        assert(irp->num_bytes % mps == 0);  //IN transfers MUST be integer multiple of MPS
+        num_qtds = irp->num_bytes / mps;
+    } else {
+        num_qtds = irp->num_bytes / mps;    //Floor division for number of MPS packets
+        if (irp->num_bytes % irp->num_bytes > 0) {
+            num_qtds++; //For the last shot packet
+        }
+    }
+    assert(num_qtds <= XFER_LIST_LEN_INTR);
+    //Fill all but last descriptor
+    int bytes_filled = 0;
+    for (int i = 0; i < num_qtds - 1; i++) {
+        usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, i, &irp->data_buffer[bytes_filled], mps, (is_in) ? USBH_HAL_XFER_DESC_FLAG_IN : 0);
+        bytes_filled += mps;
+    }
+    //Fill in the last descriptor with HOC flag
+    usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, num_qtds - 1, &irp->data_buffer[bytes_filled], irp->num_bytes - bytes_filled,
+                            ((is_in) ? USBH_HAL_XFER_DESC_FLAG_IN : 0) | USBH_HAL_XFER_DESC_FLAG_HOC);
+    //Update buffer members and flags
+    buffer->flags.intr.num_qtds = num_qtds;
+}
 
-static void _xfer_desc_list_fill(pipe_t *pipe)
+static inline void _buffer_fill_isoc(dma_buffer_block_t *buffer, usb_irp_t *irp, bool is_in, int mps, int interval, int start_idx)
 {
-    //inflight_irp of the pipe must already set to the target IRP
-    assert(pipe->inflight_irp != NULL);
-    //Fill transfer descriptor list with a single IRP
-    usb_irp_t *usb_irp = pipe->inflight_irp;
+    assert(interval > 0);
+    int total_num_desc = irp->num_iso_packets * interval;
+    assert(total_num_desc <= XFER_LIST_LEN_ISOC);
+    int desc_idx = start_idx;
+    int bytes_filled = 0;
+    //For each packet, fill in a descriptor and a interval-1 blank descriptor after it
+    for (int pkt_idx = 0; pkt_idx < irp->num_iso_packets; pkt_idx++) {
+        int xfer_len = irp->iso_packet_desc[pkt_idx].length;
+        uint32_t flags = (is_in) ? USBH_HAL_XFER_DESC_FLAG_IN : 0;
+        if (pkt_idx == irp->num_iso_packets - 1) {
+            //Last packet, set the the HOC flag
+            flags |= USBH_HAL_XFER_DESC_FLAG_HOC;
+        }
+        usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, desc_idx, &irp->data_buffer[bytes_filled], xfer_len, flags);
+        bytes_filled += xfer_len;
+        if (++desc_idx >= XFER_LIST_LEN_ISOC) {
+            desc_idx = 0;
+        }
+        //Clear descriptors for unscheduled frames
+        for (int i = 0; i < interval - 1; i++) {
+            usbh_hal_xfer_desc_clear(buffer->xfer_desc_list, desc_idx);
+            if (++desc_idx >= XFER_LIST_LEN_ISOC) {
+                desc_idx = 0;
+            }
+        }
+    }
+    //Update buffer members and flags
+    buffer->flags.isoc.num_qtds = total_num_desc;
+    buffer->flags.isoc.interval = interval;
+    buffer->flags.isoc.irp_start_idx = start_idx;
+    buffer->flags.isoc.next_irp_start_idx = desc_idx;
+}
+
+static void _buffer_fill(pipe_t *pipe)
+{
+    //Get an IRP from the pending tailq
+    usb_irp_t *irp = TAILQ_FIRST(&pipe->pending_irp_tailq);
+    assert(pipe->num_irp_pending > 0 && irp != NULL);
+    TAILQ_REMOVE(&pipe->pending_irp_tailq, irp, tailq_entry);
+    pipe->num_irp_pending--;
+
+    //Select the inactive buffer
+    assert(pipe->multi_buffer_flags.buffer_num_to_exec <= NUM_BUFFERS);
+    dma_buffer_block_t *buffer_to_fill = pipe->buffers[pipe->multi_buffer_flags.wr_idx];
+    assert(buffer_to_fill->irp == NULL);
+    bool is_in = pipe->ep_char.bEndpointAddress & USB_B_ENDPOINT_ADDRESS_EP_DIR_MASK;
+    int mps = pipe->ep_char.mps;
     switch (pipe->ep_char.type) {
-        case USB_XFER_TYPE_CTRL: {
-            //Get information about the control transfer by analyzing the setup packet (the first 8 bytes)
-            usb_ctrl_req_t *ctrl_req = (usb_ctrl_req_t *)usb_irp->data_buffer;
-            pipe->flags.ctrl_data_stg_in = ((ctrl_req->bRequestType & USB_B_REQUEST_TYPE_DIR_IN) != 0);
-            pipe->flags.ctrl_data_stg_skip = (usb_irp->num_bytes == 0);
-
-            //Fill setup stage
-            usbh_hal_xfer_desc_fill(pipe->xfer_desc_list, 0, usb_irp->data_buffer, sizeof(usb_ctrl_req_t),
-                                    USBH_HAL_XFER_DESC_FLAG_SETUP | USBH_HAL_XFER_DESC_FLAG_HALT);
-            if (pipe->flags.ctrl_data_stg_skip) {
-                //Fill a NULL packet if there is no data stage
-                usbh_hal_xfer_desc_fill(pipe->xfer_desc_list, 1, NULL, 0, USBH_HAL_XFER_DESC_FLAG_NULL);
+        case USB_PRIV_XFER_TYPE_CTRL: {
+            _buffer_fill_ctrl(buffer_to_fill, irp);
+            break;
+        }
+        case USB_PRIV_XFER_TYPE_ISOCHRONOUS: {
+            uint32_t start_idx;
+            if (pipe->multi_buffer_flags.buffer_num_to_exec == 0) {
+                //There are no more previously filled buffers to execute. We need to calculate a new start index based on HFNUM and the pipe's schedule
+                uint32_t cur_frame_num = usbh_hal_port_get_cur_frame_num(pipe->port->hal);
+                uint32_t cur_mod_idx_no_offset = (cur_frame_num - pipe->ep_char.periodic.phase_offset_frames) & (XFER_LIST_LEN_ISOC - 1);    //Get the modulated index (i.e., the Nth desc in the descriptor list)
+                //This is the non-offset modulated QTD index of the last scheduled interval
+                uint32_t last_interval_mod_idx_no_offset = (cur_mod_idx_no_offset / pipe->ep_char.periodic.interval) * pipe->ep_char.periodic.interval; //Floor divide and the multiply again
+                uint32_t next_interval_idx_no_offset = (last_interval_mod_idx_no_offset + pipe->ep_char.periodic.interval);
+                //We want at least a half interval or 2 frames of buffer space
+                if (next_interval_idx_no_offset - cur_mod_idx_no_offset > (pipe->ep_char.periodic.interval / 2)
+                    && next_interval_idx_no_offset - cur_mod_idx_no_offset >= 2) {
+                        start_idx = (next_interval_idx_no_offset + pipe->ep_char.periodic.phase_offset_frames) & (XFER_LIST_LEN_ISOC - 1);
+                } else {
+                    //Not enough time until the next schedule, add another interval to it.
+                        start_idx =  (next_interval_idx_no_offset + pipe->ep_char.periodic.interval + pipe->ep_char.periodic.phase_offset_frames) & (XFER_LIST_LEN_ISOC - 1);
+                }
             } else {
-                //Fill data stage
-                usbh_hal_xfer_desc_fill(pipe->xfer_desc_list, 1, usb_irp->data_buffer + sizeof(usb_ctrl_req_t), usb_irp->num_bytes,
-                                        ((pipe->flags.ctrl_data_stg_in) ? USBH_HAL_XFER_DESC_FLAG_IN : 0) | USBH_HAL_XFER_DESC_FLAG_HALT);
+                //Start index is based on previously filled buffer
+                uint32_t prev_buffer_idx = (pipe->multi_buffer_flags.wr_idx - 1) & (NUM_BUFFERS - 1);
+                dma_buffer_block_t *prev_filled_buffer = pipe->buffers[prev_buffer_idx];
+                start_idx = prev_filled_buffer->flags.isoc.next_irp_start_idx;
             }
-            //Fill status stage (i.e., a zero length packet). If data stage is skipped, the status stage is always IN.
-            usbh_hal_xfer_desc_fill(pipe->xfer_desc_list, 2, NULL, 0,
-                                    ((pipe->flags.ctrl_data_stg_in && !pipe->flags.ctrl_data_stg_skip) ? 0 : USBH_HAL_XFER_DESC_FLAG_IN) | USBH_HAL_XFER_DESC_FLAG_HALT);
+            _buffer_fill_isoc(buffer_to_fill, irp, is_in, mps, (int)pipe->ep_char.periodic.interval, start_idx);
+            break;
+        }
+        case USB_PRIV_XFER_TYPE_BULK: {
+            _buffer_fill_bulk(buffer_to_fill, irp, is_in);
+            break;
+        }
+        case USB_PRIV_XFER_TYPE_INTR: {
+            _buffer_fill_intr(buffer_to_fill, irp, is_in, mps);
+            break;
+        }
+        default: {
+            abort();
+            break;
+        }
+    }
+    buffer_to_fill->irp = irp;
+    IRP_STATE_SET(irp->reserved_flags, IRP_STATE_INFLIGHT);
+    //Update multi buffer flags
+    pipe->multi_buffer_flags.wr_idx++;
+    pipe->multi_buffer_flags.buffer_num_to_fill--;
+    pipe->multi_buffer_flags.buffer_num_to_exec++;
+}
+
+static void _buffer_exec(pipe_t *pipe)
+{
+    assert(pipe->multi_buffer_flags.rd_idx != pipe->multi_buffer_flags.wr_idx || pipe->multi_buffer_flags.buffer_num_to_exec > 0);
+    dma_buffer_block_t *buffer_to_exec = pipe->buffers[pipe->multi_buffer_flags.rd_idx];
+    assert(buffer_to_exec->irp != NULL);
+
+    uint32_t start_idx;
+    int desc_list_len;
+    switch (pipe->ep_char.type) {
+        case USB_PRIV_XFER_TYPE_CTRL: {
+            start_idx = 0;
+            desc_list_len = XFER_LIST_LEN_CTRL;
             //Set the channel's direction to OUT and PID to 0 respectively for the the setup stage
             usbh_hal_chan_set_dir(pipe->chan_obj, false);   //Setup stage is always OUT
             usbh_hal_chan_set_pid(pipe->chan_obj, 0);   //Setup stage always has a PID of DATA0
             break;
         }
-        case USB_XFER_TYPE_BULK: {
-            bool is_in = pipe->ep_char.bEndpointAddress & USB_B_ENDPOINT_ADDRESS_EP_DIR_MASK;
-            usbh_hal_xfer_desc_fill(pipe->xfer_desc_list, 0, usb_irp->data_buffer, usb_irp->num_bytes,
-                                    ((is_in) ? USBH_HAL_XFER_DESC_FLAG_IN : 0) | USBH_HAL_XFER_DESC_FLAG_HALT);
+        case USB_PRIV_XFER_TYPE_ISOCHRONOUS: {
+            start_idx = buffer_to_exec->flags.isoc.irp_start_idx;
+            desc_list_len = XFER_LIST_LEN_ISOC;
+            break;
+        }
+        case USB_PRIV_XFER_TYPE_BULK: {
+            start_idx = 0;
+            desc_list_len = (buffer_to_exec->flags.bulk.zero_len_packet) ? XFER_LIST_LEN_BULK : 1;
+            break;
+        }
+        case USB_PRIV_XFER_TYPE_INTR: {
+            start_idx = 0;
+            desc_list_len = buffer_to_exec->flags.intr.num_qtds;
             break;
         }
         default: {
-            break;  //Isoc and Interrupt transfers not supported yet
+            start_idx = 0;
+            desc_list_len = 0;
+            abort();
+            break;
         }
     }
-    //Claim slot
-    usbh_hal_chan_slot_acquire(pipe->chan_obj, pipe->xfer_desc_list, pipe->flags.xfer_desc_list_len, (void *)pipe);
+    //Update buffer and multi buffer flags
+    buffer_to_exec->status_flags.executing = 1;
+    pipe->multi_buffer_flags.buffer_is_executing = 1;
+    usbh_hal_chan_activate(pipe->chan_obj, buffer_to_exec->xfer_desc_list, desc_list_len, start_idx);
 }
 
-static void _xfer_desc_list_continue(pipe_t *pipe)
+static bool _buffer_check_done(pipe_t *pipe)
 {
-    int next_idx = usbh_hal_chan_get_next_desc_index(pipe->chan_obj);
-    bool next_dir_is_in;    //Next descriptor direction is IN
-    int next_pid;           //Next PID (DATA0 or DATA 1)
-    int num_to_skip;        //Number of descriptors to skip
-    if (next_idx == 1) {
-        //Just finished setup stage
-        if (pipe->flags.ctrl_data_stg_skip) {
+    if (pipe->ep_char.type != USB_PRIV_XFER_TYPE_CTRL) {
+        return true;
+    }
+    //Only control transfers need to be continued
+    dma_buffer_block_t *buffer_inflight = pipe->buffers[pipe->multi_buffer_flags.rd_idx];
+    bool next_dir_is_in;
+    int next_pid;
+    if (buffer_inflight->flags.ctrl.cur_stg == 0) { //Just finished control stage
+        if (buffer_inflight->flags.ctrl.data_stg_skip) {
             //Skipping data stage. Go straight to status stage
             next_dir_is_in = true;     //With no data stage, status stage must be IN
             next_pid = 1;       //Status stage always has a PID of DATA1
-            num_to_skip = 1;    //Skip over the null descriptor representing the skipped data stage
+            buffer_inflight->flags.ctrl.cur_stg = 2;    //Skip over the null descriptor representing the skipped data stage
         } else {
             //Go to data stage
-            next_dir_is_in = pipe->flags.ctrl_data_stg_in;
+            next_dir_is_in = buffer_inflight->flags.ctrl.data_stg_in;
             next_pid = 1;   //Data stage always starts with a PID of DATA1
-            num_to_skip = 0;
+            buffer_inflight->flags.ctrl.cur_stg = 1;
         }
-    } else {    //next_idx == 2
-        //Going to status stage from data stage
-        next_dir_is_in = !pipe->flags.ctrl_data_stg_in;     //Status stage is opposite direction of data stage
+    } else if (buffer_inflight->flags.ctrl.cur_stg == 1) {  //Just finished data stage. Go to status stage
+        next_dir_is_in = !buffer_inflight->flags.ctrl.data_stg_in;  //Status stage is always the opposite direction of data stage
         next_pid = 1;   //Status stage always has a PID of DATA1
-        num_to_skip = 0;
+        buffer_inflight->flags.ctrl.cur_stg = 2;
+    } else {    //Just finished status stage. Transfer is complete
+        return true;
     }
-
+    //Continue the control transfer
     usbh_hal_chan_set_dir(pipe->chan_obj, next_dir_is_in);
     usbh_hal_chan_set_pid(pipe->chan_obj, next_pid);
-    usbh_hal_chan_activate(pipe->chan_obj, num_to_skip);    //Start the next stage
+    usbh_hal_chan_activate(pipe->chan_obj, buffer_inflight->xfer_desc_list, XFER_LIST_LEN_CTRL, buffer_inflight->flags.ctrl.cur_stg);
+    return false;
 }
 
-static void _xfer_desc_list_parse(pipe_t *pipe, bool error_occurred)
+static inline void _buffer_parse_ctrl(dma_buffer_block_t *buffer)
 {
-    assert(pipe->inflight_irp != NULL);
-    //Release the slot
-    void *xfer_desc_list;
-    int xfer_desc_len;
-    usbh_hal_chan_slot_release(pipe->chan_obj, &xfer_desc_list, &xfer_desc_len);
-    assert(xfer_desc_list == pipe->xfer_desc_list);
-    (void) xfer_desc_len;
-
-    //Parse the transfer descriptor list for the result of the transfer
-    usb_irp_t *irp = pipe->inflight_irp;
-    usb_transfer_status_t xfer_status;
-    int xfer_rem_len;
-    if (error_occurred) {
-        //Either a pipe error has occurred or the pipe is no longer valid
-        if (pipe->state == HCD_PIPE_STATE_INVALID) {
-            xfer_status = USB_TRANSFER_STATUS_NO_DEVICE;
+    usb_irp_t *irp = buffer->irp;
+    //Update IRP's actual number of bytes
+    if (buffer->flags.ctrl.data_stg_skip)     {
+        //There was no data stage. Just set the actual length to zero
+        irp->actual_num_bytes = 0;
+    } else {
+        //Parse the data stage for the remaining length
+        int rem_len;
+        int desc_status;
+        usbh_hal_xfer_desc_parse(buffer->xfer_desc_list, 1, &rem_len, &desc_status);
+        assert(desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS);
+        assert(rem_len <= irp->num_bytes);
+        irp->actual_num_bytes = irp->num_bytes - rem_len;
+    }
+    //Update IRP status
+    irp->status = USB_TRANSFER_STATUS_COMPLETED;
+    //Clear the descriptor list
+    memset(buffer->xfer_desc_list, XFER_LIST_LEN_CTRL, sizeof(usbh_ll_dma_qtd_t));
+}
+
+static inline void _buffer_parse_bulk(dma_buffer_block_t *buffer)
+{
+    usb_irp_t *irp = buffer->irp;
+    //Update IRP's actual number of bytes
+    int rem_len;
+    int desc_status;
+    usbh_hal_xfer_desc_parse(buffer->xfer_desc_list, 0, &rem_len, &desc_status);
+    assert(desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS);
+    assert(rem_len <= irp->num_bytes);
+    irp->actual_num_bytes = irp->num_bytes - rem_len;
+    //Update IRP's status
+    irp->status = USB_TRANSFER_STATUS_COMPLETED;
+    //Clear the descriptor list
+    memset(buffer->xfer_desc_list, XFER_LIST_LEN_BULK, sizeof(usbh_ll_dma_qtd_t));
+}
+
+static inline void _buffer_parse_intr(dma_buffer_block_t *buffer, bool is_in, int mps)
+{
+    usb_irp_t *irp = buffer->irp;
+    int intr_stop_idx = buffer->status_flags.stop_idx;
+    if (is_in) {
+        if (intr_stop_idx > 0) { //This is an early stop (short packet)
+            assert(intr_stop_idx <= buffer->flags.intr.num_qtds);
+            int rem_len;
+            int desc_status;
+            for (int i = 0; i < intr_stop_idx - 1; i++) {    //Check all packets before the short
+                usbh_hal_xfer_desc_parse(buffer->xfer_desc_list, i, &rem_len, &desc_status);
+                assert(rem_len == 0 && desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS);
+            }
+            //Check the short packet
+            usbh_hal_xfer_desc_parse(buffer->xfer_desc_list, intr_stop_idx - 1, &rem_len, &desc_status);
+            assert(rem_len > 0 && desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS);
+            //Update actual bytes
+            irp->actual_num_bytes = (mps * intr_stop_idx - 2) + (mps - rem_len);
         } else {
-            //Must have been a pipe error event
-            switch (pipe->last_event) {
-                case HCD_PIPE_EVENT_ERROR_XFER: //Excessive transaction error
-                    xfer_status = USB_TRANSFER_STATUS_ERROR;
-                    break;
-                case HCD_PIPE_EVENT_ERROR_OVERFLOW:
-                    xfer_status = USB_TRANSFER_STATUS_OVERFLOW;
-                    break;
-                case HCD_PIPE_EVENT_ERROR_STALL:
-                    xfer_status = USB_TRANSFER_STATUS_STALL;
-                    break;
-                default:
-                    //HCD_PIPE_EVENT_ERROR_IRP_NOT_AVAIL should never occur
-                    abort();
-                    break;
+            //Check that all but the last packet transmitted MPS
+            for (int i = 0; i < buffer->flags.intr.num_qtds - 1; i++) {
+                int rem_len;
+                int desc_status;
+                usbh_hal_xfer_desc_parse(buffer->xfer_desc_list, i, &rem_len, &desc_status);
+                assert(rem_len == 0 && desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS);
             }
+            //Check the last packet
+            int last_packet_rem_len;
+            int last_packet_desc_status;
+            usbh_hal_xfer_desc_parse(buffer->xfer_desc_list, buffer->flags.intr.num_qtds - 1, &last_packet_rem_len, &last_packet_desc_status);
+            assert(last_packet_desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS);
+            //All packets except last MUST be MPS. So just deduct the remaining length of the last packet to get actual number of bytes
+            irp->actual_num_bytes = irp->num_bytes - last_packet_rem_len;
         }
-        //We assume no bytes transmitted because of an error.
-        xfer_rem_len = irp->num_bytes;
     } else {
+        //OUT INTR transfers can only complete successfully if all MPS packets have been transmitted. Double check
+        for (int i = 0 ; i < buffer->flags.intr.num_qtds; i++) {
+            int rem_len;
+            int desc_status;
+            usbh_hal_xfer_desc_parse(buffer->xfer_desc_list, i, &rem_len, &desc_status);
+            assert(rem_len == 0 && desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS);
+        }
+        irp->actual_num_bytes = irp->num_bytes;
+    }
+    //Update IRP's status
+    irp->status = USB_TRANSFER_STATUS_COMPLETED;
+    //Clear the descriptor list
+    memset(buffer->xfer_desc_list, XFER_LIST_LEN_INTR, sizeof(usbh_ll_dma_qtd_t));
+}
+
+static inline void _buffer_parse_isoc(dma_buffer_block_t *buffer, bool is_in)
+{
+    usb_irp_t *irp = buffer->irp;
+    int desc_idx = buffer->flags.isoc.irp_start_idx;    //Descriptor index tracks which descriptor in the QTD list
+    for (int pkt_idx = 0; pkt_idx < irp->num_iso_packets; pkt_idx++) {
+        //Clear the filled descriptor
+        int rem_len;
         int desc_status;
+        usbh_hal_xfer_desc_parse(buffer->xfer_desc_list, desc_idx, &rem_len, &desc_status);
+        usbh_hal_xfer_desc_clear(buffer->xfer_desc_list, desc_idx);
+        assert(rem_len == 0 || is_in);
+        assert(desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS || USBH_HAL_XFER_DESC_STS_NOT_EXECUTED);
+        assert(rem_len <= irp->iso_packet_desc[pkt_idx].length);    //Check for DMA errata
+        //Update ISO packet actual length and status
+        irp->iso_packet_desc[pkt_idx].actual_length = irp->iso_packet_desc[pkt_idx].length - rem_len;
+        irp->iso_packet_desc[pkt_idx].status = (desc_status == USBH_HAL_XFER_DESC_STS_NOT_EXECUTED) ? USB_TRANSFER_STATUS_SKIPPED : USB_TRANSFER_STATUS_COMPLETED;
+        //A descriptor is also allocated for unscheduled frames. We need to skip over them
+        desc_idx += buffer->flags.isoc.interval;
+        if (desc_idx >= XFER_LIST_LEN_INTR) {
+            desc_idx -= XFER_LIST_LEN_INTR;
+        }
+    }
+}
+
+static inline void _buffer_parse_error(dma_buffer_block_t *buffer)
+{
+    //The IRP had an error, so we consider that NO bytes were transferred
+    usb_irp_t *irp = buffer->irp;
+    irp->actual_num_bytes = 0;
+    for (int i = 0; i < irp->num_iso_packets; i++) {
+        irp->iso_packet_desc[i].actual_length = 0;
+    }
+    //Update status of IRP
+    if (buffer->status_flags.cancelled) {
+        irp->status = USB_TRANSFER_STATUS_CANCELED;
+    } else if (buffer->status_flags.pipe_state == HCD_PIPE_STATE_INVALID) {
+        irp->status = USB_TRANSFER_STATUS_NO_DEVICE;
+    } else {
+        switch (buffer->status_flags.pipe_event) {
+            case HCD_PIPE_EVENT_ERROR_XFER: //Excessive transaction error
+                irp->status = USB_TRANSFER_STATUS_ERROR;
+                break;
+            case HCD_PIPE_EVENT_ERROR_OVERFLOW:
+                irp->status = USB_TRANSFER_STATUS_OVERFLOW;
+                break;
+            case HCD_PIPE_EVENT_ERROR_STALL:
+                irp->status = USB_TRANSFER_STATUS_STALL;
+                break;
+            case HCD_PIPE_EVENT_IRP_DONE:   //Special case where we are cancelling an IRP due to pipe_retire
+                irp->status = USB_TRANSFER_STATUS_CANCELED;
+                break;
+            default:
+                //HCD_PIPE_EVENT_ERROR_IRP_NOT_AVAIL should never occur
+                abort();
+                break;
+        }
+    }
+    //Clear error flags
+    buffer->status_flags.val = 0;
+}
+
+static void _buffer_parse(pipe_t *pipe)
+{
+    assert(pipe->multi_buffer_flags.buffer_num_to_parse > 0);
+    dma_buffer_block_t *buffer_to_parse = pipe->buffers[pipe->multi_buffer_flags.fr_idx];
+    assert(buffer_to_parse->irp != NULL);
+    bool is_in = pipe->ep_char.bEndpointAddress & USB_B_ENDPOINT_ADDRESS_EP_DIR_MASK;
+    int mps = pipe->ep_char.mps;
+
+    //Parsing the buffer will update the buffer's corresponding IRP
+    if (buffer_to_parse->status_flags.error_occurred) {
+        _buffer_parse_error(buffer_to_parse);
+    } else {
         switch (pipe->ep_char.type) {
-            case USB_XFER_TYPE_CTRL: {
-                if (pipe->flags.ctrl_data_stg_skip) {
-                    //There was no data stage. Just set it as successful
-                    desc_status = USBH_HAL_XFER_DESC_STS_SUCCESS;
-                    xfer_rem_len = 0;
-                } else {
-                    //Check the data stage (index 1)
-                    usbh_hal_xfer_desc_parse(pipe->xfer_desc_list, 1, &xfer_rem_len, &desc_status);
-                }
+            case USB_PRIV_XFER_TYPE_CTRL: {
+                _buffer_parse_ctrl(buffer_to_parse);
+                break;
+            }
+            case USB_PRIV_XFER_TYPE_ISOCHRONOUS: {
+                _buffer_parse_isoc(buffer_to_parse, is_in);
+                break;
+            }
+            case USB_PRIV_XFER_TYPE_BULK: {
+                _buffer_parse_bulk(buffer_to_parse);
                 break;
             }
-            case USB_XFER_TYPE_BULK: {
-                usbh_hal_xfer_desc_parse(pipe->xfer_desc_list, 0, &xfer_rem_len, &desc_status);
+            case USB_PRIV_XFER_TYPE_INTR: {
+                _buffer_parse_intr(buffer_to_parse, is_in, mps);
                 break;
             }
             default: {
-                //We don't supportISOC and INTR pipes yet
-                desc_status = USBH_HAL_XFER_DESC_STS_NOT_EXECUTED;
-                xfer_rem_len = 0;
-                xfer_status = USB_TRANSFER_STATUS_ERROR;
                 abort();
                 break;
             }
         }
-        xfer_status = USB_TRANSFER_STATUS_COMPLETED;
-        assert(desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS);
     }
-    //Write back results to IRP
-    irp->actual_num_bytes = irp->num_bytes - xfer_rem_len;
-    irp->status = xfer_status;
+    usb_irp_t *irp = buffer_to_parse->irp;
+    IRP_STATE_SET(irp->reserved_flags, IRP_STATE_DONE);
+    buffer_to_parse->irp = NULL;
+    buffer_to_parse->flags.val = 0; //Clear flags
+    //Move the IRP to the done tailq
+    TAILQ_INSERT_TAIL(&pipe->done_irp_tailq, irp, tailq_entry);
+    pipe->num_irp_done++;
+    //Update multi buffer flags
+    pipe->multi_buffer_flags.fr_idx++;
+    pipe->multi_buffer_flags.buffer_num_to_parse--;
+    pipe->multi_buffer_flags.buffer_num_to_fill++;
+}
+
+static void _buffer_flush_all(pipe_t *pipe, bool cancelled)
+{
+    int cur_num_to_mark_done =  pipe->multi_buffer_flags.buffer_num_to_exec;
+    for (int i = 0; i < cur_num_to_mark_done; i++) {
+        //Mark any filled buffers as done
+        _buffer_done_error(pipe, 0, pipe->state, pipe->last_event, cancelled);
+    }
+    int cur_num_to_parse = pipe->multi_buffer_flags.buffer_num_to_parse;
+    for (int i = 0; i < cur_num_to_parse; i++) {
+        _buffer_parse(pipe);
+    }
+    //At this point, there should be no more filled buffers. Only IRPs in the pending or done tailq
 }
 
+// ---------------------------------------------- HCD Transfer Descriptors ---------------------------------------------
+
 // ----------------------- Public --------------------------
 
 esp_err_t hcd_irp_enqueue(hcd_pipe_handle_t pipe_hdl, usb_irp_t *irp)
@@ -1802,35 +2527,31 @@ esp_err_t hcd_irp_enqueue(hcd_pipe_handle_t pipe_hdl, usb_irp_t *irp)
     pipe_t *pipe = (pipe_t *)pipe_hdl;
 
     HCD_ENTER_CRITICAL();
-    //Check that pipe and port are in the corrrect state to receive IRPs
-    HCD_CHECK_FROM_CRIT(pipe->port->state == HCD_PORT_STATE_ENABLED     //The pipe's port must be in the correct state
-                        && pipe->state == HCD_PIPE_STATE_ACTIVE         //The pipe must be in the correct state
-                        && !pipe->flags.pipe_cmd_processing,            //Pipe cannot currently be processing a pipe command
+    //Check that pipe and port are in the correct state to receive IRPs
+    HCD_CHECK_FROM_CRIT(pipe->port->state == HCD_PORT_STATE_ENABLED         //The pipe's port must be in the correct state
+                        && pipe->state == HCD_PIPE_STATE_ACTIVE             //The pipe must be in the correct state
+                        && !pipe->cs_flags.pipe_cmd_processing,            //Pipe cannot currently be processing a pipe command
                         ESP_ERR_INVALID_STATE);
     //Use the IRP's reserved_ptr to store the pipe's
     irp->reserved_ptr = (void *)pipe;
-
-    //Check if we can start execution on the pipe immediately
-    if (!pipe->flags.paused && pipe->num_irp_pending == 0 && pipe->inflight_irp == NULL) {
-        //Pipe isn't executing any transfers. Start immediately
-        pipe->inflight_irp = irp;
-        _xfer_desc_list_fill(pipe);
-        usbh_hal_chan_activate(pipe->chan_obj, 0);  //Start with the first descriptor
-        //use the IRP's reserved_flags to store the IRP's current state
-        IRP_STATE_SET(irp->reserved_flags, IRP_STATE_INFLIGHT);
-        if (pipe->num_irp_done == 0) {
-            //This is the first IRP to be enqueued into the pipe. Move the pipe to the list of active pipes
-            TAILQ_REMOVE(&pipe->port->pipes_idle_tailq, pipe, tailq_entry);
-            TAILQ_INSERT_TAIL(&pipe->port->pipes_active_tailq, pipe, tailq_entry);
-            pipe->port->num_pipes_idle--;
-            pipe->port->num_pipes_queued++;
-        }
-    } else {
-        //Add the IRP to the pipe's pending tailq
-        TAILQ_INSERT_TAIL(&pipe->pending_irp_tailq, irp, tailq_entry);
-        pipe->num_irp_pending++;
-        //use the IRP's reserved_flags to store the IRP's current state
-        IRP_STATE_SET(irp->reserved_flags, IRP_STATE_PENDING);
+    //Add the IRP to the pipe's pending tailq
+    IRP_STATE_SET(irp->reserved_flags, IRP_STATE_PENDING);
+    TAILQ_INSERT_TAIL(&pipe->pending_irp_tailq, irp, tailq_entry);
+    pipe->num_irp_pending++;
+    //use the IRP's reserved_flags to store the IRP's current state
+    if (_buffer_can_fill(pipe)) {
+        _buffer_fill(pipe);
+    }
+    if (_buffer_can_exec(pipe)) {
+        _buffer_exec(pipe);
+    }
+    if (!pipe->cs_flags.is_active) {
+        //This is the first IRP to be enqueued into the pipe. Move the pipe to the list of active pipes
+        TAILQ_REMOVE(&pipe->port->pipes_idle_tailq, pipe, tailq_entry);
+        TAILQ_INSERT_TAIL(&pipe->port->pipes_active_tailq, pipe, tailq_entry);
+        pipe->port->num_pipes_idle--;
+        pipe->port->num_pipes_queued++;
+        pipe->cs_flags.is_active = 1;
     }
     HCD_EXIT_CRITICAL();
     return ESP_OK;
@@ -1850,12 +2571,15 @@ usb_irp_t *hcd_irp_dequeue(hcd_pipe_handle_t pipe_hdl)
         assert(irp->reserved_ptr == (void *)pipe && IRP_STATE_GET(irp->reserved_flags) == IRP_STATE_DONE);  //The IRP's reserved field should have been set to this pipe
         irp->reserved_ptr = NULL;
         IRP_STATE_SET(irp->reserved_flags, IRP_STATE_IDLE);
-        if (pipe->num_irp_done == 0 && pipe->num_irp_pending == 0) {
+        if (pipe->cs_flags.is_active
+            && pipe->num_irp_pending == 0 && pipe->num_irp_done == 0
+            && pipe->multi_buffer_flags.buffer_num_to_exec == 0 && pipe->multi_buffer_flags.buffer_num_to_parse == 0) {
             //This pipe has no more enqueued IRPs. Move the pipe to the list of idle pipes
             TAILQ_REMOVE(&pipe->port->pipes_active_tailq, pipe, tailq_entry);
             TAILQ_INSERT_TAIL(&pipe->port->pipes_idle_tailq, pipe, tailq_entry);
             pipe->port->num_pipes_idle++;
             pipe->port->num_pipes_queued--;
+            pipe->cs_flags.is_active = 0;
         }
     } else {
         //No more IRPs to dequeue from this pipe
@@ -1881,9 +2605,15 @@ esp_err_t hcd_irp_abort(usb_irp_t *irp)
         //Add it to the done queue
         TAILQ_INSERT_TAIL(&pipe->done_irp_tailq, irp, tailq_entry);
         pipe->num_irp_done++;
-        //Update the IRP's current state and status
+        //Update the IRP's current state, status, and actual length
         IRP_STATE_SET(irp->reserved_flags, IRP_STATE_DONE);
-        irp->status = USB_TRANSFER_STATUS_CANCELLED;
+        irp->actual_num_bytes = 0;
+        irp->status = USB_TRANSFER_STATUS_CANCELED;
+        //If this is an ISOC IRP, update the ISO packet descriptors as well
+        for (int i = 0; i < irp->num_iso_packets; i++) {
+            irp->iso_packet_desc[i].actual_length = 0;
+            irp->iso_packet_desc[i].status = USB_TRANSFER_STATUS_CANCELED;
+        }
     }// Otherwise, the IRP is in-flight or already done thus cannot be aborted
     HCD_EXIT_CRITICAL();
     return ESP_OK;
diff --git a/components/usb/maintainers.md b/components/usb/maintainers.md
index 849fae716d..ab243489b4 100644
--- a/components/usb/maintainers.md
+++ b/components/usb/maintainers.md
@@ -31,11 +31,19 @@ The HAL layer abstracts the DWC_OTG operating in Host Mode using Internal Scatte
 ## HAL Channels
 
 - Channels are essentially the controllers abstraction of USB pipes. At any one point in time, a channel can be configured to map to a particular endpoint on a particular connected device (i.e., a particular device address).
-- Channels have to be allocated and freed. It's possible to change a channel's endpoint characteristics (i.e., EP number, device address, direction, transfer type etc) so long as the channel is in the Halted state whilst doing so.
-- Channels transfer data using transfer descriptor lists (i.e., a list of DMA descriptors). Each channel has one slot for a single list. Use `usbh_hal_chan_slot_acquire()` to acquire a channel's list slot, and `usbh_hal_chan_activate()` to start the transfer.
-- Once a transfer is completed, an channel event should be generated. Use `usbh_hal_chan_slot_release()` to free the slot, allowing for another transfer list to acquire the slot.
-- To fill and parse a transfer descriptor list, use the `usbh_hal_xfer_desc_fill()` and `usbh_hal_xfer_desc_parse()` functions.
-- Each channel and each channel slot will allow the callers to set a context variable. This allows client to associate a particular channel or an acquired slot with client objects (e.g., associate a channel to a HCD pipe object).
+- Channels have to be allocated and freed. It's possible to change a channel's endpoint characteristics (i.e., EP number, device address, direction, transfer type etc) so long as the channel is halted (i.e., not actively executing transfer descriptors).
+  - Use `usbh_hal_chan_alloc()` to allocate a channel
+  - Once allocated, use `usbh_hal_chan_set_ep_char()` to set the Endpoint characteristics of the channel (i.e., the information of the endpoint that the channel is communicating with). There are also some `usbh_hal_chan_set...()` functions to change a particular characteristic.
+  - Once the channel is no longer needed, call `usbh_hal_chan_free()` to free the channel
+- Channels use a list of Queue Transfer Descriptors (QTDs) to executed USB transfers.
+  - A transfer descriptor list must be filled using `usbh_hal_xfer_desc_fill()`
+  - Once filled, a channel can be activated using `usbh_hal_chan_activate()`
+  - Once the channel is done (i.e., a descriptor with the `USBH_HAL_XFER_DESC_FLAG_HOC` is executed), a `USBH_HAL_CHAN_EVENT_CPLT` event is generated. The channel is now halted
+  - Call `usbh_hal_xfer_desc_parse()` to parse the results of the descriptor list
+  - If you need to halt the channel early (such as aborting a transfer), call `usbh_hal_chan_request_halt()`
+- In case of a channel error event:
+  - Call `usbh_hal_chan_get_error()` to get the specific channel error that occurred
+  - You must call `usbh_hal_chan_clear_error()` after an error to clear the error and allow the channel to continue to be used.
 
 # Host Controller Driver (HCD)
 
@@ -49,16 +57,18 @@ The HCD currently has the following limitations:
 - HCD **does not** "present the root hub and its behavior according to the hub class definition". We currently don't have a hub driver yet, so the port commands in the driver do not fully represent an interface of a USB hub as described in 10.4 of the USB2.0 spec.
 - No more than 8 pipes can be allocated at any one time due to underlying Host Controllers 8 channel limit. In the future, we could make particular pipes share a single Host Controller channel.
 - The HCD currently only supports Control and Bulk transfer types.
+- If you are connecting to a device with a large MPS requirements (e.g., Isochronous transfers), you may need to call `hcd_port_set_fifo_bias()` to adjust the size of the internal FIFO
 
 ## HCD Port
 
 - An HCD port can be as a simplified version of a port on the Root Hub of the host controller. However, the complexity of parsing Hub Requests is discarded in favor of port commands (`hcd_port_cmd_t`) as the current USB Host Stack does not support hubs yet.
 - A port must first initialized before it can be used. A port is identified by its handled of type `hcd_port_handle_t`
-- The port can be manipulated using commands such as
+- The port can be manipulated using commands such as:
   - Powering the port ON/OFF
   - Issuing reset/resume signals
 - The various host port events are represented in the `hcd_port_event_t` enumeration
 - When a fatal error (such as a sudden disconnection or a port over current), the port will be put into the HCD_PORT_STATE_RECOVERY state. The port can be deinitialized from there, or recovered using `hcd_port_recover()`. All the pipes routed through the port will be made invalid.
+- The FIFO bias of a port can be set using `hcd_port_set_fifo_bias()`. Biasing the FIFO will affect the permissible MPS sizes of pipes. For example, if the connected device has an IN endpoint with large MPS (e.g., 512 bytes), the FIFO should be biased as `HCD_PORT_FIFO_BIAS_RX`.
 
 ## HCD Pipes
 
diff --git a/components/usb/private_include/hcd.h b/components/usb/private_include/hcd.h
index 48d4547cb2..9e692f1d9d 100644
--- a/components/usb/private_include/hcd.h
+++ b/components/usb/private_include/hcd.h
@@ -38,7 +38,7 @@ extern "C" {
  */
 typedef enum {
     HCD_PORT_STATE_NOT_POWERED,     /**< The port is not powered */
-    HCD_PORT_STATE_DISCONNECTED,    /**< The port is powered but no device is conencted */
+    HCD_PORT_STATE_DISCONNECTED,    /**< The port is powered but no device is connected */
     HCD_PORT_STATE_DISABLED,        /**< A device has connected to the port but has not been reset. SOF/keep alive are not being sent */
     HCD_PORT_STATE_RESETTING,       /**< The port is issuing a reset condition */
     HCD_PORT_STATE_SUSPENDED,       /**< The port has been suspended. */
@@ -74,12 +74,12 @@ typedef enum {
  * On receiving a port event, hcd_port_handle_event() should be called to handle that event
  */
 typedef enum {
-    HCD_PORT_EVENT_NONE,            /**< No event has ocurred. Or the previous event is no longer valid */
+    HCD_PORT_EVENT_NONE,            /**< No event has occurred. Or the previous event is no longer valid */
     HCD_PORT_EVENT_CONNECTION,      /**< A device has been connected to the port */
     HCD_PORT_EVENT_DISCONNECTION,   /**< A device disconnection has been detected */
     HCD_PORT_EVENT_ERROR,           /**< A port error has been detected. Port is now HCD_PORT_STATE_RECOVERY  */
     HCD_PORT_EVENT_OVERCURRENT,     /**< Overcurrent detected on the port. Port is now HCD_PORT_STATE_RECOVERY */
-    HCD_PORT_EVENT_SUDDEN_DISCONN,  /**< The port has suddenly disconencted (i.e., there was an enabled device connected
+    HCD_PORT_EVENT_SUDDEN_DISCONN,  /**< The port has suddenly disconnected (i.e., there was an enabled device connected
                                          to the port when the disconnection occurred. Port is now HCD_PORT_STATE_RECOVERY. */
 } hcd_port_event_t;
 
@@ -152,6 +152,12 @@ typedef bool (*hcd_port_isr_callback_t)(hcd_port_handle_t port_hdl, hcd_port_eve
  */
 typedef bool (*hcd_pipe_isr_callback_t)(hcd_pipe_handle_t pipe_hdl, hcd_pipe_event_t pipe_event, void *user_arg, bool in_isr);
 
+typedef enum {
+    HCD_PORT_FIFO_BIAS_BALANCED,    /**< Balanced FIFO sizing for RX, Non-periodic TX, and periodic TX */
+    HCD_PORT_FIFO_BIAS_RX,          /**< Bias towards a large RX FIFO */
+    HCD_PORT_FIFO_BIAS_PTX,         /**< Bias towards periodic TX FIFO */
+} hcd_port_fifo_bias_t;
+
 /**
  * @brief HCD configuration structure
  */
@@ -165,7 +171,7 @@ typedef struct {
 typedef struct {
     hcd_port_isr_callback_t callback;       /**< HCD port event callback */
     void *callback_arg;                     /**< User argument for HCD port callback */
-    void *context;
+    void *context;                          /**< Context variable used to associate the port with upper layer object */
 } hcd_port_config_t;
 
 /**
@@ -177,9 +183,9 @@ typedef struct {
     hcd_pipe_isr_callback_t callback;       /**< HCD pipe event ISR callback */
     void *callback_arg;                     /**< User argument for HCD pipe callback */
     void *context;                          /**< Context variable used to associate the pipe with upper layer object */
-    usb_desc_ep_t *ep_desc;                 /**< Pointer to endpoint descriptor of the pipe */
-    uint8_t dev_addr;                       /**< Device address of the pipe */
+    const usb_desc_ep_t *ep_desc;                 /**< Pointer to endpoint descriptor of the pipe */
     usb_speed_t dev_speed;                  /**< Speed of the device */
+    uint8_t dev_addr;                       /**< Device address of the pipe */
 } hcd_pipe_config_t;
 
 // --------------------------------------------- Host Controller Driver ------------------------------------------------
@@ -297,7 +303,7 @@ esp_err_t hcd_port_get_speed(hcd_port_handle_t port_hdl, usb_speed_t *speed);
  *
  * If the port has no events, this function will return HCD_PORT_EVENT_NONE.
  *
- * @note If callbacks are not used, this function can also be used in a polling manner to repeatedely check for and
+ * @note If callbacks are not used, this function can also be used in a polling manner to repeatedly check for and
  *       handle a port's events.
  * @note This function is internally protected by a mutex. If multiple threads call this function, this function will
  *       can block.
@@ -325,7 +331,22 @@ esp_err_t hcd_port_recover(hcd_port_handle_t port_hdl);
  * @param port_hdl Port handle
  * @return void* Context variable
  */
-void *hcd_port_get_ctx(hcd_port_handle_t port_hdl);
+void *hcd_port_get_context(hcd_port_handle_t port_hdl);
+
+/**
+ * @brief Set the bias of the HCD port's internal FIFO
+ *
+ * @note This function can only be called when the following conditions are met:
+ *  - Port is initialized
+ *  - Port does not have any pending events
+ *  - Port does not have any allocated pipes
+ *
+ * @param port_hdl Port handle
+ * @param bias Fifo bias
+ * @retval ESP_OK FIFO sizing successfully set
+ * @retval ESP_ERR_INVALID_STATE Incorrect state for FIFO sizes to be set
+ */
+esp_err_t hcd_port_set_fifo_bias(hcd_port_handle_t port_hdl, hcd_port_fifo_bias_t bias);
 
 // --------------------------------------------------- HCD Pipes -------------------------------------------------------
 
@@ -346,7 +367,7 @@ void *hcd_port_get_ctx(hcd_port_handle_t port_hdl);
  * @retval ESP_ERR_NO_MEM: Insufficient memory
  * @retval ESP_ERR_INVALID_ARG: Arguments are invalid
  * @retval ESP_ERR_INVALID_STATE: Host port is not in the correct state to allocate a pipe
- * @retval ESP_ERR_NOT_SUPPORTED: The pipe cannot be supported
+ * @retval ESP_ERR_NOT_SUPPORTED: The pipe's configuration cannot be supported
  */
 esp_err_t hcd_pipe_alloc(hcd_port_handle_t port_hdl, const hcd_pipe_config_t *pipe_config, hcd_pipe_handle_t *pipe_hdl);
 
@@ -365,22 +386,38 @@ esp_err_t hcd_pipe_alloc(hcd_port_handle_t port_hdl, const hcd_pipe_config_t *pi
 esp_err_t hcd_pipe_free(hcd_pipe_handle_t pipe_hdl);
 
 /**
- * @brief Update a pipe's device address and maximum packet size
+ * @brief Update a pipe's maximum packet size
+ *
+ * This function is intended to be called on default pipes during enumeration in order to update the pipe's maximum
+ * packet size. This function can only be called on a pipe that has met the following conditions:
+ * - Pipe is still valid (i.e., not in the HCD_PIPE_STATE_INVALID state)
+ * - Pipe is not currently processing a command
+ * - All IRPs have been dequeued from the pipe
+ *
+ * @param pipe_hdl Pipe handle
+ * @param mps New Maximum Packet Size
+ *
+ * @retval ESP_OK: Pipe successfully updated
+ * @retval ESP_ERR_INVALID_STATE: Pipe is not in a condition to be updated
+ */
+esp_err_t hcd_pipe_update_mps(hcd_pipe_handle_t pipe_hdl, int mps);
+
+/**
+ * @brief Update a pipe's device address
  *
  * This function is intended to be called on default pipes during enumeration in order to update the pipe's device
- * address and maximum packet size. This function can only be called on a pipe that has met the following conditions:
+ * address. This function can only be called on a pipe that has met the following conditions:
  * - Pipe is still valid (i.e., not in the HCD_PIPE_STATE_INVALID state)
  * - Pipe is not currently processing a command
  * - All IRPs have been dequeued from the pipe
  *
  * @param pipe_hdl Pipe handle
  * @param dev_addr New device address
- * @param mps New Maximum Packet Size
  *
  * @retval ESP_OK: Pipe successfully updated
- * @retval ESP_ERR_INVALID_STATE: Pipe is no in a condition to be updated
+ * @retval ESP_ERR_INVALID_STATE: Pipe is not in a condition to be updated
  */
-esp_err_t hcd_pipe_update(hcd_pipe_handle_t pipe_hdl, uint8_t dev_addr, int mps);
+esp_err_t hcd_pipe_update_dev_addr(hcd_pipe_handle_t pipe_hdl, uint8_t dev_addr);
 
 /**
  * @brief Get the context variable of a pipe from its handle
@@ -388,7 +425,7 @@ esp_err_t hcd_pipe_update(hcd_pipe_handle_t pipe_hdl, uint8_t dev_addr, int mps)
  * @param pipe_hdl Pipe handle
  * @return void* Context variable
  */
-void *hcd_pipe_get_ctx(hcd_pipe_handle_t pipe_hdl);
+void *hcd_pipe_get_context(hcd_pipe_handle_t pipe_hdl);
 
 /**
  * @brief Get the current sate of the pipe
@@ -406,8 +443,8 @@ hcd_pipe_state_t hcd_pipe_get_state(hcd_pipe_handle_t pipe_hdl);
  * - Pipe is still valid (i.e., not in the HCD_PIPE_STATE_INVALID)
  * - No other thread/task processing a command on the pipe concurrently (will return)
  *
- * @note Some pipe commands will block until the pipe's current inflight IRP is complete. If the pipe's state
- *       changes unexpectedley, this function will return ESP_ERR_INVALID_RESPONSE
+ * @note Some pipe commands will block until the pipe's current in-flight IRP is complete. If the pipe's state
+ *       changes unexpectedly, this function will return ESP_ERR_INVALID_RESPONSE
  *
  * @param pipe_hdl Pipe handle
  * @param command Pipe command
@@ -449,7 +486,7 @@ esp_err_t hcd_irp_enqueue(hcd_pipe_handle_t pipe_hdl, usb_irp_t *irp);
  * @brief Dequeue an IRP from a particular pipe
  *
  * This function should be called on a pipe after a pipe receives a HCD_PIPE_EVENT_IRP_DONE event. If a pipe has
- * multiple IRPs that can be dequeued, this function should be called repeatedely until all IRPs are dequeued. If a pipe
+ * multiple IRPs that can be dequeued, this function should be called repeatedly until all IRPs are dequeued. If a pipe
  * has no more IRPs to dequeue, this function will return NULL.
  *
  * @param pipe_hdl Pipe handle
@@ -461,7 +498,7 @@ usb_irp_t *hcd_irp_dequeue(hcd_pipe_handle_t pipe_hdl);
  * @brief Abort an enqueued IRP
  *
  * This function will attempt to abort an IRP that is already enqueued. If the IRP has yet to be executed, it will be
- * "cancelled" and can then be dequeued. If the IRP is currenty inflight or has already completed, the IRP will not be
+ * "cancelled" and can then be dequeued. If the IRP is currenty in-flight or has already completed, the IRP will not be
  * affected by this function.
  *
  * @param irp I/O Request Packet to abort
diff --git a/components/usb/private_include/usb.h b/components/usb/private_include/usb.h
index fe26f1c8b0..3abe2801f6 100644
--- a/components/usb/private_include/usb.h
+++ b/components/usb/private_include/usb.h
@@ -54,10 +54,10 @@ typedef enum {
  * @note The enum values need to match the bmAttributes field of an EP descriptor
  */
 typedef enum {
-    USB_XFER_TYPE_CTRL = 0,
-    USB_XFER_TYPE_ISOCHRONOUS,
-    USB_XFER_TYPE_BULK,
-    USB_XFER_TYPE_INTR,
+    USB_TRANSFER_TYPE_CTRL = 0,
+    USB_TRANSFER_TYPE_ISOCHRONOUS,
+    USB_TRANSFER_TYPE_BULK,
+    USB_TRANSFER_TYPE_INTR,
 } usb_transfer_type_t;
 
 /**
@@ -67,10 +67,11 @@ typedef enum {
     USB_TRANSFER_STATUS_COMPLETED,      /**< The transfer was successful (but may be short) */
     USB_TRANSFER_STATUS_ERROR,          /**< The transfer failed because due to excessive errors (e.g. no response or CRC error) */
     USB_TRANSFER_STATUS_TIMED_OUT,      /**< The transfer failed due to a time out */
-    USB_TRANSFER_STATUS_CANCELLED,      /**< The transfer was canceled */
+    USB_TRANSFER_STATUS_CANCELED,      /**< The transfer was canceled */
     USB_TRANSFER_STATUS_STALL,          /**< The transfer was stalled */
     USB_TRANSFER_STATUS_NO_DEVICE,      /**< The transfer failed because the device is no longer valid (e.g., disconnected */
     USB_TRANSFER_STATUS_OVERFLOW,       /**< The transfer as more data was sent than was requested */
+    USB_TRANSFER_STATUS_SKIPPED,        /**< ISOC only. The packet was skipped due to system latency */
 } usb_transfer_status_t;
 
 /**
@@ -87,6 +88,8 @@ typedef struct {
     usb_transfer_status_t status;       /**< Status of the packet */
 } usb_iso_packet_desc_t;
 
+#define USB_IRP_FLAG_ZERO_PACK  0x01    /**< (For bulk OUT only). Indicates that a bulk OUT transfers should always terminate with a short packet, even if it means adding an extra zero length packet */
+
 /**
  * @brief USB IRP (I/O Request Packet). See USB2.0 Spec
  *
@@ -114,8 +117,9 @@ struct usb_irp_obj {
     uint8_t *data_buffer;                   /**< Pointer to data buffer. Must be DMA capable memory */
     int num_bytes;                          /**< Number of bytes in IRP. Control should exclude size of setup. IN should be integer multiple of MPS */
     int actual_num_bytes;                   /**< Actual number of bytes transmitted/receives in the IRP */
+    uint32_t flags;                         /**< IRP flags */
     usb_transfer_status_t status;           /**< Status of the transfer */
-    uint32_t timeout;                       /**< Timeout (in milliseconds) of the packet */
+    uint32_t timeout;                       /**< Timeout (in milliseconds) of the packet (currently not supported yet) */
     void *context;                          /**< Context variable used to associate the IRP object with another object */
     int num_iso_packets;                    /**< Only relevant to Isochronous. Number of service periods to transfer data buffer over. Set to 0 for non-iso transfers */
     usb_iso_packet_desc_t iso_packet_desc[0];   /**< Descriptors for each ISO packet */
@@ -125,6 +129,15 @@ typedef struct usb_irp_obj usb_irp_t;
 
 // ---------------------------------------------------- Chapter 9 ------------------------------------------------------
 
+#define USB_B_DESCRIPTOR_TYPE_DEVICE                        1
+#define USB_B_DESCRIPTOR_TYPE_CONFIGURATION                 2
+#define USB_B_DESCRIPTOR_TYPE_STRING                        3
+#define USB_B_DESCRIPTOR_TYPE_INTERFACE                     4
+#define USB_B_DESCRIPTOR_TYPE_ENDPOINT                      5
+#define USB_B_DESCRIPTOR_TYPE_DEVICE_QUALIFIER              6
+#define USB_B_DESCRIPTOR_TYPE_OTHER_SPEED_CONFIGURATION     7
+#define USB_B_DESCRIPTOR_TYPE_INTERFACE_POWER               8
+
 // ------------------- Control Request ---------------------
 
 /**
@@ -250,12 +263,23 @@ _Static_assert(sizeof(usb_ctrl_req_t) == USB_CTRL_REQ_SIZE, "Size of usb_ctrl_re
     (ctrl_req_ptr)->wLength = 0;   \
 })
 
+/**
+ * @brief Initializer for a request to set an interface's alternate setting
+ */
+#define USB_CTRL_REQ_INIT_SET_INTERFACE(ctrl_req_ptr, intf_num, alt_setting_num) ({    \
+    (ctrl_req_ptr)->bRequestType = USB_B_REQUEST_TYPE_DIR_OUT | USB_B_REQUEST_TYPE_TYPE_STANDARD | USB_B_REQUEST_TYPE_RECIP_INTERFACE;  \
+    (ctrl_req_ptr)->bRequest = USB_B_REQUEST_SET_INTERFACE; \
+    (ctrl_req_ptr)->wValue = (alt_setting_num); \
+    (ctrl_req_ptr)->wIndex = (intf_num);  \
+    (ctrl_req_ptr)->wLength = 0;   \
+})
+
 // ------------------ Device Descriptor --------------------
 
 /**
  * @brief Size of a USB device descriptor in bytes
  */
-#define USB_DESC_DEV_SIZE       18
+#define USB_DESC_DEVC_SIZE       18
 
 /**
  * @brief Structure representing a USB device descriptor
@@ -277,9 +301,9 @@ typedef union {
         uint8_t iSerialNumber;
         uint8_t bNumConfigurations;
     } USB_DESC_ATTR;
-    uint8_t val[USB_DESC_DEV_SIZE];
+    uint8_t val[USB_DESC_DEVC_SIZE];
 } usb_desc_devc_t;
-_Static_assert(sizeof(usb_desc_devc_t) == USB_DESC_DEV_SIZE, "Size of usb_desc_devc_t incorrect");
+_Static_assert(sizeof(usb_desc_devc_t) == USB_DESC_DEVC_SIZE, "Size of usb_desc_devc_t incorrect");
 
 /**
  * @brief Possible base class values of the bDeviceClass field of a USB device descriptor
diff --git a/components/usb/test/CMakeLists.txt b/components/usb/test/CMakeLists.txt
index d02b3aef31..6a7f671f06 100644
--- a/components/usb/test/CMakeLists.txt
+++ b/components/usb/test/CMakeLists.txt
@@ -5,7 +5,7 @@ if(NOT "${target}" STREQUAL "esp32s2")
     return()
 endif()
 
-idf_component_register(SRC_DIRS "."
-                    PRIV_INCLUDE_DIRS "." "../private_include"
+idf_component_register(SRC_DIRS "hcd"
+                    PRIV_INCLUDE_DIRS "../private_include" "." "hcd"
                     PRIV_REQUIRES cmock usb test_utils
                     )
diff --git a/components/usb/test/hcd/test_hcd_bulk.c b/components/usb/test/hcd/test_hcd_bulk.c
new file mode 100644
index 0000000000..f3cbda5df7
--- /dev/null
+++ b/components/usb/test/hcd/test_hcd_bulk.c
@@ -0,0 +1,262 @@
+// Copyright 2015-2020 Espressif Systems (Shanghai) PTE LTD
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <stdio.h>
+#include <stdbool.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "unity.h"
+#include "test_utils.h"
+#include "test_hcd_common.h"
+
+// ------------------------------------------------- Mock MSC SCSI -----------------------------------------------------
+
+/*
+Note: The following test requires that USB flash drive be connected. The flash drive should...
+
+- Be implement the Mass Storage class supporting BULK only transfers using SCSI commands
+- It's configuration 1 should have the following endpoints
+
+Endpoint Descriptor:
+    bLength             7
+    bDescriptorType     5
+    bEndpointAddress    0x01  EP 1 OUT
+    bmAttributes        2
+        Transfer Type   Bulk
+        Synch Type      None
+        Usage Type      Data
+    wMaxPacketSize      0x0040  1x 64 bytes
+    bInterval           1
+Endpoint Descriptor:
+    bLength             7
+    bDescriptorType     5
+    bEndpointAddress    0x82  EP 2 IN
+    bmAttributes        2
+        Transfer Type   Bulk
+        Synch Type      None
+        Usage Type      Data
+    wMaxPacketSize      0x0040  1x 64 bytes
+    bInterval           1
+
+If you're using a flash driver with different endpoints, modify the endpoint descriptors below.
+*/
+
+static const usb_desc_ep_t bulk_out_ep_desc = {
+    .bLength = sizeof(usb_desc_ep_t),
+    .bDescriptorType = USB_B_DESCRIPTOR_TYPE_ENDPOINT,
+    .bEndpointAddress = 0x01,       //EP 1 OUT
+    .bmAttributes = USB_BM_ATTRIBUTES_XFER_BULK,
+    .wMaxPacketSize = 64,           //MPS of 64 bytes
+    .bInterval = 1,
+};
+
+static const usb_desc_ep_t bulk_in_ep_desc = {
+    .bLength = sizeof(usb_desc_ep_t),
+    .bDescriptorType = USB_B_DESCRIPTOR_TYPE_ENDPOINT,
+    .bEndpointAddress = 0x82,       //EP 2 IN
+    .bmAttributes = USB_BM_ATTRIBUTES_XFER_BULK,
+    .wMaxPacketSize = 64,           //MPS of 64 bytes
+    .bInterval = 1,
+};
+
+#define MOCK_MSC_SCSI_SECTOR_SIZE       512
+#define MOCK_MSC_SCSI_LUN               0
+#define MSC_SCSI_INTR_NUMBER            0
+
+#define MOCK_MSC_SCSI_REQ_INIT_RESET(ctrl_req_ptr, intf_num) ({  \
+    (ctrl_req_ptr)->bRequestType = USB_B_REQUEST_TYPE_DIR_OUT | USB_B_REQUEST_TYPE_TYPE_CLASS | USB_B_REQUEST_TYPE_RECIP_INTERFACE; \
+    (ctrl_req_ptr)->bRequest = 0xFF;    \
+    (ctrl_req_ptr)->wValue = 0; \
+    (ctrl_req_ptr)->wIndex = (intf_num);    \
+    (ctrl_req_ptr)->wLength = 0;    \
+})
+
+typedef struct __attribute__((packed)) {
+    uint8_t opcode; //0x28 = read(10), 0x2A=write(10)
+    uint8_t flags;
+    uint8_t lba_3;
+    uint8_t lba_2;
+    uint8_t lba_1;
+    uint8_t lba_0;
+    uint8_t group;
+    uint8_t len_1;
+    uint8_t len_0;
+    uint8_t control;
+} mock_scsi_cmd10_t;
+
+typedef struct __attribute__((packed)) {
+    uint32_t dCBWSignature;
+    uint32_t dCBWTag;
+    uint32_t dCBWDataTransferLength;
+    uint8_t bmCBWFlags;
+    uint8_t bCBWLUN;
+    uint8_t bCBWCBLength;
+    mock_scsi_cmd10_t CBWCB;
+    uint8_t padding[6];
+} mock_msc_bulk_cbw_t;
+
+// USB Bulk Transfer Command Status Wrapper data
+typedef struct __attribute__((packed)) {
+    uint32_t dCSWSignature;
+    uint32_t dCSWTag;
+    uint32_t dCSWDataResidue;
+    uint8_t bCSWStatus;
+} mock_msc_bulk_csw_t;
+
+static void mock_msc_reset_req(hcd_pipe_handle_t default_pipe)
+{
+    //Create IRP
+    usb_irp_t *irp = heap_caps_calloc(1, sizeof(usb_irp_t), MALLOC_CAP_DEFAULT);
+    TEST_ASSERT_NOT_EQUAL(NULL, irp);
+    irp->data_buffer = heap_caps_malloc(sizeof(usb_ctrl_req_t), MALLOC_CAP_DMA);
+    TEST_ASSERT_NOT_EQUAL(NULL, irp->data_buffer);
+    usb_ctrl_req_t *ctrl_req = (usb_ctrl_req_t *)irp->data_buffer;
+    MOCK_MSC_SCSI_REQ_INIT_RESET(ctrl_req, MSC_SCSI_INTR_NUMBER);
+    irp->num_bytes = 0;
+    //Enqueue, wait, dequeue, and check IRP
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp));
+    test_hcd_expect_pipe_event(default_pipe, HCD_PIPE_EVENT_IRP_DONE);
+    TEST_ASSERT_EQUAL(irp, hcd_irp_dequeue(default_pipe));
+    TEST_ASSERT_EQUAL(USB_TRANSFER_STATUS_COMPLETED, irp->status);
+    //Free IRP
+    heap_caps_free(irp->data_buffer);
+    heap_caps_free(irp);
+}
+
+static void mock_msc_scsi_init_cbw(mock_msc_bulk_cbw_t *cbw, bool is_read, int offset, int num_sectors, uint32_t tag)
+{
+    cbw->dCBWSignature = 0x43425355;    //Fixed value
+    cbw->dCBWTag = tag; //Random value that is echoed back
+    cbw->dCBWDataTransferLength = num_sectors * MOCK_MSC_SCSI_SECTOR_SIZE;
+    cbw->bmCBWFlags = (is_read) ? (1 << 7) : 0; //If this is a read, set the direction flag
+    cbw->bCBWLUN = MOCK_MSC_SCSI_LUN;
+    cbw->bCBWCBLength = 10;     //The length of the SCSI command
+    //Initialize SCSI CMD as READ10 or WRITE 10
+    cbw->CBWCB.opcode = (is_read) ? 0x28 : 0x2A;  //SCSI CMD READ10 or WRITE10
+    cbw->CBWCB.flags = 0;
+    cbw->CBWCB.lba_3 = (offset >> 24);
+    cbw->CBWCB.lba_2 = (offset >> 16);
+    cbw->CBWCB.lba_1 = (offset >> 8);
+    cbw->CBWCB.lba_0 = (offset >> 0);
+    cbw->CBWCB.group = 0;
+    cbw->CBWCB.len_1 = (num_sectors >> 8);
+    cbw->CBWCB.len_0 = (num_sectors >> 0);
+    cbw->CBWCB.control = 0;
+}
+
+static bool mock_msc_scsi_check_csw(mock_msc_bulk_csw_t *csw, uint32_t tag_expect)
+{
+    bool no_issues = true;
+    if (csw->dCSWSignature != 0x53425355) {
+        no_issues = false;
+        printf("Warning: csw signature corrupt (0x%X)\n", csw->dCSWSignature);
+    }
+    if (csw->dCSWTag != tag_expect) {
+        no_issues = false;
+        printf("Warning: csw tag unexpected! Expected %d got %d\n", tag_expect, csw->dCSWTag);
+    }
+    if (csw->dCSWDataResidue) {
+        no_issues = false;
+        printf("Warning: csw indicates data residue of %d bytes!\n", csw->dCSWDataResidue);
+    }
+    if (csw->bCSWStatus) {
+        no_issues = false;
+        printf("Warning: csw indicates non-good status %d!\n", csw->bCSWStatus);
+    }
+    return no_issues;
+}
+
+// --------------------------------------------------- Test Cases ------------------------------------------------------
+
+/*
+Test HCD bulk pipe IRPs
+
+Purpose:
+    - Test that a bulk pipe can be created
+    - IRPs can be created and enqueued to the bulk pipe pipe
+    - Bulk pipe returns HCD_PIPE_EVENT_IRP_DONE for completed IRPs
+    - Test utilizes a bare bones (i.e., mock) MSC class using SCSI commands
+
+Procedure:
+    - Setup HCD and wait for connection
+    - Allocate default pipe and enumerate the device
+    - Allocate separate IRPS for CBW, Data, and CSW transfers of the MSC class
+    - Read TEST_NUM_SECTORS number of sectors for the mass storage device
+    - Expect HCD_PIPE_EVENT_IRP_DONE for each IRP
+    - Deallocate IRPs
+    - Teardown
+*/
+
+#define TEST_NUM_SECTORS                10
+#define TEST_NUM_SECTORS_PER_ITER       2
+
+TEST_CASE("Test HCD bulk pipe IRPs", "[hcd][ignore]")
+{
+    hcd_port_handle_t port_hdl = test_hcd_setup();  //Setup the HCD and port
+    usb_speed_t port_speed = test_hcd_wait_for_conn(port_hdl);  //Trigger a connection
+    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
+
+    //Enumerate and reset MSC SCSI device
+    hcd_pipe_handle_t default_pipe = test_hcd_pipe_alloc(port_hdl, NULL, 0, port_speed); //Create a default pipe (using a NULL EP descriptor)
+    uint8_t dev_addr = test_hcd_enum_devc(default_pipe);
+    mock_msc_reset_req(default_pipe);
+
+    //Create BULK IN and BULK OUT pipes for SCSI
+    hcd_pipe_handle_t bulk_out_pipe = test_hcd_pipe_alloc(port_hdl, &bulk_out_ep_desc, dev_addr, port_speed);
+    hcd_pipe_handle_t bulk_in_pipe = test_hcd_pipe_alloc(port_hdl, &bulk_in_ep_desc, dev_addr, port_speed);
+    //Create IRPs for CBW, Data, and CSW transport. IN Buffer sizes are rounded up to nearest MPS
+    usb_irp_t *irp_cbw = test_hcd_alloc_irp(0, sizeof(mock_msc_bulk_cbw_t));
+    usb_irp_t *irp_data = test_hcd_alloc_irp(0, TEST_NUM_SECTORS_PER_ITER * MOCK_MSC_SCSI_SECTOR_SIZE);
+    usb_irp_t *irp_csw = test_hcd_alloc_irp(0, sizeof(mock_msc_bulk_csw_t) + (bulk_in_ep_desc.wMaxPacketSize - (sizeof(mock_msc_bulk_csw_t) % bulk_in_ep_desc.wMaxPacketSize)));
+    irp_cbw->num_bytes = sizeof(mock_msc_bulk_cbw_t);
+    irp_data->num_bytes = TEST_NUM_SECTORS_PER_ITER * MOCK_MSC_SCSI_SECTOR_SIZE;
+    irp_csw->num_bytes = sizeof(mock_msc_bulk_csw_t) + (bulk_in_ep_desc.wMaxPacketSize - (sizeof(mock_msc_bulk_csw_t) % bulk_in_ep_desc.wMaxPacketSize));
+
+    for (int block_num = 0; block_num < TEST_NUM_SECTORS; block_num += TEST_NUM_SECTORS_PER_ITER) {
+        //Initialize CBW IRP, then send it on the BULK OUT pipe
+        mock_msc_scsi_init_cbw((mock_msc_bulk_cbw_t *)irp_cbw->data_buffer, true, block_num, TEST_NUM_SECTORS_PER_ITER, 0xAAAAAAAA);
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(bulk_out_pipe, irp_cbw));
+        test_hcd_expect_pipe_event(bulk_out_pipe, HCD_PIPE_EVENT_IRP_DONE);
+        TEST_ASSERT_EQUAL(irp_cbw, hcd_irp_dequeue(bulk_out_pipe));
+        TEST_ASSERT_EQUAL(USB_TRANSFER_STATUS_COMPLETED, irp_cbw->status);
+        //Read data through BULK IN pipe
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(bulk_in_pipe, irp_data));
+        test_hcd_expect_pipe_event(bulk_in_pipe, HCD_PIPE_EVENT_IRP_DONE);
+        TEST_ASSERT_EQUAL(irp_data, hcd_irp_dequeue(bulk_in_pipe));
+        TEST_ASSERT_EQUAL(USB_TRANSFER_STATUS_COMPLETED, irp_data->status);
+        //Read the CSW through BULK IN pipe
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(bulk_in_pipe, irp_csw));
+        test_hcd_expect_pipe_event(bulk_in_pipe, HCD_PIPE_EVENT_IRP_DONE);
+        TEST_ASSERT_EQUAL(irp_csw, hcd_irp_dequeue(bulk_in_pipe));
+        TEST_ASSERT_EQUAL(USB_TRANSFER_STATUS_COMPLETED, irp_data->status);
+        TEST_ASSERT_EQUAL(sizeof(mock_msc_bulk_csw_t), irp_csw->actual_num_bytes);
+        TEST_ASSERT_EQUAL(true, mock_msc_scsi_check_csw((mock_msc_bulk_csw_t *)irp_csw->data_buffer, 0xAAAAAAAA));
+        //Print the read data
+        printf("Block %d to %d:\n", block_num, block_num + TEST_NUM_SECTORS_PER_ITER);
+        for (int i = 0; i < irp_data->actual_num_bytes; i++) {
+            printf("0x%02x,", ((char *)irp_data->data_buffer)[i]);
+        }
+        printf("\n\n");
+    }
+
+    test_hcd_free_irp(irp_cbw);
+    test_hcd_free_irp(irp_data);
+    test_hcd_free_irp(irp_csw);
+    test_hcd_pipe_free(bulk_out_pipe);
+    test_hcd_pipe_free(bulk_in_pipe);
+    test_hcd_pipe_free(default_pipe);
+    //Cleanup
+    test_hcd_wait_for_disconn(port_hdl, false);
+    test_hcd_teardown(port_hdl);
+}
diff --git a/components/usb/test/hcd/test_hcd_common.c b/components/usb/test/hcd/test_hcd_common.c
new file mode 100644
index 0000000000..3f1a8464ca
--- /dev/null
+++ b/components/usb/test/hcd/test_hcd_common.c
@@ -0,0 +1,350 @@
+// Copyright 2015-2020 Espressif Systems (Shanghai) PTE LTD
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+
+
+
+//Todo: Move all the port and PHY to here
+//Have a separate test file for INTR (HID), ISOC (UVC), and BULK (SCSI)
+//Each test case has a fixed HW device
+//Implements bare minimum for a MOCK protocol
+
+#include <stdio.h>
+#include <string.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "test_utils.h"
+#include "soc/gpio_pins.h"
+#include "soc/gpio_sig_map.h"
+#include "esp_intr_alloc.h"
+#include "esp_err.h"
+#include "esp_attr.h"
+#include "esp_rom_gpio.h"
+#include "hal/usbh_ll.h"
+#include "usb.h"
+#include "hcd.h"
+
+#define PORT_NUM                1
+#define EVENT_QUEUE_LEN         5
+#define ENUM_ADDR               1   //Device address to use for tests that enumerate the device
+#define ENUM_CONFIG             1   //Device configuration number to use for tests that enumerate the device
+
+typedef struct {
+    hcd_port_handle_t port_hdl;
+    hcd_port_event_t port_event;
+} port_event_msg_t;
+
+typedef struct {
+    hcd_pipe_handle_t pipe_hdl;
+    hcd_pipe_event_t pipe_event;
+} pipe_event_msg_t;
+
+// ---------------------------------------------------- Private --------------------------------------------------------
+
+/**
+ * @brief HCD port callback. Registered when initializing an HCD port
+ *
+ * @param port_hdl Port handle
+ * @param port_event Port event that triggered the callback
+ * @param user_arg User argument
+ * @param in_isr Whether callback was called in an ISR context
+ * @return true ISR should yield after this callback returns
+ * @return false No yield required (non-ISR context calls should always return false)
+ */
+static bool port_callback(hcd_port_handle_t port_hdl, hcd_port_event_t port_event, void *user_arg, bool in_isr)
+{
+    //We store the port's queue handle in the port's context variable
+    void *port_ctx = hcd_port_get_context(port_hdl);
+    QueueHandle_t port_evt_queue = (QueueHandle_t)port_ctx;
+    TEST_ASSERT(in_isr);    //Current HCD implementation should never call a port callback in a task context
+    port_event_msg_t msg = {
+        .port_hdl = port_hdl,
+        .port_event = port_event,
+    };
+    BaseType_t xTaskWoken = pdFALSE;
+    xQueueSendFromISR(port_evt_queue, &msg, &xTaskWoken);
+    return (xTaskWoken == pdTRUE);
+}
+
+/**
+ * @brief HCD pipe callback. Registered when allocating a HCD pipe
+ *
+ * @param pipe_hdl Pipe handle
+ * @param pipe_event Pipe event that triggered the callback
+ * @param user_arg User argument
+ * @param in_isr Whether the callback was called in an ISR context
+ * @return true ISR should yield after this callback returns
+ * @return false No yield required (non-ISR context calls should always return false)
+ */
+static bool pipe_callback(hcd_pipe_handle_t pipe_hdl, hcd_pipe_event_t pipe_event, void *user_arg, bool in_isr)
+{
+    QueueHandle_t pipe_evt_queue = (QueueHandle_t)user_arg;
+    pipe_event_msg_t msg = {
+        .pipe_hdl = pipe_hdl,
+        .pipe_event = pipe_event,
+    };
+    if (in_isr) {
+        BaseType_t xTaskWoken = pdFALSE;
+        xQueueSendFromISR(pipe_evt_queue, &msg, &xTaskWoken);
+        return (xTaskWoken == pdTRUE);
+    } else {
+        xQueueSend(pipe_evt_queue, &msg, portMAX_DELAY);
+        return false;
+    }
+}
+
+// ------------------------------------------------- HCD Event Test ----------------------------------------------------
+
+void test_hcd_expect_port_event(hcd_port_handle_t port_hdl, hcd_port_event_t expected_event)
+{
+    //Get the port event queue from the port's context variable
+    QueueHandle_t port_evt_queue = (QueueHandle_t)hcd_port_get_context(port_hdl);
+    TEST_ASSERT_NOT_EQUAL(NULL, port_evt_queue);
+    //Wait for port callback to send an event message
+    port_event_msg_t msg;
+    xQueueReceive(port_evt_queue, &msg, portMAX_DELAY);
+    //Check the contents of that event message
+    TEST_ASSERT_EQUAL(port_hdl, msg.port_hdl);
+    TEST_ASSERT_EQUAL(expected_event, msg.port_event);
+    printf("\t-> Port event\n");
+}
+
+void test_hcd_expect_pipe_event(hcd_pipe_handle_t pipe_hdl, hcd_pipe_event_t expected_event)
+{
+    //Get the pipe's event queue from the pipe's context variable
+    QueueHandle_t pipe_evt_queue = (QueueHandle_t)hcd_pipe_get_context(pipe_hdl);
+    TEST_ASSERT_NOT_EQUAL(NULL, pipe_evt_queue);
+    //Wait for pipe callback to send an event message
+    pipe_event_msg_t msg;
+    xQueueReceive(pipe_evt_queue, &msg, portMAX_DELAY);
+    //Check the contents of that event message
+    TEST_ASSERT_EQUAL(pipe_hdl, msg.pipe_hdl);
+    TEST_ASSERT_EQUAL(expected_event, msg.pipe_event);
+}
+
+int test_hcd_get_num_port_events(hcd_port_handle_t port_hdl)
+{
+    //Get the port event queue from the port's context variable
+    QueueHandle_t port_evt_queue = (QueueHandle_t)hcd_port_get_context(port_hdl);
+    TEST_ASSERT_NOT_EQUAL(NULL, port_evt_queue);
+    return EVENT_QUEUE_LEN - uxQueueSpacesAvailable(port_evt_queue);
+}
+
+int test_hcd_get_num_pipe_events(hcd_pipe_handle_t pipe_hdl)
+{
+    //Get the pipe's event queue from the pipe's context variable
+    QueueHandle_t pipe_evt_queue = (QueueHandle_t)hcd_pipe_get_context(pipe_hdl);
+    TEST_ASSERT_NOT_EQUAL(NULL, pipe_evt_queue);
+    return EVENT_QUEUE_LEN - uxQueueSpacesAvailable(pipe_evt_queue);
+}
+
+// ----------------------------------------------- Driver/Port Related -------------------------------------------------
+
+void test_hcd_force_conn_state(bool connected, TickType_t delay_ticks)
+{
+    vTaskDelay(delay_ticks);
+    usb_wrap_dev_t *wrap = &USB_WRAP;
+    if (connected) {
+        //Swap back to internal PHY that is connected to a device
+        wrap->otg_conf.phy_sel = 0;
+    } else {
+        //Set external PHY input signals to fixed voltage levels mimicking a disconnected state
+        esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ZERO_INPUT, USB_EXTPHY_VP_IDX, false);
+        esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ZERO_INPUT, USB_EXTPHY_VM_IDX, false);
+        esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ONE_INPUT, USB_EXTPHY_RCV_IDX, false);
+        //Swap to the external PHY
+        wrap->otg_conf.phy_sel = 1;
+    }
+}
+
+hcd_port_handle_t test_hcd_setup(void)
+{
+    //Create a queue for port callback to queue up port events
+    QueueHandle_t port_evt_queue = xQueueCreate(EVENT_QUEUE_LEN, sizeof(port_event_msg_t));
+    TEST_ASSERT_NOT_EQUAL(NULL, port_evt_queue);
+    //Install HCD
+    hcd_config_t hcd_config = {
+        .intr_flags = ESP_INTR_FLAG_LEVEL1,
+    };
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_install(&hcd_config));
+    //Initialize a port
+    hcd_port_config_t port_config = {
+        .callback = port_callback,
+        .callback_arg = (void *)port_evt_queue,
+        .context = (void *)port_evt_queue,
+    };
+    hcd_port_handle_t port_hdl;
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_init(PORT_NUM, &port_config, &port_hdl));
+    TEST_ASSERT_NOT_EQUAL(NULL, port_hdl);
+    TEST_ASSERT_EQUAL(HCD_PORT_STATE_NOT_POWERED, hcd_port_get_state(port_hdl));
+    test_hcd_force_conn_state(false, 0);    //Force disconnected state on PHY
+    return port_hdl;
+}
+
+void test_hcd_teardown(hcd_port_handle_t port_hdl)
+{
+    //Get the queue handle from the port's context variable
+    QueueHandle_t port_evt_queue = (QueueHandle_t)hcd_port_get_context(port_hdl);
+    TEST_ASSERT_NOT_EQUAL(NULL, port_evt_queue);
+    //Deinitialize a port
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_deinit(port_hdl));
+    //Uninstall the HCD
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_uninstall());
+    vQueueDelete(port_evt_queue);
+}
+
+usb_speed_t test_hcd_wait_for_conn(hcd_port_handle_t port_hdl)
+{
+    //Power ON the port
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_POWER_ON));
+    TEST_ASSERT_EQUAL(HCD_PORT_STATE_DISCONNECTED, hcd_port_get_state(port_hdl));
+    //Wait for connection event
+    printf("Waiting for connection\n");
+    test_hcd_force_conn_state(true, pdMS_TO_TICKS(100));     //Allow for connected state on PHY
+    test_hcd_expect_port_event(port_hdl, HCD_PORT_EVENT_CONNECTION);
+    TEST_ASSERT_EQUAL(HCD_PORT_EVENT_CONNECTION, hcd_port_handle_event(port_hdl));
+    TEST_ASSERT_EQUAL(HCD_PORT_STATE_DISABLED, hcd_port_get_state(port_hdl));
+    //Reset newly connected device
+    printf("Resetting\n");
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_RESET));
+    TEST_ASSERT_EQUAL(HCD_PORT_STATE_ENABLED, hcd_port_get_state(port_hdl));
+    //Get speed of connected
+    usb_speed_t port_speed;
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_get_speed(port_hdl, &port_speed));
+    if (port_speed == USB_SPEED_FULL) {
+        printf("Full speed enabled\n");
+    } else {
+        printf("Low speed enabled\n");
+    }
+    return port_speed;
+}
+
+void test_hcd_wait_for_disconn(hcd_port_handle_t port_hdl, bool already_disabled)
+{
+    if (!already_disabled) {
+        //Disable the device
+        printf("Disabling\n");
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_DISABLE));
+        TEST_ASSERT_EQUAL(HCD_PORT_STATE_DISABLED, hcd_port_get_state(port_hdl));
+    }
+    //Wait for a safe disconnect
+    printf("Waiting for disconnection\n");
+    test_hcd_force_conn_state(false, pdMS_TO_TICKS(100));    //Force disconnected state on PHY
+    test_hcd_expect_port_event(port_hdl, HCD_PORT_EVENT_DISCONNECTION);
+    TEST_ASSERT_EQUAL(HCD_PORT_EVENT_DISCONNECTION, hcd_port_handle_event(port_hdl));
+    TEST_ASSERT_EQUAL(HCD_PORT_STATE_DISCONNECTED, hcd_port_get_state(port_hdl));
+    //Power down the port
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_POWER_OFF));
+    TEST_ASSERT_EQUAL(HCD_PORT_STATE_NOT_POWERED, hcd_port_get_state(port_hdl));
+}
+
+// ---------------------------------------------- Pipe Setup/Tear-down -------------------------------------------------
+
+hcd_pipe_handle_t test_hcd_pipe_alloc(hcd_port_handle_t port_hdl, const usb_desc_ep_t *ep_desc, uint8_t dev_addr, usb_speed_t dev_speed)
+{
+    //Create a queue for pipe callback to queue up pipe events
+    QueueHandle_t pipe_evt_queue = xQueueCreate(EVENT_QUEUE_LEN, sizeof(pipe_event_msg_t));
+    TEST_ASSERT_NOT_EQUAL(NULL, pipe_evt_queue);
+    printf("Creating pipe\n");
+    hcd_pipe_config_t pipe_config = {
+        .callback = pipe_callback,
+        .callback_arg = (void *)pipe_evt_queue,
+        .context = (void *)pipe_evt_queue,
+        .ep_desc = ep_desc,
+        .dev_addr = dev_addr,
+        .dev_speed = dev_speed,
+    };
+    hcd_pipe_handle_t pipe_hdl;
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_alloc(port_hdl, &pipe_config, &pipe_hdl));
+    TEST_ASSERT_NOT_EQUAL(NULL, pipe_hdl);
+    return pipe_hdl;
+}
+
+void test_hcd_pipe_free(hcd_pipe_handle_t pipe_hdl)
+{
+    //Get the pipe's event queue from its context variable
+    QueueHandle_t pipe_evt_queue = (QueueHandle_t)hcd_pipe_get_context(pipe_hdl);
+    TEST_ASSERT_NOT_EQUAL(NULL, pipe_evt_queue);
+    //Free the pipe and queue
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_free(pipe_hdl));
+    vQueueDelete(pipe_evt_queue);
+}
+
+usb_irp_t *test_hcd_alloc_irp(int num_iso_packets, size_t data_buffer_size)
+{
+    //Allocate list of IRPs
+    usb_irp_t *irp = heap_caps_calloc(1, sizeof(usb_irp_t) + (num_iso_packets * sizeof(usb_iso_packet_desc_t)), MALLOC_CAP_DEFAULT);
+    TEST_ASSERT_NOT_EQUAL(NULL, irp);
+    //Allocate data buffer for each IRP and assign them
+    uint8_t *data_buffer = heap_caps_malloc(data_buffer_size, MALLOC_CAP_DMA);
+    TEST_ASSERT_NOT_EQUAL(NULL, data_buffer);
+    irp->data_buffer = data_buffer;
+    irp->num_iso_packets = num_iso_packets;
+    return irp;
+}
+
+void test_hcd_free_irp(usb_irp_t *irp)
+{
+    //Free data buffers of each IRP
+    heap_caps_free(irp->data_buffer);
+    //Free the IRP list
+    heap_caps_free(irp);
+}
+
+uint8_t test_hcd_enum_devc(hcd_pipe_handle_t default_pipe)
+{
+    //We need to create an IRP for the enumeration control transfers
+    usb_irp_t *irp = heap_caps_calloc(1, sizeof(usb_irp_t), MALLOC_CAP_DEFAULT);
+    TEST_ASSERT_NOT_EQUAL(NULL, irp);
+    //We use a single data buffer for all control transfers during enumerations. 256 bytes should be large enough for most descriptors
+    irp->data_buffer = heap_caps_malloc(sizeof(usb_ctrl_req_t) + 256, MALLOC_CAP_DMA);
+    TEST_ASSERT_NOT_EQUAL(NULL, irp->data_buffer);
+    usb_ctrl_req_t *ctrl_req = (usb_ctrl_req_t *)irp->data_buffer;
+
+    //Get the device descriptor (note that device might only return 8 bytes)
+    USB_CTRL_REQ_INIT_GET_DEVC_DESC(ctrl_req);
+    irp->num_bytes = sizeof(usb_desc_devc_t);
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp));
+    test_hcd_expect_pipe_event(default_pipe, HCD_PIPE_EVENT_IRP_DONE);
+    TEST_ASSERT_EQUAL(irp, hcd_irp_dequeue(default_pipe));
+    TEST_ASSERT_EQUAL(USB_TRANSFER_STATUS_COMPLETED, irp->status);
+
+    //Update the MPS of the default pipe
+    usb_desc_devc_t *devc_desc = (usb_desc_devc_t *)(irp->data_buffer + sizeof(usb_ctrl_req_t));
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_update_mps(default_pipe, devc_desc->bMaxPacketSize0));
+
+    //Send a set address request
+    USB_CTRL_REQ_INIT_SET_ADDR(ctrl_req, ENUM_ADDR);    //We only support one device for now so use address 1
+    irp->num_bytes = 0;
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp));
+    test_hcd_expect_pipe_event(default_pipe, HCD_PIPE_EVENT_IRP_DONE);
+    TEST_ASSERT_EQUAL(irp, hcd_irp_dequeue(default_pipe));
+    TEST_ASSERT_EQUAL(USB_TRANSFER_STATUS_COMPLETED, irp->status);
+
+    //Update address of default pipe
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_update_dev_addr(default_pipe, ENUM_ADDR));
+
+    //Send a set configuration request
+    USB_CTRL_REQ_INIT_SET_CONFIG(ctrl_req, ENUM_CONFIG);
+    irp->num_bytes = 0;
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp));
+    test_hcd_expect_pipe_event(default_pipe, HCD_PIPE_EVENT_IRP_DONE);
+    TEST_ASSERT_EQUAL(irp, hcd_irp_dequeue(default_pipe));
+    TEST_ASSERT_EQUAL(USB_TRANSFER_STATUS_COMPLETED, irp->status);
+
+    //Free IRP
+    heap_caps_free(irp->data_buffer);
+    heap_caps_free(irp);
+    return ENUM_ADDR;
+}
diff --git a/components/usb/test/hcd/test_hcd_common.h b/components/usb/test/hcd/test_hcd_common.h
new file mode 100644
index 0000000000..71a06ce057
--- /dev/null
+++ b/components/usb/test/hcd/test_hcd_common.h
@@ -0,0 +1,151 @@
+// Copyright 2015-2020 Espressif Systems (Shanghai) PTE LTD
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "usb.h"
+#include "hcd.h"
+
+#define IRP_CONTEXT_VAL ((void *)0xDEADBEEF)
+
+// ------------------------------------------------- HCD Event Test ----------------------------------------------------
+
+/**
+ * @brief Expect (wait) for an HCD port event
+ *
+ * @param port_hdl Port handle to expect event from
+ * @param expected_event Port event to expect
+ */
+void test_hcd_expect_port_event(hcd_port_handle_t port_hdl, hcd_port_event_t expected_event);
+
+/**
+ * @brief Expect (wait) for an HCD pipe event
+ *
+ * @param pipe_hdl Pipe handle to expect event from
+ * @param expected_event Pipe event to expect
+ */
+void test_hcd_expect_pipe_event(hcd_pipe_handle_t pipe_hdl, hcd_pipe_event_t expected_event);
+
+/**
+ * @brief Get the current number of queued port events (dequeued using test_hcd_expect_port_event())
+ *
+ * @param port_hdl Port handle
+ * @return int Number of port events currently queued
+ */
+int test_hcd_get_num_port_events(hcd_port_handle_t port_hdl);
+
+/**
+ * @brief Get the current number of queued pipe events (dequeued using test_hcd_expect_pipe_event())
+ *
+ * @param pipe_hdl Pipe handle
+ * @return int Number of pipe events currently queued
+ */
+int test_hcd_get_num_pipe_events(hcd_pipe_handle_t pipe_hdl);
+
+// ----------------------------------------------- Driver/Port Related -------------------------------------------------
+
+/**
+ * @brief For the USB PHY into the connected or disconnected state
+ *
+ * @param connected For into connected state if true, disconnected if false
+ * @param delay_ticks Delay in ticks before forcing state
+ */
+void test_hcd_force_conn_state(bool connected, TickType_t delay_ticks);
+
+/**
+ * @brief Sets up the HCD and initializes an HCD port.
+ *
+ * @return hcd_port_handle_t Port handle
+ */
+hcd_port_handle_t test_hcd_setup(void);
+
+/**
+ * @brief Frees and HCD port and uninstalls the HCD
+ *
+ * @param port_hdl Port handle
+ */
+void test_hcd_teardown(hcd_port_handle_t port_hdl);
+
+/**
+ * @brief Wait for a connection on an HCD port
+ *
+ * @note This function will internally call test_hcd_force_conn_state() to allow for a connection
+ *
+ * @param port_hdl Port handle
+ * @return usb_speed_t Speed of the connected device
+ */
+usb_speed_t test_hcd_wait_for_conn(hcd_port_handle_t port_hdl);
+
+/**
+ * @brief Wait for a disconnection on an HCD port
+ *
+ * @note This fucntion will internally call test_hcd_force_conn_state() to force a disconnection
+ *
+ * @param port_hdl Port handle
+ * @param already_disabled Whether the HCD port is already in the disabled state
+ */
+void test_hcd_wait_for_disconn(hcd_port_handle_t port_hdl, bool already_disabled);
+
+// ------------------------------------------------- Pipe alloc/free ---------------------------------------------------
+
+/**
+ * @brief Test the allocation of a pipe
+ *
+ * @param port_hdl Port handle
+ * @param ep_desc Endpoint descriptor
+ * @param dev_addr Device address of the pipe
+ * @param dev_speed Device speed of the pipe
+ * @return hcd_pipe_handle_t Pipe handle
+ */
+hcd_pipe_handle_t test_hcd_pipe_alloc(hcd_port_handle_t port_hdl, const usb_desc_ep_t *ep_desc, uint8_t dev_addr, usb_speed_t dev_speed);
+
+/**
+ * @brief Test the freeing of a pipe
+ *
+ * @param pipe_hdl Pipe handle
+ */
+void test_hcd_pipe_free(hcd_pipe_handle_t pipe_hdl);
+
+/**
+ * @brief Allocate an IRP
+ *
+ * @param num_iso_packets Number of isochronous packets
+ * @param data_buffer_size Size of the data buffer of the IRP
+ * @return usb_irp_t* IRP
+ */
+usb_irp_t *test_hcd_alloc_irp(int num_iso_packets, size_t data_buffer_size);
+
+/**
+ * @brief Free an IRP
+ *
+ * @param irp IRP
+ */
+void test_hcd_free_irp(usb_irp_t *irp);
+
+// --------------------------------------------------- Enumeration -----------------------------------------------------
+
+/**
+ * @brief Do some basic enumeration of the device
+ *
+ * For tests that need a device to have been enumerated (such as bulk tests). This function will enumerate that device
+ * using the device's default pipe. The minimal enumeration will include
+ *
+ * - Getting the device's descriptor and updating the default pipe's MPS
+ * - Setting the device's address and updating the default pipe to use that address
+ * - Setting the device to configuration 1 (i.e., the first configuration found
+ *
+ * @param default_pipe The connected device's default pipe
+ * @return uint8_t The address of the device after enumeration
+ */
+uint8_t test_hcd_enum_devc(hcd_pipe_handle_t default_pipe);
diff --git a/components/usb/test/hcd/test_hcd_ctrl.c b/components/usb/test/hcd/test_hcd_ctrl.c
new file mode 100644
index 0000000000..6e8f7a1915
--- /dev/null
+++ b/components/usb/test/hcd/test_hcd_ctrl.c
@@ -0,0 +1,271 @@
+// Copyright 2015-2020 Espressif Systems (Shanghai) PTE LTD
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <stdio.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "unity.h"
+#include "test_utils.h"
+#include "test_hcd_common.h"
+
+#define TEST_DEV_ADDR               0
+#define NUM_IRPS                    3
+#define TRANSFER_MAX_BYTES          256
+#define IRP_DATA_BUFF_SIZE          (sizeof(usb_ctrl_req_t) + TRANSFER_MAX_BYTES)   //256 is worst case size for configuration descriptors
+
+/*
+Test HCD control pipe IRPs (normal completion and early abort)
+
+Purpose:
+    - Test that a control pipe can be created
+    - IRPs can be created and enqueued to the control pipe
+    - Control pipe returns HCD_PIPE_EVENT_IRP_DONE
+    - Test that IRPs can be aborted when enqueued
+
+Procedure:
+    - Setup HCD and wait for connection
+    - Setup default pipe and allocate IRPs
+    - Enqueue IRPs
+    - Expect HCD_PIPE_EVENT_IRP_DONE
+    - Requeue IRPs, but abort them immediately
+    - Expect IRP to be USB_TRANSFER_STATUS_CANCELED or USB_TRANSFER_STATUS_COMPLETED
+    - Teardown
+*/
+TEST_CASE("Test HCD control pipe IRPs", "[hcd][ignore]")
+{
+    hcd_port_handle_t port_hdl = test_hcd_setup();  //Setup the HCD and port
+    usb_speed_t port_speed = test_hcd_wait_for_conn(port_hdl);  //Trigger a connection
+    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
+
+    //Allocate some IRPs and initialize their data buffers with control transfers
+    hcd_pipe_handle_t default_pipe = test_hcd_pipe_alloc(port_hdl, NULL, TEST_DEV_ADDR, port_speed); //Create a default pipe (using a NULL EP descriptor)
+    usb_irp_t *irp_list[NUM_IRPS];
+    for (int i = 0; i < NUM_IRPS; i++) {
+        irp_list[i] = test_hcd_alloc_irp(0, IRP_DATA_BUFF_SIZE);
+        //Initialize with a "Get Config Descriptor request"
+        irp_list[i]->num_bytes = TRANSFER_MAX_BYTES;
+        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *)irp_list[i]->data_buffer, 0, TRANSFER_MAX_BYTES);
+        irp_list[i]->context = IRP_CONTEXT_VAL;
+    }
+
+    //Enqueue IRPs but immediately suspend the port
+    printf("Enqueuing IRPs\n");
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
+    }
+    //Wait for each done event of each IRP
+    for (int i = 0; i < NUM_IRPS; i++) {
+        test_hcd_expect_pipe_event(default_pipe, HCD_PIPE_EVENT_IRP_DONE);
+    }
+    //Dequeue IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
+        TEST_ASSERT_EQUAL(irp_list[i], irp);
+        TEST_ASSERT_EQUAL(USB_TRANSFER_STATUS_COMPLETED, irp->status);
+        TEST_ASSERT_EQUAL(IRP_CONTEXT_VAL, irp->context);
+    }
+
+    //Enqueue IRPs again but abort them short after
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
+    }
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_abort(irp_list[i]));
+    }
+    vTaskDelay(pdMS_TO_TICKS(100)); //Give some time for any inflight transfers to complete
+
+    //Wait for the IRPs to complete and dequeue them, then check results
+    //Dequeue IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
+        //No need to check for IRP pointer address as they may be out of order
+        TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_COMPLETED || irp->status == USB_TRANSFER_STATUS_CANCELED);
+        if (irp->status == USB_TRANSFER_STATUS_COMPLETED) {
+            TEST_ASSERT_GREATER_THAN(0, irp->actual_num_bytes);
+        } else {
+            TEST_ASSERT_EQUAL(0, irp->actual_num_bytes);
+        }
+        TEST_ASSERT_EQUAL(irp->context, IRP_CONTEXT_VAL);
+    }
+
+    //Free IRP list and pipe
+    for (int i = 0; i < NUM_IRPS; i++) {
+        test_hcd_free_irp(irp_list[i]);
+    }
+    test_hcd_pipe_free(default_pipe);
+    //Cleanup
+    test_hcd_wait_for_disconn(port_hdl, false);
+    test_hcd_teardown(port_hdl);
+}
+
+/*
+Test HCD control pipe STALL condition, abort, and clear
+
+Purpose:
+    - Test that a control pipe can react to a STALL (i.e., a HCD_PIPE_EVENT_HALTED event)
+    - The HCD_PIPE_CMD_ABORT can retire all IRPs
+    - Pipe clear command can return the pipe to being active
+
+Procedure:
+    - Setup HCD and wait for connection
+    - Setup default pipe and allocate IRPs
+    - Corrupt the first IRP so that it will trigger a STALL, then enqueue all the IRPs
+    - Check that a HCD_PIPE_EVENT_ERROR_STALL event is triggered
+    - Check that all IRPs can be retired using HCD_PIPE_CMD_ABORT
+    - Check that the STALL can be cleared by using HCD_PIPE_CMD_CLEAR
+    - Fix the corrupt first IRP and retry the IRPs
+    - Dequeue IRPs
+    - Teardown
+*/
+TEST_CASE("Test HCD control pipe STALL", "[hcd][ignore]")
+{
+    hcd_port_handle_t port_hdl = test_hcd_setup();  //Setup the HCD and port
+    usb_speed_t port_speed = test_hcd_wait_for_conn(port_hdl);  //Trigger a connection
+    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
+
+    //Allocate some IRPs and initialize their data buffers with control transfers
+    hcd_pipe_handle_t default_pipe = test_hcd_pipe_alloc(port_hdl, NULL, TEST_DEV_ADDR, port_speed); //Create a default pipe (using a NULL EP descriptor)
+    usb_irp_t *irp_list[NUM_IRPS];
+    for (int i = 0; i < NUM_IRPS; i++) {
+        irp_list[i] = test_hcd_alloc_irp(0, IRP_DATA_BUFF_SIZE);
+        //Initialize with a "Get Config Descriptor request"
+        irp_list[i]->num_bytes = TRANSFER_MAX_BYTES;
+        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *)irp_list[i]->data_buffer, 0, TRANSFER_MAX_BYTES);
+        irp_list[i]->context = IRP_CONTEXT_VAL;
+    }
+    //Corrupt the first IRP so that it triggers a STALL
+    ((usb_ctrl_req_t *)irp_list[0]->data_buffer)->bRequest = 0xAA;
+
+    //Enqueue IRPs. A STALL should occur
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
+    }
+    printf("Expecting STALL\n");
+    test_hcd_expect_pipe_event(default_pipe, HCD_PIPE_EVENT_ERROR_STALL);
+    TEST_ASSERT_EQUAL(HCD_PIPE_STATE_HALTED, hcd_pipe_get_state(default_pipe));
+
+    //Call the pipe abort command to retire all IRPs then dequeue them all
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_command(default_pipe, HCD_PIPE_CMD_ABORT));
+    for (int i = 0; i < NUM_IRPS; i++) {
+        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
+        TEST_ASSERT_EQUAL(irp_list[i], irp);
+        TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_STALL || irp->status == USB_TRANSFER_STATUS_CANCELED);
+        if (irp->status == USB_TRANSFER_STATUS_COMPLETED) {
+            TEST_ASSERT_GREATER_THAN(0, irp->actual_num_bytes);
+        } else {
+            TEST_ASSERT_EQUAL(0, irp->actual_num_bytes);
+        }
+        TEST_ASSERT_EQUAL(IRP_CONTEXT_VAL, irp->context);
+    }
+
+    //Call the clear command to un-stall the pipe
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_command(default_pipe, HCD_PIPE_CMD_CLEAR));
+    TEST_ASSERT_EQUAL(HCD_PIPE_STATE_ACTIVE, hcd_pipe_get_state(default_pipe));
+
+    printf("Retrying\n");
+    //Correct first IRP then requeue
+    USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *)irp_list[0]->data_buffer, 0, TRANSFER_MAX_BYTES);
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
+    }
+
+    //Wait for each IRP to be done, deequeue, and check results
+    for (int i = 0; i < NUM_IRPS; i++) {
+        test_hcd_expect_pipe_event(default_pipe, HCD_PIPE_EVENT_IRP_DONE);
+        //expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_IRP_DONE);
+        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
+        TEST_ASSERT_EQUAL(irp_list[i], irp);
+        TEST_ASSERT_EQUAL(USB_TRANSFER_STATUS_COMPLETED, irp->status);
+        TEST_ASSERT_GREATER_THAN(0, irp->actual_num_bytes);
+        TEST_ASSERT_EQUAL(IRP_CONTEXT_VAL, irp->context);
+    }
+
+    //Free IRP list and pipe
+    for (int i = 0; i < NUM_IRPS; i++) {
+        test_hcd_free_irp(irp_list[i]);
+    }
+    test_hcd_pipe_free(default_pipe);
+    //Cleanup
+    test_hcd_wait_for_disconn(port_hdl, false);
+    test_hcd_teardown(port_hdl);
+}
+
+/*
+Test control pipe run-time halt and clear
+
+Purpose:
+    - Test that a control pipe can be halted with HCD_PIPE_CMD_HALT whilst there are ongoing IRPs
+    - Test that a control pipe can be un-halted with a HCD_PIPE_CMD_CLEAR
+    - Test that enqueued IRPs are resumed when pipe is un-halted
+
+Procedure:
+    - Setup HCD and wait for connection
+    - Setup default pipe and allocate IRPs
+    - Enqqueue IRPs but execute a HCD_PIPE_CMD_HALT command immediately after. Halt command should let on
+      the current going IRP finish before actually halting the pipe.
+    - Un-halt the pipe a HCD_PIPE_CMD_HALT command. Enqueued IRPs will be resumed
+    - Check that all IRPs have completed successfully
+    - Dequeue IRPs and teardown
+*/
+TEST_CASE("Test HCD control pipe runtime halt and clear", "[hcd][ignore]")
+{
+    hcd_port_handle_t port_hdl = test_hcd_setup();  //Setup the HCD and port
+    usb_speed_t port_speed = test_hcd_wait_for_conn(port_hdl);  //Trigger a connection
+    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
+
+    //Allocate some IRPs and initialize their data buffers with control transfers
+    hcd_pipe_handle_t default_pipe = test_hcd_pipe_alloc(port_hdl, NULL, TEST_DEV_ADDR, port_speed); //Create a default pipe (using a NULL EP descriptor)
+    usb_irp_t *irp_list[NUM_IRPS];
+    for (int i = 0; i < NUM_IRPS; i++) {
+        irp_list[i] = test_hcd_alloc_irp(0, IRP_DATA_BUFF_SIZE);
+        //Initialize with a "Get Config Descriptor request"
+        irp_list[i]->num_bytes = TRANSFER_MAX_BYTES;
+        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *)irp_list[i]->data_buffer, 0, TRANSFER_MAX_BYTES);
+        irp_list[i]->context = IRP_CONTEXT_VAL;
+    }
+
+    //Enqueue IRPs but immediately halt the pipe
+    printf("Enqueuing IRPs\n");
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
+    }
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_command(default_pipe, HCD_PIPE_CMD_HALT));
+    TEST_ASSERT_EQUAL(HCD_PIPE_STATE_HALTED, hcd_pipe_get_state(default_pipe));
+    printf("Pipe halted\n");
+
+    //Un-halt the pipe
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_command(default_pipe, HCD_PIPE_CMD_CLEAR));
+    TEST_ASSERT_EQUAL(HCD_PIPE_STATE_ACTIVE, hcd_pipe_get_state(default_pipe));
+    printf("Pipe cleared\n");
+    vTaskDelay(pdMS_TO_TICKS(100)); //Give some time pending for transfers to restart and complete
+
+    //Wait for each IRP to be done, dequeue, and check results
+    for (int i = 0; i < NUM_IRPS; i++) {
+        test_hcd_expect_pipe_event(default_pipe, HCD_PIPE_EVENT_IRP_DONE);
+        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
+        TEST_ASSERT_EQUAL(irp_list[i], irp);
+        TEST_ASSERT_EQUAL(USB_TRANSFER_STATUS_COMPLETED, irp->status);
+        TEST_ASSERT_GREATER_THAN(0, irp->actual_num_bytes);
+        TEST_ASSERT_EQUAL(IRP_CONTEXT_VAL, irp->context);
+    }
+
+    //Free IRP list and pipe
+    for (int i = 0; i < NUM_IRPS; i++) {
+        test_hcd_free_irp(irp_list[i]);
+    }
+    test_hcd_pipe_free(default_pipe);
+    //Cleanup
+    test_hcd_wait_for_disconn(port_hdl, false);
+    test_hcd_teardown(port_hdl);
+}
diff --git a/components/usb/test/hcd/test_hcd_intr.c b/components/usb/test/hcd/test_hcd_intr.c
new file mode 100644
index 0000000000..8495fd72eb
--- /dev/null
+++ b/components/usb/test/hcd/test_hcd_intr.c
@@ -0,0 +1,159 @@
+// Copyright 2015-2020 Espressif Systems (Shanghai) PTE LTD
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <stdio.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "unity.h"
+#include "test_utils.h"
+#include "test_hcd_common.h"
+
+// ------------------------------------------------- Mock HID Mice -----------------------------------------------------
+
+/*
+Note: The following test requires that USB low speed mouse be connected. The mouse should...
+
+- Be implement the HID with standard report format used by mice
+- It's configuration 1 should have the following endpoint
+
+Endpoint Descriptor:
+    bLength             7
+    bDescriptorType     5
+    bEndpointAddress    0x81  EP 1 IN
+    bmAttributes        3
+        Transfer Type   Interrupt
+        Synch Type      None
+        Usage Type      Data
+    wMaxPacketSize      0x0004  1x 4 bytes
+    bInterval           10
+
+If you're using another mice with different endpoints, modify the endpoint descriptor below
+*/
+static const usb_desc_ep_t in_ep_desc = {
+    .bLength = sizeof(usb_desc_ep_t),
+    .bDescriptorType = USB_B_DESCRIPTOR_TYPE_ENDPOINT,
+    .bEndpointAddress = 0x81,       //EP 1 IN
+    .bmAttributes = USB_BM_ATTRIBUTES_XFER_INT,
+    .wMaxPacketSize = 4,            //MPS of 4 bytes
+    .bInterval = 10,                //Interval of 10ms
+};
+
+typedef union {
+    struct {
+        uint32_t left_button: 1;
+        uint32_t right_button: 1;
+        uint32_t middle_button: 1;
+        uint32_t reserved5: 5;
+        uint8_t x_movement;
+        uint8_t y_movement;
+    } __attribute__((packed));
+    uint8_t val[3];
+} mock_hid_mouse_report_t;
+_Static_assert(sizeof(mock_hid_mouse_report_t) == 3, "Size of HID mouse report incorrect");
+
+static void mock_hid_process_report(mock_hid_mouse_report_t *report, int iter)
+{
+    static int x_pos = 0;
+    static int y_pos = 0;
+    //Update X position
+    if (report->x_movement & 0x80) {    //Positive movement
+        x_pos += report->x_movement & 0x7F;
+    } else {    //Negative movement
+        x_pos -= report->x_movement & 0x7F;
+    }
+    //Update Y position
+    if (report->y_movement & 0x80) {    //Positive movement
+        y_pos += report->y_movement & 0x7F;
+    } else {    //Negative movement
+        y_pos -= report->y_movement & 0x7F;
+    }
+    printf("\rX:%d\tY:%d\tIter: %d\n", x_pos, y_pos, iter);
+}
+
+// --------------------------------------------------- Test Cases ------------------------------------------------------
+
+/*
+Test HCD interrupt pipe IRPs
+Purpose:
+    - Test that an interrupt pipe can be created
+    - IRPs can be created and enqueued to the interrupt pipe
+    - Interrupt pipe returns HCD_PIPE_EVENT_IRP_DONE
+    - Test that IRPs can be aborted when enqueued
+
+Procedure:
+    - Setup HCD and wait for connection
+    - Allocate default pipe and enumerate the device
+    - Setup interrupt pipe and allocate IRPs
+    - Enqueue IRPs, expect HCD_PIPE_EVENT_IRP_DONE, and requeue
+    - Stop after fixed number of iterations
+    - Deallocate IRPs
+    - Teardown
+
+Note: Some mice will NAK until it is moved, so try moving the mouse around if this test case gets stuck.
+*/
+
+#define TEST_HID_DEV_SPEED                  USB_SPEED_LOW
+#define NUM_IRPS                            3
+#define IRP_DATA_BUFF_SIZE                  4       //MPS is 4
+#define MOCK_HID_NUM_REPORT_PER_IRP         2
+#define NUM_IRP_ITERS                       (NUM_IRPS * 100)
+
+TEST_CASE("Test HCD interrupt pipe IRPs", "[hcd][ignore]")
+{
+    hcd_port_handle_t port_hdl = test_hcd_setup();  //Setup the HCD and port
+    usb_speed_t port_speed = test_hcd_wait_for_conn(port_hdl);  //Trigger a connection
+    TEST_ASSERT_EQUAL(TEST_HID_DEV_SPEED, TEST_HID_DEV_SPEED);
+    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
+
+    hcd_pipe_handle_t default_pipe = test_hcd_pipe_alloc(port_hdl, NULL, 0, port_speed); //Create a default pipe (using a NULL EP descriptor)
+    uint8_t dev_addr = test_hcd_enum_devc(default_pipe);
+
+    //Allocate interrupt pipe and IRPS
+    hcd_pipe_handle_t intr_pipe = test_hcd_pipe_alloc(port_hdl, &in_ep_desc, dev_addr, port_speed);
+    usb_irp_t *irp_list[NUM_IRPS];
+    for (int i = 0; i < NUM_IRPS; i++) {
+        irp_list[i] = test_hcd_alloc_irp(0, IRP_DATA_BUFF_SIZE);
+        irp_list[i]->num_bytes = IRP_DATA_BUFF_SIZE;
+        irp_list[i]->context = IRP_CONTEXT_VAL;
+    }
+
+    //Enqueue IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(intr_pipe, irp_list[i]));
+    }
+    int iter_count = NUM_IRP_ITERS;
+    for (iter_count = NUM_IRP_ITERS; iter_count > 0; iter_count--) {
+        //Wait for an IRP to be done
+        test_hcd_expect_pipe_event(intr_pipe, HCD_PIPE_EVENT_IRP_DONE);
+        //Dequeue the IRP and check results
+        usb_irp_t *irp = hcd_irp_dequeue(intr_pipe);
+        TEST_ASSERT_EQUAL(USB_TRANSFER_STATUS_COMPLETED, irp->status);
+        TEST_ASSERT_EQUAL(IRP_CONTEXT_VAL, irp->context);
+        mock_hid_process_report((mock_hid_mouse_report_t *)irp->data_buffer, iter_count);
+        //Requeue IRP
+        if (iter_count > NUM_IRPS) {
+            TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(intr_pipe, irp));
+        }
+    }
+
+    //Free IRP list and pipe
+    for (int i = 0; i < NUM_IRPS; i++) {
+        test_hcd_free_irp(irp_list[i]);
+    }
+    test_hcd_pipe_free(intr_pipe);
+    test_hcd_pipe_free(default_pipe);
+    //Clearnup
+    test_hcd_wait_for_disconn(port_hdl, false);
+    test_hcd_teardown(port_hdl);
+}
diff --git a/components/usb/test/hcd/test_hcd_isoc.c b/components/usb/test/hcd/test_hcd_isoc.c
new file mode 100644
index 0000000000..4379a7b0d2
--- /dev/null
+++ b/components/usb/test/hcd/test_hcd_isoc.c
@@ -0,0 +1,114 @@
+// Copyright 2015-2020 Espressif Systems (Shanghai) PTE LTD
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <stdio.h>
+#include <string.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "unity.h"
+#include "test_utils.h"
+#include "test_hcd_common.h"
+
+//We talk to a non-existent device. Since ISOC out requires no ACK, there should be no errors.
+#define MOCK_ISOC_EP_NUM        2
+#define MOCK_ISOC_EP_MPS        512
+
+#define NUM_IRPS                3
+#define NUM_PACKETS_PER_IRP     3
+#define ISOC_PACKET_SIZE        MOCK_ISOC_EP_MPS
+#define IRP_DATA_BUFF_SIZE      (NUM_PACKETS_PER_IRP * ISOC_PACKET_SIZE)
+
+static const usb_desc_ep_t isoc_out_ep_desc = {
+    .bLength = sizeof(usb_desc_ep_t),
+    .bDescriptorType = USB_B_DESCRIPTOR_TYPE_ENDPOINT,
+    .bEndpointAddress = MOCK_ISOC_EP_NUM,
+    .bmAttributes = USB_BM_ATTRIBUTES_XFER_ISOC,
+    .wMaxPacketSize = MOCK_ISOC_EP_MPS,     //MPS of 512 bytes
+    .bInterval = 1,     //Isoc interval is (2 ^ (bInterval - 1)) which means an interval of 1ms
+};
+
+/*
+Test HCD ISOC pipe IRPs
+
+Purpose:
+    - Test that an isochronous pipe can be created
+    - IRPs can be created and enqueued to the isoc pipe pipe
+    - isoc pipe returns HCD_PIPE_EVENT_IRP_DONE for completed IRPs
+    - Test utilizes ISOC OUT transfers and do not require ACKs. So the isoc pipe will target a non existing endpoint
+
+Procedure:
+    - Setup HCD and wait for connection
+    - Allocate default pipe and enumerate the device
+    - Allocate an isochronous pipe and multiple IRPs. Each IRP should contain multiple packets to test HCD's ability to
+      schedule an IRP across multiple intervals.
+    - Enqueue those IRPs
+    - Expect HCD_PIPE_EVENT_IRP_DONE for each IRP. Verify that data is correct using logic analyzer
+    - Deallocate IRPs
+    - Teardown
+*/
+
+TEST_CASE("Test HCD isochronous pipe IRPs", "[hcd][ignore]")
+{
+    hcd_port_handle_t port_hdl = test_hcd_setup();  //Setup the HCD and port
+    usb_speed_t port_speed = test_hcd_wait_for_conn(port_hdl);  //Trigger a connection
+    //The MPS of the ISOC OUT pipe is quite large, so we need to bias the FIFO sizing
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_set_fifo_bias(port_hdl, HCD_PORT_FIFO_BIAS_PTX));
+    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
+
+    //Enumerate and reset device
+    hcd_pipe_handle_t default_pipe = test_hcd_pipe_alloc(port_hdl, NULL, 0, port_speed); //Create a default pipe (using a NULL EP descriptor)
+    uint8_t dev_addr = test_hcd_enum_devc(default_pipe);
+
+    //Create ISOC OUT pipe to non-existent device
+    hcd_pipe_handle_t isoc_out_pipe = test_hcd_pipe_alloc(port_hdl, &isoc_out_ep_desc, dev_addr + 1, port_speed);
+    //Create IRPs
+    usb_irp_t *irp_list[NUM_IRPS];
+    //Initialize IRPs
+    for (int irp_idx = 0; irp_idx < NUM_IRPS; irp_idx++) {
+        irp_list[irp_idx] = test_hcd_alloc_irp(NUM_PACKETS_PER_IRP, IRP_DATA_BUFF_SIZE);
+        irp_list[irp_idx]->num_bytes = 0;  //num_bytes is not used for ISOC
+        irp_list[irp_idx]->context = IRP_CONTEXT_VAL;
+        for (int pkt_idx = 0; pkt_idx < NUM_PACKETS_PER_IRP; pkt_idx++) {
+            irp_list[irp_idx]->iso_packet_desc[pkt_idx].length = ISOC_PACKET_SIZE;
+            //Each packet will consist of the same byte, but each subsequent packet's byte will increment (i.e., packet 0 transmits all 0x0, packet 1 transmits all 0x1)
+            memset(&irp_list[irp_idx]->data_buffer[pkt_idx * ISOC_PACKET_SIZE], (irp_idx * NUM_IRPS) + pkt_idx, ISOC_PACKET_SIZE);
+        }
+    }
+    //Enqueue IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(isoc_out_pipe, irp_list[i]));
+    }
+    //Wait for each done event from each IRP
+    for (int i = 0; i < NUM_IRPS; i++) {
+        test_hcd_expect_pipe_event(isoc_out_pipe, HCD_PIPE_EVENT_IRP_DONE);
+    }
+    //Dequeue IRPs
+    for (int irp_idx = 0; irp_idx < NUM_IRPS; irp_idx++) {
+        usb_irp_t *irp = hcd_irp_dequeue(isoc_out_pipe);
+        TEST_ASSERT_EQUAL(irp_list[irp_idx], irp);
+        TEST_ASSERT_EQUAL(IRP_CONTEXT_VAL, irp->context);
+        for (int pkt_idx = 0; pkt_idx < NUM_PACKETS_PER_IRP; pkt_idx++) {
+            TEST_ASSERT_EQUAL(USB_TRANSFER_STATUS_COMPLETED, irp->iso_packet_desc[pkt_idx].status);
+        }
+    }
+    //Free IRP list and pipe
+    for (int i = 0; i < NUM_IRPS; i++) {
+        test_hcd_free_irp(irp_list[i]);
+    }
+    test_hcd_pipe_free(isoc_out_pipe);
+    test_hcd_pipe_free(default_pipe);
+    //Cleanup
+    test_hcd_wait_for_disconn(port_hdl, false);
+    test_hcd_teardown(port_hdl);
+}
diff --git a/components/usb/test/hcd/test_hcd_port.c b/components/usb/test/hcd/test_hcd_port.c
new file mode 100644
index 0000000000..e3f5bab9be
--- /dev/null
+++ b/components/usb/test/hcd/test_hcd_port.c
@@ -0,0 +1,309 @@
+// Copyright 2015-2020 Espressif Systems (Shanghai) PTE LTD
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <stdio.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "unity.h"
+#include "test_utils.h"
+#include "test_hcd_common.h"
+
+#define TEST_DEV_ADDR               0
+#define NUM_IRPS                    3
+#define TRANSFER_MAX_BYTES          256
+#define IRP_DATA_BUFF_SIZE          (sizeof(usb_ctrl_req_t) + TRANSFER_MAX_BYTES)   //256 is worst case size for configuration descriptors
+
+/*
+Test a port sudden disconnect and port recovery
+
+Purpose: Test that when sudden disconnection happens on an HCD port, the port will
+    - Generate the HCD_PORT_EVENT_SUDDEN_DISCONN and be put into the HCD_PORT_STATE_RECOVERY state
+    - Ongoing IRPs and pipes are handled correctly
+
+Procedure:
+    - Setup the HCD and a port
+    - Trigger a port connection
+    - Create a default pipe
+    - Start transfers but immediately trigger a disconnect
+    - Check that HCD_PORT_EVENT_SUDDEN_DISCONN event is generated. Handle the event.
+    - Check that default pipe received a HCD_PIPE_EVENT_INVALID event. Pipe state should be invalid. Dequeue IRPs
+    - Free default pipe
+    - Recover the port
+    - Trigger connection and disconnection again (to make sure the port works post recovery)
+    - Teardown port and HCD
+*/
+
+TEST_CASE("Test HCD port sudden disconnect", "[hcd][ignore]")
+{
+    hcd_port_handle_t port_hdl = test_hcd_setup();  //Setup the HCD and port
+    usb_speed_t port_speed = test_hcd_wait_for_conn(port_hdl);  //Trigger a connection
+    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
+
+    //Allocate some IRPs and initialize their data buffers with control transfers
+    hcd_pipe_handle_t default_pipe = test_hcd_pipe_alloc(port_hdl, NULL, TEST_DEV_ADDR, port_speed); //Create a default pipe (using a NULL EP descriptor)
+    usb_irp_t *irp_list[NUM_IRPS];
+    for (int i = 0; i < NUM_IRPS; i++) {
+        irp_list[i] = test_hcd_alloc_irp(0, IRP_DATA_BUFF_SIZE);
+        //Initialize with a "Get Config Descriptor request"
+        irp_list[i]->num_bytes = TRANSFER_MAX_BYTES;
+        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *)irp_list[i]->data_buffer, 0, TRANSFER_MAX_BYTES);
+        irp_list[i]->context = (void *)0xDEADBEEF;
+    }
+
+    //Enqueue IRPs but immediately trigger a disconnect
+    printf("Enqueuing IRPs\n");
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
+    }
+    test_hcd_force_conn_state(false, 0);
+    //Disconnect event should have occurred. Handle the event
+    test_hcd_expect_port_event(port_hdl, HCD_PORT_EVENT_SUDDEN_DISCONN);
+    TEST_ASSERT_EQUAL(HCD_PORT_EVENT_SUDDEN_DISCONN, hcd_port_handle_event(port_hdl));
+    TEST_ASSERT_EQUAL(HCD_PORT_STATE_RECOVERY, hcd_port_get_state(port_hdl));
+    printf("Sudden disconnect\n");
+
+    //Pipe should have received (zero or more HCD_PIPE_EVENT_IRP_DONE) followed by a HCD_PIPE_EVENT_INVALID (MUST OCCUR)
+    int num_pipe_events = test_hcd_get_num_pipe_events(default_pipe);
+    for (int i = 0; i < num_pipe_events - 1; i++) {
+        test_hcd_expect_pipe_event(default_pipe, HCD_PIPE_EVENT_IRP_DONE);
+    }
+    test_hcd_expect_pipe_event(default_pipe, HCD_PIPE_EVENT_INVALID);
+    TEST_ASSERT_EQUAL(hcd_pipe_get_state(default_pipe), HCD_PIPE_STATE_INVALID);
+
+    //Dequeue IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
+        TEST_ASSERT_EQUAL(irp_list[i], irp);
+        TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_COMPLETED || irp->status == USB_TRANSFER_STATUS_NO_DEVICE);
+        if (irp->status == USB_TRANSFER_STATUS_COMPLETED) {
+            TEST_ASSERT_GREATER_THAN(0, irp->actual_num_bytes);
+        } else {
+            TEST_ASSERT_EQUAL(0, irp->actual_num_bytes);
+        }
+        TEST_ASSERT_EQUAL(0xDEADBEEF, irp->context);
+    }
+    //Free IRP list and pipe
+    for (int i = 0; i < NUM_IRPS; i++) {
+        test_hcd_free_irp(irp_list[i]);
+    }
+    test_hcd_pipe_free(default_pipe);
+
+    //Recover the port should return to the to NOT POWERED state
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_recover(port_hdl));
+    TEST_ASSERT_EQUAL(HCD_PORT_STATE_NOT_POWERED, hcd_port_get_state(port_hdl));
+
+    //Recovered port should be able to connect and disconnect again
+    test_hcd_wait_for_conn(port_hdl);
+    test_hcd_wait_for_disconn(port_hdl, false);
+    test_hcd_teardown(port_hdl);
+}
+
+/*
+Test port suspend and resume with active pipes
+
+Purpose:
+    - Test port suspend and resume commands work correctly whilst there are active pipes with ongoing transfers
+    - When suspending, the pipes should be allowed to finish their current ongoing transfer before the bus is suspended.
+    - When resuming, pipes with pending transfer should be started after the bus is resumed.
+
+Procedure:
+    - Setup the HCD and a port
+    - Trigger a port connection
+    - Create a default pipe
+    - Start transfers but suspend the port immediately
+    - Resume the port
+    - Check that all the IRPs have completed successfully
+    - Cleanup IRPs and default pipe
+    - Trigger disconnection and teardown
+*/
+TEST_CASE("Test HCD port suspend and resume", "[hcd][ignore]")
+{
+    hcd_port_handle_t port_hdl = test_hcd_setup();  //Setup the HCD and port
+    usb_speed_t port_speed = test_hcd_wait_for_conn(port_hdl);  //Trigger a connection
+    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
+
+    //Allocate some IRPs and initialize their data buffers with control transfers
+    hcd_pipe_handle_t default_pipe = test_hcd_pipe_alloc(port_hdl, NULL, TEST_DEV_ADDR, port_speed); //Create a default pipe (using a NULL EP descriptor)
+    usb_irp_t *irp_list[NUM_IRPS];
+    for (int i = 0; i < NUM_IRPS; i++) {
+        irp_list[i] = test_hcd_alloc_irp(0, IRP_DATA_BUFF_SIZE);
+        //Initialize with a "Get Config Descriptor request"
+        irp_list[i]->num_bytes = TRANSFER_MAX_BYTES;
+        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *)irp_list[i]->data_buffer, 0, TRANSFER_MAX_BYTES);
+        irp_list[i]->context = (void *)0xDEADBEEF;
+    }
+
+    //Enqueue IRPs but immediately suspend the port
+    printf("Enqueuing IRPs\n");
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
+    }
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_SUSPEND));
+    TEST_ASSERT_EQUAL(HCD_PORT_STATE_SUSPENDED, hcd_port_get_state(port_hdl));
+    printf("Suspended\n");
+    vTaskDelay(pdMS_TO_TICKS(100)); //Give some time for bus to remain suspended
+
+    //Resume the port
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_RESUME));
+    TEST_ASSERT_EQUAL(HCD_PORT_STATE_ENABLED, hcd_port_get_state(port_hdl));
+    printf("Resumed\n");
+    vTaskDelay(pdMS_TO_TICKS(100)); //Give some time for resumed IRPs to complete
+    //Dequeue IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
+        TEST_ASSERT_EQUAL(irp_list[i], irp);
+        TEST_ASSERT_EQUAL(irp->status, USB_TRANSFER_STATUS_COMPLETED);
+        TEST_ASSERT_GREATER_THAN(0, irp->actual_num_bytes);
+        TEST_ASSERT_EQUAL(0xDEADBEEF, irp->context);
+    }
+
+    //Free IRP list and pipe
+    for (int i = 0; i < NUM_IRPS; i++) {
+        test_hcd_free_irp(irp_list[i]);
+    }
+    test_hcd_pipe_free(default_pipe);
+    //Cleanup
+    test_hcd_wait_for_disconn(port_hdl, false);
+    test_hcd_teardown(port_hdl);
+}
+
+/*
+Test HCD port disable with active pipes
+
+Purpose:
+    - Test that the port disable command works correctly with active pipes
+    - Pipes should be to finish their current ongoing transfer before port is disabled
+    - After disabling the port, all pipes should become invalid.
+
+Procedure:
+    - Setup HCD, a default pipe, and multiple IRPs
+    - Start transfers but immediately disable the port
+    - Check pipe received invalid event
+    - Check that transfer are either done or not executed
+    - Teardown
+*/
+TEST_CASE("Test HCD port disable", "[hcd][ignore]")
+{
+    hcd_port_handle_t port_hdl = test_hcd_setup();  //Setup the HCD and port
+    usb_speed_t port_speed = test_hcd_wait_for_conn(port_hdl);  //Trigger a connection
+    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
+
+    //Allocate some IRPs and initialize their data buffers with control transfers
+    hcd_pipe_handle_t default_pipe = test_hcd_pipe_alloc(port_hdl, NULL, TEST_DEV_ADDR, port_speed); //Create a default pipe (using a NULL EP descriptor)
+    usb_irp_t *irp_list[NUM_IRPS];
+    for (int i = 0; i < NUM_IRPS; i++) {
+        irp_list[i] = test_hcd_alloc_irp(0, IRP_DATA_BUFF_SIZE);
+        //Initialize with a "Get Config Descriptor request"
+        irp_list[i]->num_bytes = TRANSFER_MAX_BYTES;
+        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *)irp_list[i]->data_buffer, 0, TRANSFER_MAX_BYTES);
+        irp_list[i]->context = (void *)0xDEADBEEF;
+    }
+
+    //Enqueue IRPs but immediately disable the port
+    printf("Enqueuing IRPs\n");
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
+    }
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_DISABLE));
+    TEST_ASSERT_EQUAL(HCD_PORT_STATE_DISABLED, hcd_port_get_state(port_hdl));
+    printf("Disabled\n");
+
+    //Pipe should have received (zero or more HCD_PIPE_EVENT_IRP_DONE) followed by a HCD_PIPE_EVENT_INVALID (MUST OCCUR)
+    int num_pipe_events = test_hcd_get_num_pipe_events(default_pipe);
+    for (int i = 0; i < num_pipe_events - 1; i++) {
+        test_hcd_expect_pipe_event(default_pipe, HCD_PIPE_EVENT_IRP_DONE);
+    }
+    test_hcd_expect_pipe_event(default_pipe, HCD_PIPE_EVENT_INVALID);
+
+    //Dequeue IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
+        TEST_ASSERT_EQUAL(irp_list[i], irp);
+        TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_COMPLETED || irp->status == USB_TRANSFER_STATUS_NO_DEVICE);
+        if (irp->status == USB_TRANSFER_STATUS_COMPLETED) {
+            TEST_ASSERT_GREATER_THAN(0, irp->actual_num_bytes);
+        } else {
+            TEST_ASSERT_EQUAL(0, irp->actual_num_bytes);
+        }
+        TEST_ASSERT_EQUAL(0xDEADBEEF, irp->context);
+    }
+
+    //Free IRP list and pipe
+    for (int i = 0; i < NUM_IRPS; i++) {
+        test_hcd_free_irp(irp_list[i]);
+    }
+    test_hcd_pipe_free(default_pipe);
+    //Cleanup
+    test_hcd_wait_for_disconn(port_hdl, true);
+    test_hcd_teardown(port_hdl);
+}
+
+/*
+Test HCD port command bailout
+
+Purpose:
+    - Test that if the a port's state changes whilst a command is being executed, the port command should return
+       ESP_ERR_INVALID_RESPONSE
+
+Procedure:
+    - Setup HCD and wait for connection
+    - Suspend the port
+    - Resume the port but trigger a disconnect from another thread during the resume command
+    - Check that port command returns ESP_ERR_INVALID_RESPONSE
+*/
+
+static void concurrent_task(void *arg)
+{
+    SemaphoreHandle_t sync_sem = (SemaphoreHandle_t) arg;
+    xSemaphoreTake(sync_sem, portMAX_DELAY);
+    vTaskDelay(pdMS_TO_TICKS(10));  //Give a short delay let reset command start in main thread
+    //Force a disconnection
+    test_hcd_force_conn_state(false, 0);
+    vTaskDelay(portMAX_DELAY);  //Block forever and wait to be deleted
+}
+
+TEST_CASE("Test HCD port command bailout", "[hcd][ignore]")
+{
+    hcd_port_handle_t port_hdl = test_hcd_setup();  //Setup the HCD and port
+    test_hcd_wait_for_conn(port_hdl);  //Trigger a connection
+    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
+
+    //Create task to run port commands concurrently
+    SemaphoreHandle_t sync_sem = xSemaphoreCreateBinary();
+    TaskHandle_t task_handle;
+    TEST_ASSERT_NOT_EQUAL(NULL, sync_sem);
+    TEST_ASSERT_EQUAL(pdTRUE, xTaskCreatePinnedToCore(concurrent_task, "tsk", 4096, (void *) sync_sem, UNITY_FREERTOS_PRIORITY + 1, &task_handle, 0));
+
+    //Suspend the device
+    printf("Suspending\n");
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_SUSPEND));
+    vTaskDelay(pdMS_TO_TICKS(20)); //Short delay for device to enter suspend state
+
+    //Attempt to resume the port. But the concurrent task should override this with a disconnection event
+    printf("Attempting to resume\n");
+    xSemaphoreGive(sync_sem);   //Trigger concurrent task
+    TEST_ASSERT_EQUAL(ESP_ERR_INVALID_RESPONSE, hcd_port_command(port_hdl, HCD_PORT_CMD_RESUME));
+
+    //Check that concurrent task triggered a sudden disconnection
+    test_hcd_expect_port_event(port_hdl, HCD_PORT_EVENT_SUDDEN_DISCONN);
+    TEST_ASSERT_EQUAL(HCD_PORT_EVENT_SUDDEN_DISCONN, hcd_port_handle_event(port_hdl));
+    TEST_ASSERT_EQUAL(HCD_PORT_STATE_RECOVERY, hcd_port_get_state(port_hdl));
+
+    //Cleanup task and semaphore
+    vTaskDelay(pdMS_TO_TICKS(10)); //Short delay for concurrent task finish running
+    vTaskDelete(task_handle);
+    vSemaphoreDelete(sync_sem);
+
+    test_hcd_teardown(port_hdl);
+}
diff --git a/components/usb/test/test_hcd.c b/components/usb/test/test_hcd.c
deleted file mode 100644
index 0b915a2fb0..0000000000
--- a/components/usb/test/test_hcd.c
+++ /dev/null
@@ -1,790 +0,0 @@
-// Copyright 2015-2020 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include <stdio.h>
-#include "freertos/FreeRTOS.h"
-#include "freertos/semphr.h"
-#include "unity.h"
-#include "test_utils.h"
-#include "soc/gpio_pins.h"
-#include "soc/gpio_sig_map.h"
-#include "esp_intr_alloc.h"
-#include "esp_err.h"
-#include "esp_attr.h"
-#include "esp_rom_gpio.h"
-#include "hal/usbh_ll.h"
-#include "usb.h"
-#include "hcd.h"
-
-// -------------------------------------------------- PHY Control ------------------------------------------------------
-
-static void phy_force_conn_state(bool connected, TickType_t delay_ticks)
-{
-    vTaskDelay(delay_ticks);
-    usb_wrap_dev_t *wrap = &USB_WRAP;
-    if (connected) {
-        //Swap back to internal PHY that is connected to a device
-        wrap->otg_conf.phy_sel = 0;
-    } else {
-        //Set external PHY input signals to fixed voltage levels mimicking a disconnected state
-        esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ZERO_INPUT, USB_EXTPHY_VP_IDX, false);
-        esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ZERO_INPUT, USB_EXTPHY_VM_IDX, false);
-        esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ONE_INPUT, USB_EXTPHY_RCV_IDX, false);
-        //Swap to the external PHY
-        wrap->otg_conf.phy_sel = 1;
-    }
-}
-
-// ------------------------------------------------ Helper Functions ---------------------------------------------------
-
-#define EVENT_QUEUE_LEN         5
-#define NUM_IRPS                3
-#define TRANSFER_DATA_MAX_BYTES 256     //Just assume that will only IN/OUT 256 bytes for now
-#define PORT_NUM                1
-#define IRP_CONTEXT_VAL         ((void *)0xDEADBEEF)    //Conext value for created IRPs
-
-typedef struct {
-    hcd_port_handle_t port_hdl;
-    hcd_port_event_t port_event;
-} port_event_msg_t;
-
-typedef struct {
-    hcd_pipe_handle_t pipe_hdl;
-    hcd_pipe_event_t pipe_event;
-} pipe_event_msg_t;
-
-static bool port_callback(hcd_port_handle_t port_hdl, hcd_port_event_t port_event, void *user_arg, bool in_isr)
-{
-    QueueHandle_t port_evt_queue = (QueueHandle_t)user_arg;
-    TEST_ASSERT(in_isr);    //Current HCD implementation should never call a port callback in a task context
-    port_event_msg_t msg = {
-        .port_hdl = port_hdl,
-        .port_event = port_event,
-    };
-    BaseType_t xTaskWoken = pdFALSE;
-    xQueueSendFromISR(port_evt_queue, &msg, &xTaskWoken);
-    return (xTaskWoken == pdTRUE);
-}
-
-static bool pipe_callback(hcd_pipe_handle_t pipe_hdl, hcd_pipe_event_t pipe_event, void *user_arg, bool in_isr)
-{
-    QueueHandle_t pipe_evt_queue = (QueueHandle_t)user_arg;
-    pipe_event_msg_t msg = {
-        .pipe_hdl = pipe_hdl,
-        .pipe_event = pipe_event,
-    };
-    if (in_isr) {
-        BaseType_t xTaskWoken = pdFALSE;
-        xQueueSendFromISR(pipe_evt_queue, &msg, &xTaskWoken);
-        return (xTaskWoken == pdTRUE);
-    } else {
-        xQueueSend(pipe_evt_queue, &msg, portMAX_DELAY);
-        return false;
-    }
-}
-
-static void expect_port_event(QueueHandle_t port_evt_queue, hcd_port_handle_t expected_hdl, hcd_port_event_t expected_event)
-{
-    port_event_msg_t msg;
-    xQueueReceive(port_evt_queue, &msg, portMAX_DELAY);
-    TEST_ASSERT_EQUAL(expected_hdl, msg.port_hdl);
-    TEST_ASSERT_EQUAL(expected_event, msg.port_event);
-    printf("\t-> Port event\n");
-}
-
-static void expect_pipe_event(QueueHandle_t pipe_evt_queue, hcd_pipe_handle_t expected_hdl, hcd_pipe_event_t expected_event)
-{
-    pipe_event_msg_t msg;
-    xQueueReceive(pipe_evt_queue, &msg, portMAX_DELAY);
-    TEST_ASSERT_EQUAL(expected_hdl, msg.pipe_hdl);
-    TEST_ASSERT_EQUAL(expected_event, msg.pipe_event);
-}
-
-/**
- * @brief Creates port and pipe event queues. Sets up the HCD, and initializes a port.
- *
- * @param[out] port_evt_queue Port event queue
- * @param[out] pipe_evt_queue Pipe event queue
- * @param[out] port_hdl Port handle
- */
-static void setup(QueueHandle_t *port_evt_queue, QueueHandle_t *pipe_evt_queue, hcd_port_handle_t *port_hdl)
-{
-    *port_evt_queue = xQueueCreate(EVENT_QUEUE_LEN, sizeof(port_event_msg_t));
-    *pipe_evt_queue = xQueueCreate(EVENT_QUEUE_LEN, sizeof(pipe_event_msg_t));
-    TEST_ASSERT_NOT_EQUAL(NULL, *port_evt_queue);
-    TEST_ASSERT_NOT_EQUAL(NULL, *pipe_evt_queue);
-
-    //Install HCD
-    hcd_config_t config = {
-        .intr_flags = ESP_INTR_FLAG_LEVEL1,
-    };
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_install(&config));
-    //Initialize a port
-    hcd_port_config_t port_config = {
-        .callback = port_callback,
-        .callback_arg = (void *)*port_evt_queue,
-        .context = NULL,
-    };
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_init(PORT_NUM, &port_config, port_hdl));
-    TEST_ASSERT_NOT_EQUAL(NULL, *port_hdl);
-    TEST_ASSERT_EQUAL(HCD_PORT_STATE_NOT_POWERED, hcd_port_get_state(*port_hdl));
-    phy_force_conn_state(false, 0);    //Force disconnected state on PHY
-}
-
-/**
- * @brief Deinitializes the port, uninstalls HCD, and frees port and pipe event queues
- *
- * @param[in] port_evt_queue Port event queue
- * @param[in] pipe_evt_queue Pipe event semaphore
- * @param[in] port_hdl Port handle
- */
-static void teardown(QueueHandle_t port_evt_queue, QueueHandle_t pipe_evt_queue, hcd_port_handle_t port_hdl)
-{
-    //Deinitialize a port
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_deinit(port_hdl));
-    //Uninstall the HCD
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_uninstall());
-    vQueueDelete(port_evt_queue);
-    vQueueDelete(pipe_evt_queue);
-}
-
-/**
- * @brief Powers ON a port and waits for a connection, then resets the connected device
- *
- * @param port_hdl Port handle
- * @param port_evt_queue Port event queue
- */
-static void wait_for_connection(hcd_port_handle_t port_hdl, QueueHandle_t port_evt_queue)
-{
-    //Power ON the port
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_POWER_ON));
-    TEST_ASSERT_EQUAL(HCD_PORT_STATE_DISCONNECTED, hcd_port_get_state(port_hdl));
-    //Wait for connection event
-    printf("Waiting for conenction\n");
-    phy_force_conn_state(true, pdMS_TO_TICKS(100));     //Allow for connected state on PHY
-    expect_port_event(port_evt_queue, port_hdl, HCD_PORT_EVENT_CONNECTION);
-    TEST_ASSERT_EQUAL(HCD_PORT_EVENT_CONNECTION, hcd_port_handle_event(port_hdl));
-    TEST_ASSERT_EQUAL(HCD_PORT_STATE_DISABLED, hcd_port_get_state(port_hdl));
-    //Reset newly connected device
-    printf("Resetting\n");
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_RESET));
-    TEST_ASSERT_EQUAL(HCD_PORT_STATE_ENABLED, hcd_port_get_state(port_hdl));
-    //Get speed of conencted
-    usb_speed_t port_speed;
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_get_speed(port_hdl, &port_speed));
-    if (port_speed == USB_SPEED_FULL) {
-        printf("Full speed enabled\n");
-    } else {
-        printf("Low speed enabled\n");
-    }
-}
-
-/**
- * @brief Disables the port, waits for a disconnection, then powers OFF the port
- *
- * @param port_hdl Port handle
- * @param port_evt_queue Port event queue
- * @param already_disabled If the port is already disabled, it will skip disabling the port
- */
-static void wait_for_disconnection(hcd_port_handle_t port_hdl, QueueHandle_t port_evt_queue, bool already_disabled)
-{
-    if (!already_disabled) {
-        //Disable the device
-        printf("Disabling\n");
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_DISABLE));
-        TEST_ASSERT_EQUAL(HCD_PORT_STATE_DISABLED, hcd_port_get_state(port_hdl));
-    }
-    //Wait for a safe disconnect
-    printf("Waiting for disconnection\n");
-    phy_force_conn_state(false, pdMS_TO_TICKS(100));    //Force disconnected state on PHY
-    expect_port_event(port_evt_queue, port_hdl, HCD_PORT_EVENT_DISCONNECTION);
-    TEST_ASSERT_EQUAL(HCD_PORT_EVENT_DISCONNECTION, hcd_port_handle_event(port_hdl));
-    TEST_ASSERT_EQUAL(HCD_PORT_STATE_DISCONNECTED, hcd_port_get_state(port_hdl));
-    //Power down the port
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_POWER_OFF));
-    TEST_ASSERT_EQUAL(HCD_PORT_STATE_NOT_POWERED, hcd_port_get_state(port_hdl));
-}
-
-static void alloc_pipe_and_irp_list(hcd_port_handle_t port_hdl,
-                                    QueueHandle_t pipe_evt_queue,
-                                    int num_irps,
-                                    hcd_pipe_handle_t *pipe_hdl,
-                                    usb_irp_t ***irp_list)
-{
-    //We don't support hubs yet. Just get the speed of the port to determine the speed of the device
-    usb_speed_t port_speed;
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_get_speed(port_hdl, &port_speed));
-
-    //Create default pipe
-    printf("Creating default pipe\n");
-    hcd_pipe_config_t config = {
-        .callback = pipe_callback,
-        .callback_arg = (void *)pipe_evt_queue,
-        .context = NULL,
-        .ep_desc = NULL,    //NULL EP descriptor to create a default pipe
-        .dev_addr = 0,
-        .dev_speed = port_speed,
-    };
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_alloc(port_hdl, &config, pipe_hdl));
-    TEST_ASSERT_NOT_EQUAL(NULL, *pipe_hdl);
-    //Create IRPs and their data buffers
-    printf("Creating IRPs and IRP list\n");
-    *irp_list = heap_caps_malloc(sizeof(usb_irp_t *) * num_irps, MALLOC_CAP_DEFAULT);
-    TEST_ASSERT_NOT_EQUAL(NULL, *irp_list);
-    for (int i = 0; i < num_irps; i++) {
-        //Allocate IRP
-        usb_irp_t *irp = heap_caps_calloc(1, sizeof(usb_irp_t), MALLOC_CAP_DEFAULT);
-        TEST_ASSERT_NOT_EQUAL(NULL, irp);
-        //Allocate data buffer
-        uint8_t *data_buffer = heap_caps_malloc(sizeof(usb_ctrl_req_t) + TRANSFER_DATA_MAX_BYTES, MALLOC_CAP_DMA);
-        TEST_ASSERT_NOT_EQUAL(NULL, data_buffer);
-        //Initialize IRP and IRP list
-        irp->data_buffer = data_buffer;
-        irp->num_iso_packets = 0;
-        (*irp_list)[i] = irp;
-    }
-}
-
-static void free_pipe_and_irp_list(hcd_pipe_handle_t pipe_hdl,
-                                   int num_irps,
-                                   usb_irp_t **irp_list)
-{
-    printf("Freeing IRPs and IRP list\n");
-    for (int i = 0; i < num_irps; i++) {
-        usb_irp_t *irp = irp_list[i] ;
-        //Free data buffer
-        heap_caps_free(irp->data_buffer);
-        heap_caps_free(irp);
-    }
-    heap_caps_free(irp_list);
-    printf("Freeing default pipe\n");
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_free(pipe_hdl));
-}
-
-// ------------------------------------------------ Host Port Tests ----------------------------------------------------
-
-/*
-Test a port sudden disconnect and port recovery
-
-Purpose: Test that when sudden disconnection happens on an HCD port, the port will
-    - Generate the HCD_PORT_EVENT_SUDDEN_DISCONN and be put into the HCD_PORT_STATE_RECOVERY state
-    - Ongoing IRPs and pipes are handled correctly
-
-Procedure:
-    - Setup HCD, a default pipe, and multiple IRPs
-    - Start transfers but immediately trigger a disconnect
-    - Check that HCD_PORT_EVENT_SUDDEN_DISCONN event is generated
-    - Check that default pipe is invalid and IRPs can be dequeued
-    - Recover the port and try to connect then disconnect again (to make sure the port works port recovery)
-    - Teardown HCD
-*/
-TEST_CASE("Test HCD port sudden disconnect", "[hcd][ignore]")
-{
-    QueueHandle_t port_evt_queue;
-    QueueHandle_t pipe_evt_queue;
-    hcd_port_handle_t port_hdl;
-    setup(&port_evt_queue, &pipe_evt_queue, &port_hdl);
-    wait_for_connection(port_hdl, port_evt_queue);
-    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
-
-    //Allocate default pipe and IRPs
-    hcd_pipe_handle_t default_pipe;
-    usb_irp_t **irp_list;
-    alloc_pipe_and_irp_list(port_hdl, pipe_evt_queue, NUM_IRPS, &default_pipe, &irp_list);
-
-    //Initialize IRPs to send a "Get Device Descriptor" request
-    for (int i = 0; i < NUM_IRPS; i++) {
-        irp_list[i]->num_bytes = 64;    //1 worst case MPS
-        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *) irp_list[i]->data_buffer, 0, TRANSFER_DATA_MAX_BYTES);
-        irp_list[i]->context = IRP_CONTEXT_VAL;
-    }
-
-    //Enqueue those IRPs
-    for (int i = 0; i < NUM_IRPS; i++) {
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
-    }
-    phy_force_conn_state(false, 0);    //Force disconnected state on PHY
-
-    expect_port_event(port_evt_queue, port_hdl, HCD_PORT_EVENT_SUDDEN_DISCONN);
-    TEST_ASSERT_EQUAL(HCD_PORT_EVENT_SUDDEN_DISCONN, hcd_port_handle_event(port_hdl));
-    TEST_ASSERT_EQUAL(HCD_PORT_STATE_RECOVERY, hcd_port_get_state(port_hdl));
-    printf("Sudden disconnect\n");
-
-    //Handling the disconnection event should have invalidated all pipes.
-    //Pipe should have received (zero or more HCD_PIPE_EVENT_IRP_DONE) followed by a HCD_PIPE_EVENT_INVALID (MUST OCCUR)
-    int num_pipe_events = EVENT_QUEUE_LEN - uxQueueSpacesAvailable(pipe_evt_queue);
-    for (int i = 0; i < num_pipe_events - 1; i++) {
-        expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_IRP_DONE);
-    }
-    expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_INVALID);
-    TEST_ASSERT_EQUAL(hcd_pipe_get_state(default_pipe), HCD_PIPE_STATE_INVALID);
-
-    //Dequeue IRPs
-    for (int i = 0; i < NUM_IRPS; i++) {
-        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
-        TEST_ASSERT_NOT_EQUAL(NULL, irp);
-        TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_COMPLETED || irp->status == USB_TRANSFER_STATUS_NO_DEVICE);
-        TEST_ASSERT(irp->context == IRP_CONTEXT_VAL);
-    }
-    //Free IRPs
-    free_pipe_and_irp_list(default_pipe, NUM_IRPS, irp_list);
-
-    //Recover the port should return to the to NOT POWERED state
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_recover(port_hdl));
-    TEST_ASSERT_EQUAL(HCD_PORT_STATE_NOT_POWERED, hcd_port_get_state(port_hdl));
-
-    //Recovered port should be able to connect and disconnect again
-    wait_for_connection(port_hdl, port_evt_queue);
-    wait_for_disconnection(port_hdl, port_evt_queue, false);
-    teardown(port_evt_queue, pipe_evt_queue, port_hdl);
-}
-
-/*
-Test port suspend and resume with active pipes
-
-Purpose:
-    - Test port suspend and resume commands work correctly whilst there are active pipes with ongoing transfers
-    - When suspending, the pipes should be allowed to finish their current ongoing transfer before the bus is suspended.
-    - When resuming, pipes with pending transfer should be started after the bus is resumed.
-
-Procedure:
-    - Setup HCD, a port, a default pipe, and multiple IRPS
-    - Start transfers but immediately suspend the port
-    - Resume the port
-    - Check all IRPs have also be resumed and completed on port resume
-    - Teardown
-*/
-TEST_CASE("Test HCD port suspend and resume", "[hcd][ignore]")
-{
-    QueueHandle_t port_evt_queue;
-    QueueHandle_t pipe_evt_queue;
-    hcd_port_handle_t port_hdl;
-    setup(&port_evt_queue, &pipe_evt_queue, &port_hdl);
-    wait_for_connection(port_hdl, port_evt_queue);
-    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
-
-    //Allocate default pipe and IRPs
-    hcd_pipe_handle_t default_pipe;
-    usb_irp_t **irp_list;
-    alloc_pipe_and_irp_list(port_hdl, pipe_evt_queue, NUM_IRPS, &default_pipe, &irp_list);
-
-    //Initialize IRPs to send a "Get Device Descriptor" request
-    for (int i = 0; i < NUM_IRPS; i++) {
-        irp_list[i]->num_bytes = 64;    //1 worst case MPS
-        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *)irp_list[i]->data_buffer, 0, TRANSFER_DATA_MAX_BYTES);
-        irp_list[i]->context = IRP_CONTEXT_VAL;
-    }
-
-    //Enqueue those IRPs
-    for (int i = 0; i < NUM_IRPS; i++) {
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
-    }
-
-    //Immediately suspend the bus whilst pies are active
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_SUSPEND));
-    TEST_ASSERT_EQUAL(HCD_PORT_STATE_SUSPENDED, hcd_port_get_state(port_hdl));
-    printf("Suspended\n");
-    vTaskDelay(pdMS_TO_TICKS(100));
-
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_RESUME));
-    TEST_ASSERT_EQUAL(HCD_PORT_STATE_ENABLED, hcd_port_get_state(port_hdl));
-    vTaskDelay(pdMS_TO_TICKS(100)); //Give some time for resumed transfers to complete
-
-    //Dequeue IRPs
-    for (int i = 0; i < NUM_IRPS; i++) {
-        expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_IRP_DONE);
-        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
-        TEST_ASSERT_NOT_EQUAL(NULL, irp);
-        TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_COMPLETED);
-        TEST_ASSERT(irp->context == IRP_CONTEXT_VAL);
-    }
-    //Free IRPs
-    free_pipe_and_irp_list(default_pipe, NUM_IRPS, irp_list);
-
-    //Cleanup
-    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
-    wait_for_disconnection(port_hdl, port_evt_queue, false);
-    teardown(port_evt_queue, pipe_evt_queue, port_hdl);
-}
-
-/*
-Test HCD port disable with active pipes
-
-Purpose:
-    - Test that the port disable command works correctly with active pipes
-    - Pipes should be to finish their current ongoing transfer before port is disabled
-    - After disabling the port, all pipes should become invalid.
-
-Procedure:
-    - Setup HCD, a default pipe, and multiple IRPs
-    - Start transfers but immediately disable the port
-    - Check pipe received invalid event
-    - Check that transfer are either done or not executed
-    - Teardown
-*/
-TEST_CASE("Test HCD port disable", "[hcd][ignore]")
-{
-    QueueHandle_t port_evt_queue;
-    QueueHandle_t pipe_evt_queue;
-    hcd_port_handle_t port_hdl;
-    setup(&port_evt_queue, &pipe_evt_queue, &port_hdl);
-    wait_for_connection(port_hdl, port_evt_queue);
-    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
-
-    //Allocate default pipe and IRPs
-    hcd_pipe_handle_t default_pipe;
-    usb_irp_t **irp_list;
-    alloc_pipe_and_irp_list(port_hdl, pipe_evt_queue, NUM_IRPS, &default_pipe, &irp_list);
-
-    //Initialize IRPs to send a "Get Device Descriptor" request
-    for (int i = 0; i < NUM_IRPS; i++) {
-        irp_list[i]->num_bytes = 64;    //1 worst case MPS
-        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *) irp_list[i]->data_buffer, 0, TRANSFER_DATA_MAX_BYTES);
-        irp_list[i]->context = IRP_CONTEXT_VAL;
-    }
-
-    //Enqueue those IRPs
-    for (int i = 0; i < NUM_IRPS; i++) {
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
-    }
-    //Immediately disable port
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_DISABLE));
-    TEST_ASSERT_EQUAL(HCD_PORT_STATE_DISABLED, hcd_port_get_state(port_hdl));
-    printf("Disabled\n");
-
-    //Pipe should have received (zero or more HCD_PIPE_EVENT_IRP_DONE) followed by a HCD_PIPE_EVENT_INVALID (MUST OCCUR)
-    int num_pipe_events = EVENT_QUEUE_LEN - uxQueueSpacesAvailable(pipe_evt_queue);
-    for (int i = 0; i < num_pipe_events - 1; i++) {
-        expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_IRP_DONE);
-    }
-    expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_INVALID);
-
-    //Dequeue IRPs
-    for (int i = 0; i < NUM_IRPS; i++) {
-        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
-        TEST_ASSERT_NOT_EQUAL(NULL, irp);
-        TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_COMPLETED || irp->status == USB_TRANSFER_STATUS_NO_DEVICE);
-        TEST_ASSERT(irp->context == IRP_CONTEXT_VAL);
-    }
-    //Free IRPs
-    free_pipe_and_irp_list(default_pipe, NUM_IRPS, irp_list);
-
-    //Already disabled. Disconnect and teardown
-    wait_for_disconnection(port_hdl, port_evt_queue, true);
-    teardown(port_evt_queue, pipe_evt_queue, port_hdl);
-}
-
-/*
-Test HCD port command bailout
-
-Purpose:
-    - Test that if the a port's state changes whilst a command is being executed, the port command should return
-       ESP_ERR_INVALID_RESPONSE
-
-Procedure:
-    - Setup HCD and wait for connection
-    - Suspend the port
-    - Resume the port but trigger a disconnect from another thread during the resume command
-    - Check that port command returns ESP_ERR_INVALID_RESPONSE
-*/
-static void concurrent_task(void *arg)
-{
-    SemaphoreHandle_t sync_sem = (SemaphoreHandle_t) arg;
-    xSemaphoreTake(sync_sem, portMAX_DELAY);
-    vTaskDelay(pdMS_TO_TICKS(10));  //Give a short delay let reset command start in main thread
-    //Forcibly a disconnection
-    phy_force_conn_state(false, 0);
-    vTaskDelay(portMAX_DELAY);  //Block forever and wait to be deleted
-}
-
-TEST_CASE("Test HCD port command bailout", "[hcd][ignore]")
-{
-    QueueHandle_t port_evt_queue;
-    QueueHandle_t pipe_evt_queue;
-    hcd_port_handle_t port_hdl;
-    setup(&port_evt_queue, &pipe_evt_queue, &port_hdl);
-    wait_for_connection(port_hdl, port_evt_queue);
-    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
-
-    //Create task to run commands concurrently
-    SemaphoreHandle_t sync_sem = xSemaphoreCreateBinary();
-    TaskHandle_t task_handle;
-    TEST_ASSERT_NOT_EQUAL(NULL, sync_sem);
-    TEST_ASSERT_EQUAL(pdTRUE, xTaskCreatePinnedToCore(concurrent_task, "tsk", 4096, (void *) sync_sem, UNITY_FREERTOS_PRIORITY + 1, &task_handle, 0));
-
-    //Suspend the device
-    printf("Suspending\n");
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_SUSPEND));
-    vTaskDelay(pdMS_TO_TICKS(20)); //Short delay for device to enter suspend state
-
-    printf("Attempting to resume\n");
-    xSemaphoreGive(sync_sem);   //Trigger concurrent task
-    //Attempt to resume the port. But the concurrent task should override this with a disconnection event
-    TEST_ASSERT_EQUAL(ESP_ERR_INVALID_RESPONSE, hcd_port_command(port_hdl, HCD_PORT_CMD_RESUME));
-
-    //Check that concurrent task triggered a sudden disconnection
-    expect_port_event(port_evt_queue, port_hdl, HCD_PORT_EVENT_SUDDEN_DISCONN);
-    TEST_ASSERT_EQUAL(HCD_PORT_EVENT_SUDDEN_DISCONN, hcd_port_handle_event(port_hdl));
-    TEST_ASSERT_EQUAL(HCD_PORT_STATE_RECOVERY, hcd_port_get_state(port_hdl));
-
-    vTaskDelay(pdMS_TO_TICKS(10)); //Short delay for concurrent task finish running
-    vTaskDelete(task_handle);
-    vSemaphoreDelete(sync_sem);
-    //Directly teardown the port without recovery
-    teardown(port_evt_queue, pipe_evt_queue, port_hdl);
-}
-
-// --------------------------------------------------- Pipe Tests ------------------------------------------------------
-
-/*
-Test HCD IRPs (normal completion and early abort)
-
-Purpose:
-    - Test that pipes can be created
-    - IRPs can be created and enqueued
-    - Pipe returns HCD_PIPE_EVENT_IRP_DONE
-    - Test that IRPs can be aborted when enqueued
-
-Procedure:
-    - Setup
-    - Allocate IRPs. Initialize as Get Device Descriptor request
-    - Enqueue IRPs
-    - Expect HCD_PIPE_EVENT_IRP_DONE. Deallocate IRPs
-    - Requeue IRPs, but abort them immediately
-    - Teardown
-*/
-TEST_CASE("Test HCD IRP enqueue", "[hcd][ignore]")
-{
-    QueueHandle_t port_evt_queue;
-    QueueHandle_t pipe_evt_queue;
-    hcd_port_handle_t port_hdl;
-    setup(&port_evt_queue, &pipe_evt_queue, &port_hdl);
-    wait_for_connection(port_hdl, port_evt_queue);
-    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
-
-    //Allocate default pipe and IRPs
-    hcd_pipe_handle_t default_pipe;
-    usb_irp_t **irp_list;
-    alloc_pipe_and_irp_list(port_hdl, pipe_evt_queue, NUM_IRPS, &default_pipe, &irp_list);
-
-    //Initialize IRPs to send a "Get Config Descriptor 0" request
-    for (int i = 0; i < NUM_IRPS; i++) {
-        irp_list[i]->num_bytes = 64;    //1 worst case MPS
-        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *) irp_list[i]->data_buffer, 0, TRANSFER_DATA_MAX_BYTES);
-        irp_list[i]->context = IRP_CONTEXT_VAL;
-    }
-
-    //Enqueue those IRPs
-    for (int i = 0; i < NUM_IRPS; i++) {
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
-    }
-
-    //Wait for each done event of each IRP
-    for (int i = 0; i < NUM_IRPS; i++) {
-        expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_IRP_DONE);
-    }
-
-    //Dequeue IRPs
-    for (int i = 0; i < NUM_IRPS; i++) {
-        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
-        TEST_ASSERT_NOT_EQUAL(NULL, irp);
-        TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_COMPLETED);
-        TEST_ASSERT(irp->context == IRP_CONTEXT_VAL);
-    }
-
-    //Enqueue them again but abort them short after
-    for (int i = 0; i < NUM_IRPS; i++) {
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
-    }
-    for (int i = 0; i < NUM_IRPS; i++) {
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_abort(irp_list[i]));
-    }
-    vTaskDelay(pdMS_TO_TICKS(100)); //Give some time for any in-flight transfers to complete
-
-    expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_IRP_DONE);
-    //Wait for the IRPs to complete and dequeue them, then check results
-    for (int i = 0; i < NUM_IRPS; i++) {
-        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
-        TEST_ASSERT_NOT_EQUAL(NULL, irp);
-        TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_COMPLETED || irp->status == USB_TRANSFER_STATUS_CANCELLED);
-        TEST_ASSERT(irp->context == IRP_CONTEXT_VAL);
-    }
-
-    //Free IRPs and default pipe
-    free_pipe_and_irp_list(default_pipe, NUM_IRPS, irp_list);
-
-    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
-    wait_for_disconnection(port_hdl, port_evt_queue, false);
-    teardown(port_evt_queue, pipe_evt_queue, port_hdl);
-}
-
-/*
-Test HCD pipe STALL condition, abort, and clear
-
-Purpose:
-    - Test that a pipe can react to a STALL (i.e., a HCD_PIPE_EVENT_HALTED event)
-    - The HCD_PIPE_CMD_ABORT can retire all IRPs
-    - Pipe clear command can return the pipe to being active
-
-Procedure:
-    - Setup HCD and a port, a default pipe, and multiple IRPs
-    - Corrupt the first IRP, then enqueue all of them.
-    - The corrupted IRP should trigger a STALL response from the endpoint
-    - Check that the correct pipe event, error, and state is returned from the pipe
-    - Check that the other transfers can be retired using the abort command
-    - Check that the halt can be cleared by using the clear command
-    - Requeue correct transfers to check that pipe still works after being cleared
-    - Teardown
-*/
-TEST_CASE("Test HCD pipe STALL", "[hcd][ignore]")
-{
-    QueueHandle_t port_evt_queue;
-    QueueHandle_t pipe_evt_queue;
-    hcd_port_handle_t port_hdl;
-    setup(&port_evt_queue, &pipe_evt_queue, &port_hdl);
-    wait_for_connection(port_hdl, port_evt_queue);
-    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
-
-    //Allocate default pipe and IRPs
-    hcd_pipe_handle_t default_pipe;
-    usb_irp_t **irp_list;
-    alloc_pipe_and_irp_list(port_hdl, pipe_evt_queue, NUM_IRPS, &default_pipe, &irp_list);
-
-    //Initialize IRPs to send a "Get Device Descriptor" request
-    for (int i = 0; i < NUM_IRPS; i++) {
-        irp_list[i]->num_bytes = 64;    //1 worst case MPS
-        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *) irp_list[i]->data_buffer, 0, TRANSFER_DATA_MAX_BYTES);
-        irp_list[i]->context = IRP_CONTEXT_VAL;
-    }
-    //Corrupt first transfer so that it triggers a STALL
-    ((usb_ctrl_req_t *)irp_list[0]->data_buffer)->bRequest = 0xAA;
-
-    //Enqueue those IRPs
-    for (int i = 0; i < NUM_IRPS; i++) {
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
-    }
-    vTaskDelay(pdMS_TO_TICKS(100)); //Give some time for transfers to complete
-
-    //Check that pipe has been stalled
-    printf("Expecting STALL\n");
-    expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_ERROR_STALL);
-    TEST_ASSERT_EQUAL(HCD_PIPE_STATE_HALTED, hcd_pipe_get_state(default_pipe));
-
-    //Call the pipe abort command to retire all transfers then dequeue all transfers
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_command(default_pipe, HCD_PIPE_CMD_ABORT));
-    //Dequeue IRPs
-    for (int i = 0; i < NUM_IRPS; i++) {
-        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
-        TEST_ASSERT_NOT_EQUAL(NULL, irp);
-        TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_STALL || irp->status == USB_TRANSFER_STATUS_CANCELLED);
-        TEST_ASSERT(irp->context == IRP_CONTEXT_VAL);
-    }
-
-    //Call the clear command to un-stall the pipe
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_command(default_pipe, HCD_PIPE_CMD_CLEAR));
-    TEST_ASSERT_EQUAL(HCD_PIPE_STATE_ACTIVE, hcd_pipe_get_state(default_pipe));
-
-    //Correct first transfer then requeue
-    USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *) irp_list[0]->data_buffer, 0, TRANSFER_DATA_MAX_BYTES);
-    for (int i = 0; i < NUM_IRPS; i++) {
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
-    }
-    vTaskDelay(pdMS_TO_TICKS(100)); //Give some time for transfers to complete
-
-    //Wait for the IRPs to complete and dequeue them, then check results
-    for (int i = 0; i < NUM_IRPS; i++) {
-        expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_IRP_DONE);
-        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
-        TEST_ASSERT_NOT_EQUAL(NULL, irp);
-        TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_COMPLETED);
-        TEST_ASSERT(irp->context == IRP_CONTEXT_VAL);
-    }
-    //Free IRPs
-    free_pipe_and_irp_list(default_pipe, NUM_IRPS, irp_list);
-
-    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
-    wait_for_disconnection(port_hdl, port_evt_queue, false);
-    teardown(port_evt_queue, pipe_evt_queue, port_hdl);
-}
-
-/*
-Test Pipe runtime halt and clear
-
-Purpose:
-    - Test that a pipe can be halted with a command whilst there are ongoing IRPs
-    - Test that a pipe can be un-halted with a HCD_PIPE_CMD_CLEAR
-    - Test that enqueued IRPs are resumed when pipe is cleared
-
-Procedure:
-    - Setup HCD, a default pipe, and multiple IRPs
-    - Enqueue IRPs but execute a HCD_PIPE_CMD_HALT command immediately after. Halt command should let on
-      the current going IRP finish before actually halting the pipe.
-    - Clear the pipe halt using a HCD_PIPE_CMD_HALT command. Enqueued IRPs will be resumed
-    - Check that all IRPs have completed successfully.
-    - Teardown
-*/
-TEST_CASE("Test HCD pipe runtime halt and clear", "[hcd][ignore]")
-{
-    QueueHandle_t port_evt_queue;
-    QueueHandle_t pipe_evt_queue;
-    hcd_port_handle_t port_hdl;
-    setup(&port_evt_queue, &pipe_evt_queue, &port_hdl);
-    wait_for_connection(port_hdl, port_evt_queue);
-    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
-
-    //Allocate default pipe and IRPs
-    hcd_pipe_handle_t default_pipe;
-    usb_irp_t **irp_list;
-    alloc_pipe_and_irp_list(port_hdl, pipe_evt_queue, NUM_IRPS, &default_pipe, &irp_list);
-
-    //Initialize IRPs to send a "Get Device Descriptor" request
-    for (int i = 0; i < NUM_IRPS; i++) {
-        irp_list[i]->num_bytes = 64;    //1 worst case MPS
-        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *)irp_list[i]->data_buffer, 0, TRANSFER_DATA_MAX_BYTES);
-        irp_list[i]->context = IRP_CONTEXT_VAL;
-    }
-
-    printf("Enqueuing IRPs\n");
-    //Enqueue those IRPs
-    for (int i = 0; i < NUM_IRPS; i++) {
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
-    }
-
-    //Halt the pipe immediately
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_command(default_pipe, HCD_PIPE_CMD_HALT));
-    TEST_ASSERT_EQUAL(HCD_PIPE_STATE_HALTED, hcd_pipe_get_state(default_pipe));
-    printf("Pipe halted\n");
-    vTaskDelay(pdMS_TO_TICKS(100)); //Give some time for current in-flight transfer to complete
-
-    //Clear command to un-halt the pipe
-    TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_command(default_pipe, HCD_PIPE_CMD_CLEAR));
-    TEST_ASSERT_EQUAL(HCD_PIPE_STATE_ACTIVE, hcd_pipe_get_state(default_pipe));
-    printf("Pipe cleared\n");
-    vTaskDelay(pdMS_TO_TICKS(100)); //Give some time pending for transfers to restart and complete
-
-    //Dequeue IRPs
-    for (int i = 0; i < NUM_IRPS; i++) {
-        expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_IRP_DONE);
-        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
-        TEST_ASSERT_NOT_EQUAL(NULL, irp);
-        TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_COMPLETED);
-        TEST_ASSERT(irp->context == IRP_CONTEXT_VAL);
-    }
-    //Free IRPs
-    free_pipe_and_irp_list(default_pipe, NUM_IRPS, irp_list);
-
-    vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
-    wait_for_disconnection(port_hdl, port_evt_queue, false);
-    teardown(port_evt_queue, pipe_evt_queue, port_hdl);
-}
-- 
2.25.1


From e31f91bcd1e9fe1eb58f1140adc4d4e50a48946a Mon Sep 17 00:00:00 2001
From: Li Bo <libo@espressif.com>
Date: Mon, 24 May 2021 18:21:21 +0800
Subject: [PATCH 42/43] update spi workaround 210526

---
 components/driver/spi_master.c              | 19 +++++++++++++++++++
 components/hal/esp32s2/include/hal/spi_ll.h |  5 +++++
 2 files changed, 24 insertions(+)

diff --git a/components/driver/spi_master.c b/components/driver/spi_master.c
index e6e093afb1..c92bf66a57 100644
--- a/components/driver/spi_master.c
+++ b/components/driver/spi_master.c
@@ -568,6 +568,25 @@ static void SPI_MASTER_ISR_ATTR spi_new_trans(spi_device_t *dev, spi_trans_priv_
 
     //Call pre-transmission callback, if any
     if (dev->cfg.pre_cb) dev->cfg.pre_cb(trans);
+
+#ifdef CONFIG_IDF_TARGET_ESP32S2
+    //USB Bug workaround, only for SPI2
+    //while (!((spi_ll_tx_get_fifo_cnt(SPI_LL_GET_HW(host->id)) == 12) || (spi_ll_tx_get_fifo_cnt(SPI_LL_GET_HW(host->id)) == trans->length / 8))) {
+    if (host->id == SPI2_HOST) {
+        while (trans->length && ((trans->length >= 96 && spi_ll_tx_get_fifo_cnt(SPI_LL_GET_HW(host->id)) < 12) || (trans->length < 96 && spi_ll_tx_get_fifo_cnt(SPI_LL_GET_HW(host->id)) < trans->length/8))) {
+            __asm__ __volatile__("nop");
+            __asm__ __volatile__("nop");
+            __asm__ __volatile__("nop");
+        }
+    } else if (host->id == SPI3_HOST) {
+        while (trans->length && spi_ll_tx_get_fifo_cnt(SPI_LL_GET_HW(host->id)) == 0) {
+            __asm__ __volatile__("nop");
+            __asm__ __volatile__("nop");
+            __asm__ __volatile__("nop");
+        }
+    }
+#endif
+
     //Kick off transfer
     spi_hal_user_start(hal);
 }
diff --git a/components/hal/esp32s2/include/hal/spi_ll.h b/components/hal/esp32s2/include/hal/spi_ll.h
index 5ede97d958..7ab026d3cc 100644
--- a/components/hal/esp32s2/include/hal/spi_ll.h
+++ b/components/hal/esp32s2/include/hal/spi_ll.h
@@ -1256,6 +1256,11 @@ static inline bool spi_ll_tx_get_empty_err(spi_dev_t *hw)
     return hw->dma_int_raw.outfifo_empty_err;
 }
 
+static inline int spi_ll_tx_get_fifo_cnt(spi_dev_t *hw)
+{
+    return hw->dma_out_status.out_fifo_cnt;
+}
+
 #undef SPI_LL_RST_MASK
 #undef SPI_LL_UNUSED_INT_MASK
 
-- 
2.25.1


From 1c6a26c3fe096317ae77a235c16888e3f5cf6bb2 Mon Sep 17 00:00:00 2001
From: Li Bo <libo@espressif.com>
Date: Wed, 26 May 2021 20:56:42 +0800
Subject: [PATCH 43/43] HCD: make api public

---
 components/usb/CMakeLists.txt | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/components/usb/CMakeLists.txt b/components/usb/CMakeLists.txt
index 8d22022222..8b67214845 100644
--- a/components/usb/CMakeLists.txt
+++ b/components/usb/CMakeLists.txt
@@ -6,5 +6,5 @@ if(NOT "${target}" STREQUAL "esp32s2")
 endif()
 
 idf_component_register(SRCS "hcd.c"
-                    INCLUDE_DIRS ""
-                    PRIV_INCLUDE_DIRS "private_include")
+                    INCLUDE_DIRS "" "private_include"
+                    )
-- 
2.25.1

