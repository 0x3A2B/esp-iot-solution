From 502cde10923f5005b676aa7e967e8a6bebf88a8a Mon Sep 17 00:00:00 2001
From: Darian Leung <darian@espressif.com>
Date: Fri, 5 Mar 2021 20:51:25 +0800
Subject: [PATCH 1/9] Separate USB HAL and common USB types

This commit separates out the common USB types used throughout most of the stack into its
own header file inside the USB component. The types used in the USB HAL are now exclusive
to the HAL.

Signed-off-by: Li Bo <libo@espressif.com>
---
 components/hal/esp32s2/include/hal/usbh_hal.h |   6 +-
 components/hal/esp32s2/include/hal/usbh_ll.h  |  40 +-
 components/hal/esp32s2/usbh_hal.c             |   6 +-
 components/hal/include/hal/usb_types.h        | 440 +----------------
 components/usb/hcd.c                          |  37 +-
 components/usb/private_include/hcd.h          |   3 +-
 components/usb/private_include/usb.h          | 444 ++++++++++++++++++
 7 files changed, 514 insertions(+), 462 deletions(-)
 create mode 100644 components/usb/private_include/usb.h

diff --git a/components/hal/esp32s2/include/hal/usbh_hal.h b/components/hal/esp32s2/include/hal/usbh_hal.h
index 6e1f05773..0a777f59d 100644
--- a/components/hal/esp32s2/include/hal/usbh_hal.h
+++ b/components/hal/esp32s2/include/hal/usbh_hal.h
@@ -121,7 +121,7 @@ typedef enum {
 typedef struct {
     union {
         struct {
-            usb_xfer_type_t type: 2;        /**< The type of endpoint */
+            usb_hal_xfer_type_t type: 2;    /**< The type of endpoint */
             uint32_t bEndpointAddress: 8;   /**< Endpoint address (containing endpoint number and direction) */
             uint32_t mps: 11;               /**< Maximum Packet Size */
             uint32_t dev_addr: 8;           /**< Device Address */
@@ -413,9 +413,9 @@ static inline bool usbh_hal_port_check_if_connected(usbh_hal_context_t *hal)
  *       connected to the host port
  *
  * @param hal Context of the HAL layer
- * @return usb_speed_t Speed of the connected device
+ * @return usb_hal_speed_t Speed of the connected device
  */
-static inline usb_speed_t usbh_hal_port_get_conn_speed(usbh_hal_context_t *hal)
+static inline usb_hal_speed_t usbh_hal_port_get_conn_speed(usbh_hal_context_t *hal)
 {
     return usbh_ll_hprt_get_speed(hal->dev);
 }
diff --git a/components/hal/esp32s2/include/hal/usbh_ll.h b/components/hal/esp32s2/include/hal/usbh_ll.h
index af82e25b8..13d609d93 100644
--- a/components/hal/esp32s2/include/hal/usbh_ll.h
+++ b/components/hal/esp32s2/include/hal/usbh_ll.h
@@ -419,7 +419,7 @@ static inline void usbh_ll_hcfg_set_fsls_pclk_sel(usbh_dev_t *hw)
  *
  * @param hw
  */
-static inline void usbh_ll_hcfg_set_defaults(usbh_dev_t *hw, usb_speed_t speed)
+static inline void usbh_ll_hcfg_set_defaults(usbh_dev_t *hw, usb_hal_speed_t speed)
 {
     hw->hcfg_reg.descdma = 1;   //Enable scatt/gatt
     hw->hcfg_reg.fslssupp = 1;  //FS/LS supp only
@@ -428,13 +428,13 @@ static inline void usbh_ll_hcfg_set_defaults(usbh_dev_t *hw, usb_speed_t speed)
     Note: It seems like our PHY has an implicit 8 divider applied when in LS mode,
           so the values of FSLSPclkSel and FrInt have to be adjusted accordingly.
     */
-    hw->hcfg_reg.fslspclksel = (speed == USB_SPEED_FULL) ? 1 : 2;
+    hw->hcfg_reg.fslspclksel = (speed == USB_HAL_SPEED_FULL) ? 1 : 2;
     hw->hcfg_reg.perschedena = 0;   //Disable perio sched
 }
 
 // ----------------------------- HFIR Register ---------------------------------
 
-static inline void usbh_ll_hfir_set_defaults(usbh_dev_t *hw, usb_speed_t speed)
+static inline void usbh_ll_hfir_set_defaults(usbh_dev_t *hw, usb_hal_speed_t speed)
 {
     usb_hfir_reg_t hfir;
     hfir.val = hw->hfir_reg.val;
@@ -444,7 +444,7 @@ static inline void usbh_ll_hfir_set_defaults(usbh_dev_t *hw, usb_speed_t speed)
     Note: It seems like our PHY has an implicit 8 divider applied when in LS mode,
           so the values of FSLSPclkSel and FrInt have to be adjusted accordingly.
     */
-    hfir.frint = (speed == USB_SPEED_FULL) ? 48000 : 6000;
+    hfir.frint = (speed == USB_HAL_SPEED_FULL) ? 48000 : 6000;
     hw->hfir_reg.val = hfir.val;
 }
 
@@ -510,14 +510,9 @@ static inline uint32_t usbh_ll_get_frame_list_base_addr(usbh_dev_t *hw)
 
 // ----------------------------- HPRT Register ---------------------------------
 
-static inline usb_speed_t usbh_ll_hprt_get_speed(usbh_dev_t *hw)
+static inline usb_hal_speed_t usbh_ll_hprt_get_speed(usbh_dev_t *hw)
 {
-    int prtspd = hw->hprt_reg.prtspd;
-    if (prtspd == 1) {
-        return USB_SPEED_FULL;
-    } else {
-        return USB_SPEED_LOW;
-    }
+    return (usb_hal_speed_t) hw->hprt_reg.prtspd;
 }
 
 static inline uint32_t usbh_ll_hprt_get_test_ctl(usbh_dev_t *hw)
@@ -674,24 +669,9 @@ static inline void usbh_ll_chan_set_dev_addr(volatile usb_host_chan_regs_t *chan
     chan->hcchar_reg.devaddr = addr;
 }
 
-static inline void usbh_ll_chan_set_ep_type(volatile usb_host_chan_regs_t *chan, usb_xfer_type_t type)
-{
-    switch (type) {
-        case USB_XFER_TYPE_CTRL:
-            chan->hcchar_reg.eptype = 0x0;
-            break;
-        case USB_XFER_TYPE_ISOCHRONOUS:
-            chan->hcchar_reg.eptype = 0x1;
-            break;
-        case USB_XFER_TYPE_BULK:
-            chan->hcchar_reg.eptype = 0x2;
-            break;
-        case USB_XFER_TYPE_INTR:
-            chan->hcchar_reg.eptype = 0x3;
-            break;
-        default:
-            ;
-    }
+static inline void usbh_ll_chan_set_ep_type(volatile usb_host_chan_regs_t *chan, usb_hal_xfer_type_t type)
+{
+    chan->hcchar_reg.eptype = type;
 }
 
 //Indicates whether channel is commuunicating with a LS device connected via a FS hub. Setting this bit to 1 will cause
@@ -716,7 +696,7 @@ static inline void usbh_ll_chan_set_mps(volatile usb_host_chan_regs_t *chan, uin
     chan->hcchar_reg.mps = mps;
 }
 
-static inline void usbh_ll_chan_hcchar_init(volatile usb_host_chan_regs_t *chan, int dev_addr, int ep_num, int mps, usb_xfer_type_t type, bool is_in, bool is_ls)
+static inline void usbh_ll_chan_hcchar_init(volatile usb_host_chan_regs_t *chan, int dev_addr, int ep_num, int mps, usb_hal_xfer_type_t type, bool is_in, bool is_ls)
 {
     //Sets all persistent fields of the channel over its lifetime
     usbh_ll_chan_set_dev_addr(chan, dev_addr);
diff --git a/components/hal/esp32s2/usbh_hal.c b/components/hal/esp32s2/usbh_hal.c
index b00a08ae8..b3b30942b 100644
--- a/components/hal/esp32s2/usbh_hal.c
+++ b/components/hal/esp32s2/usbh_hal.c
@@ -191,7 +191,7 @@ static inline void debounce_lock_enable(usbh_hal_context_t *hal)
 
 void usbh_hal_port_enable(usbh_hal_context_t *hal)
 {
-    usb_speed_t speed = usbh_ll_hprt_get_speed(hal->dev);
+    usb_hal_speed_t speed = usbh_ll_hprt_get_speed(hal->dev);
     //Host Configuration
     usbh_ll_hcfg_set_defaults(hal->dev, speed);
     //Todo: Set frame list entries and ena per sched
@@ -263,10 +263,10 @@ void usbh_hal_chan_set_ep_char(usbh_hal_chan_t *chan_obj, usbh_hal_ep_char_t *ep
     //Set the endpoint characteristics of the pipe
     usbh_ll_chan_hcchar_init(chan_obj->regs,
                              ep_char->dev_addr,
-                             ep_char->bEndpointAddress & USB_B_ENDPOINT_ADDRESS_EP_NUM_MASK,
+                             ep_char->bEndpointAddress & USB_HAL_BENDPOINTADDRESS_NUM_MSK,
                              ep_char->mps,
                              ep_char->type,
-                             ep_char->bEndpointAddress & USB_B_ENDPOINT_ADDRESS_EP_DIR_MASK,
+                             ep_char->bEndpointAddress & USB_HAL_BENDPOINTADDRESS_DIR_MSK,
                              ep_char->ls_via_fs_hub);
 }
 
diff --git a/components/hal/include/hal/usb_types.h b/components/hal/include/hal/usb_types.h
index 00f8b8c2c..3d5ffd5d0 100644
--- a/components/hal/include/hal/usb_types.h
+++ b/components/hal/include/hal/usb_types.h
@@ -12,6 +12,14 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+/*
+Note: This header file contains USB2.0 related types and macros that can be used by code specific to driving the DWC_OTG
+controller operating in scatter/gather DMA Host mode (i.e., the HW specific layers of the USB host stack). In other
+words, this header is only meant to be used in the HAL layer and below of the USB Host stack. For types and macros that
+are HW implementation agnostic (i.e., HCD layer and above), add them to the "usb.h" header instead.
+*/
+
+
 #pragma once
 
 #ifdef __cplusplus
@@ -19,433 +27,33 @@ extern "C"
 {
 #endif
 
-#include <stdint.h>
-
-#define USB_CTRL_REQ_ATTR       __attribute__((packed))
-#define USB_DESC_ATTR           __attribute__((packed))
-
-/* -----------------------------------------------------------------------------
-------------------------------- Common USB Types -------------------------------
------------------------------------------------------------------------------ */
-
-// ----------------------------- Device Related --------------------------------
-
 /**
- * @brief Enumeration of USB PHY type
- */
-typedef enum {
-    USB_PHY_INTERNAL = 0,       /**< Use the chip's internal USB PHY */
-    USB_PHY_EXTERNAL,           /**< Use an external USB PHY */
-} usb_phy_t;
-
-// ------------------------------ Bus Related ----------------------------------
-
-/**
- * @brief USB Standard Speeds
- */
-typedef enum {
-    USB_SPEED_LOW = 0,                  /**< USB Low Speed (1.5 Mbit/s) */
-    USB_SPEED_FULL,                     /**< USB Full Speed (12 Mbit/s) */
-} usb_speed_t;
-
-// ---------------------------- Transfer Related -------------------------------
-
-/**
- * @brief The type of USB transfer
+ * @brief USB speeds supported by the DWC OTG controller
  *
- * @note The enum values need to match the bmAttributes field of an EP descriptor
+ * @note Should match the values of the HPRT.PrtSpd register field
  */
 typedef enum {
-    USB_XFER_TYPE_CTRL = 0,
-    USB_XFER_TYPE_ISOCHRONOUS,
-    USB_XFER_TYPE_BULK,
-    USB_XFER_TYPE_INTR,
-} usb_xfer_type_t;
-
-/**
- * @brief The status of a particular transfer
- */
-typedef enum {
-    USB_TRANSFER_STATUS_COMPLETED,      /**< The transfer was successful (but may be short) */
-    USB_TRANSFER_STATUS_ERROR,          /**< The transfer failed because due to excessive errors (e.g. no response or CRC error) */
-    USB_TRANSFER_STATUS_TIMED_OUT,      /**< The transfer failed due to to a time out */
-    USB_TRANSFER_STATUS_CANCELLED,      /**< The transfer was cancelled */
-    USB_TRANSFER_STATUS_STALL,          /**< The transfer was stalled */
-    USB_TRANSFER_STATUS_NO_DEVICE,      /**< The transfer failed because the device is no longer valid (e.g., disconencted */
-    USB_TRANSFER_STATUS_OVERFLOW,       /**< The transfer as more data was sent than was requested */
-} usb_transfer_status_t;
-
-/**
- * @brief Isochronous packet descriptor
- *
- * If the number of bytes in an IRP transfer is larger than the MPS of the
- * endpoint, the IRP is split over multiple packets (one packet per bInterval
- * of the endpoint). An array of Isochronous packet descriptos describes how
- * an IRP should be split over multiple packets.
- */
-typedef struct {
-    int length;                         /**< Number of bytes to transmit/receive in the packet */
-    int actual_length;                  /**< Actual number of bytes transmitted/received in the packet */
-    usb_transfer_status_t status;       /**< Status of the packet */
-} usb_iso_packet_desc_t;
-
-/**
- * @brief USB IRP (I/O Request Packet). See USB2.0 Spec
- *
- * An identifiable request by a software client to move data between itself (on the
- * host) and an endpoint of a device in an appropriate direction.
- *
- * This structure represents the barebones of the request. Different layers of
- * USB drivers will wrap their own objects around this.
- *
- * See 10.5.3.1 os USB2.0 specification
- * Bulk: Represnts a single bulk transfer which a pipe will transparently split
- *       into multiple MPS transactions (until the last)
- * Control: Represents a single contorl transfer with the setup packet at the
- *          first 8 bytes of the buffer.
- * Interrupt: Represnts a single interrupt transaction
- * Isochronous: Represnts a buffer of a stream of bytes which the pipe will transparently
- *              transfer the stream of bytes one or more service periods
- */
-typedef struct {
-    int num_bytes;                      /**< Number of bytes in IRP. Control should exclude size of setup. IN should be integer multiple of MPS */
-    int actual_num_bytes;               /**< Actual number of bytes transmitted/receives in the IRP */
-    uint8_t *data_buffer;               /**< Pointer to data buffer. Must be DMA capable memory */
-    usb_transfer_status_t status;       /**< Status of the transfer */
-    int num_iso_packets;                /**< Only relevant to isochronous. Number of service periods to transfer data buffer over. Set to 0 for non-iso transfers */
-    usb_iso_packet_desc_t iso_packet_desc[0];   /**< Descriptors for each ISO packet */
-} usb_irp_t;
-
-/* -----------------------------------------------------------------------------
------------------------------------ Chapter 9 ----------------------------------
------------------------------------------------------------------------------ */
-
-// ------------------------------ Control Request ------------------------------
-
-/**
- * @brief Size of a USB control transfer setup packet in bytes
- */
-#define USB_CTRL_REQ_SIZE       8
-
-/**
- * @brief Structure representing a USB control transfer setup packet
- */
-typedef union {
-    struct {
-        uint8_t bRequestType;
-        uint8_t bRequest;
-        uint16_t wValue;
-        uint16_t wIndex;
-        uint16_t wLength;
-    } USB_CTRL_REQ_ATTR;
-    uint8_t val[USB_CTRL_REQ_SIZE];
-} usb_ctrl_req_t;
-_Static_assert(sizeof(usb_ctrl_req_t) == USB_CTRL_REQ_SIZE, "Size of usb_ctrl_req_t incorrect");
-
-/**
- * @brief Bit masks pertaining to the bRequestType field of a setup packet
- */
-#define USB_B_REQUEST_TYPE_DIR_OUT          (0X00 << 7)
-#define USB_B_REQUEST_TYPE_DIR_IN           (0x01 << 7)
-#define USB_B_REQUEST_TYPE_TYPE_STANDARD    (0x00 << 5)
-#define USB_B_REQUEST_TYPE_TYPE_CLASS       (0x01 << 5)
-#define USB_B_REQUEST_TYPE_TYPE_VENDOR      (0x02 << 5)
-#define USB_B_REQUEST_TYPE_TYPE_RESERVED    (0x03 << 5)
-#define USB_B_REQUEST_TYPE_TYPE_MASK        (0x03 << 5)
-#define USB_B_REQUEST_TYPE_RECIP_DEVICE     (0x00 << 0)
-#define USB_B_REQUEST_TYPE_RECIP_INTERFACE  (0x01 << 0)
-#define USB_B_REQUEST_TYPE_RECIP_ENDPOINT   (0x02 << 0)
-#define USB_B_REQUEST_TYPE_RECIP_OTHER      (0x03 << 0)
-#define USB_B_REQUEST_TYPE_RECIP_MASK       (0x1f << 0)
-
-/**
- * @brief Bit masks pertaining to the bRequest field of a setup packet
- */
-#define USB_B_REQUEST_GET_STATUS            0x00
-#define USB_B_REQUEST_CLEAR_FEATURE         0x01
-#define USB_B_REQUEST_SET_FEATURE           0x03
-#define USB_B_REQUEST_SET_ADDRESS           0x05
-#define USB_B_REQUEST_GET_DESCRIPTOR        0x06
-#define USB_B_REQUEST_SET_DESCRIPTOR        0x07
-#define USB_B_REQUEST_GET_CONFIGURATION     0x08
-#define USB_B_REQUEST_SET_CONFIGURATION     0x09
-#define USB_B_REQUEST_GET_INTERFACE         0x0A
-#define USB_B_REQUEST_SET_INTERFACE         0x0B
-#define USB_B_REQUEST_SYNCH_FRAME           0x0C
-
-/**
- * @brief Bit masks pertaining to the wValue field of a setup packet
- */
-#define USB_W_VALUE_DT_DEVICE               0x01
-#define USB_W_VALUE_DT_CONFIG               0x02
-#define USB_W_VALUE_DT_STRING               0x03
-#define USB_W_VALUE_DT_INTERFACE            0x04
-#define USB_W_VALUE_DT_ENDPOINT             0x05
-#define USB_W_VALUE_DT_DEVICE_QUALIFIER     0x06
-#define USB_W_VALUE_DT_OTHER_SPEED_CONFIG   0x07
-#define USB_W_VALUE_DT_INTERFACE_POWER      0x08
-
-/**
- * @brief Initializer for a SET_ADDRESS request
- *
- * Sets the address of a connected device
- */
-#define USB_CTRL_REQ_INIT_SET_ADDR(ctrl_req_ptr, addr) ({  \
-    (ctrl_req_ptr)->bRequestType = USB_B_REQUEST_TYPE_DIR_OUT | USB_B_REQUEST_TYPE_TYPE_STANDARD |USB_B_REQUEST_TYPE_RECIP_DEVICE;   \
-    (ctrl_req_ptr)->bRequest = USB_B_REQUEST_SET_ADDRESS;  \
-    (ctrl_req_ptr)->wValue = (addr);   \
-    (ctrl_req_ptr)->wIndex = 0;    \
-    (ctrl_req_ptr)->wLength = 0;   \
-})
-
-/**
- * @brief Initializer for a request to get a device's device descriptor
- */
-#define USB_CTRL_REQ_INIT_GET_DEVC_DESC(ctrl_req_ptr) ({ \
-    (ctrl_req_ptr)->bRequestType = USB_B_REQUEST_TYPE_DIR_IN | USB_B_REQUEST_TYPE_TYPE_STANDARD | USB_B_REQUEST_TYPE_RECIP_DEVICE;   \
-    (ctrl_req_ptr)->bRequest = USB_B_REQUEST_GET_DESCRIPTOR;   \
-    (ctrl_req_ptr)->wValue = (USB_W_VALUE_DT_DEVICE << 8); \
-    (ctrl_req_ptr)->wIndex = 0;    \
-    (ctrl_req_ptr)->wLength = 18;  \
-})
-
-/**
- * @brief Initializer for a request to get a device's current configuration number
- */
-#define USB_CTRL_REQ_INIT_GET_CONFIG(ctrl_req_ptr) ({  \
-    (ctrl_req_ptr)->bRequestType = USB_B_REQUEST_TYPE_DIR_IN | USB_B_REQUEST_TYPE_TYPE_STANDARD | USB_B_REQUEST_TYPE_RECIP_DEVICE;   \
-    (ctrl_req_ptr)->bRequest = USB_B_REQUEST_GET_CONFIGURATION;    \
-    (ctrl_req_ptr)->wValue = 0;    \
-    (ctrl_req_ptr)->wIndex = 0;    \
-    (ctrl_req_ptr)->wLength = 1;   \
-})
+    USB_HAL_SPEED_FULL = 1,
+    USB_HAL_SPEED_LOW = 2,
+} usb_hal_speed_t;
 
 /**
- * @brief Initializer for a request to get one of the device's current configuration descriptor
+ * @brief USB transfer types supported by the DWC OTG controller
  *
- * - desc_index indicates the configuration's index number
- * - Number of bytes of the configuration descriptor to get
+ * @note Should match the values of the HCCHARi.EPType register field
  */
-#define USB_CTRL_REQ_INIT_GET_CFG_DESC(ctrl_req_ptr, desc_index, desc_len) ({  \
-    (ctrl_req_ptr)->bRequestType = USB_B_REQUEST_TYPE_DIR_IN | USB_B_REQUEST_TYPE_TYPE_STANDARD | USB_B_REQUEST_TYPE_RECIP_DEVICE;   \
-    (ctrl_req_ptr)->bRequest = USB_B_REQUEST_GET_DESCRIPTOR;   \
-    (ctrl_req_ptr)->wValue = (USB_W_VALUE_DT_CONFIG << 8) | ((desc_index) & 0xFF); \
-    (ctrl_req_ptr)->wIndex = 0;    \
-    (ctrl_req_ptr)->wLength = (desc_len);  \
-})
-
-/**
- * @brief Initializer for a request to set a device's current configuration number
- */
-#define USB_CTRL_REQ_INIT_SET_CONFIG(ctrl_req_ptr, config_num) ({  \
-    (ctrl_req_ptr)->bRequestType = USB_B_REQUEST_TYPE_DIR_OUT | USB_B_REQUEST_TYPE_TYPE_STANDARD | USB_B_REQUEST_TYPE_RECIP_DEVICE;   \
-    (ctrl_req_ptr)->bRequest = USB_B_REQUEST_SET_CONFIGURATION;    \
-    (ctrl_req_ptr)->wValue = (config_num); \
-    (ctrl_req_ptr)->wIndex = 0;    \
-    (ctrl_req_ptr)->wLength = 0;   \
-})
-
-// ---------------------------- Device Descriptor ------------------------------
-
-/**
- * @brief Size of a USB device descriptor in bytes
- */
-#define USB_DESC_DEV_SIZE       18
-
-/**
- * @brief Structure representing a USB device descriptor
- */
-typedef union {
-    struct {
-        uint8_t bLength;
-        uint8_t bDescriptorType;
-        uint16_t bcdUSB;
-        uint8_t bDeviceClass;
-        uint8_t bDeviceSubClass;
-        uint8_t bDeviceProtocol;
-        uint8_t bMaxPacketSize0;
-        uint16_t idVendor;
-        uint16_t idProduct;
-        uint16_t bcdDevice;
-        uint8_t iManufacturer;
-        uint8_t iProduct;
-        uint8_t iSerialNumber;
-        uint8_t bNumConfigurations;
-    } USB_DESC_ATTR;
-    uint8_t val[USB_DESC_DEV_SIZE];
-} usb_desc_devc_t;
-_Static_assert(sizeof(usb_desc_devc_t) == USB_DESC_DEV_SIZE, "Size of usb_desc_devc_t incorrect");
-
-/**
- * @brief Possible base class values of the bDeviceClass field of a USB device descriptor
- */
-#define USB_CLASS_PER_INTERFACE             0x00
-#define USB_CLASS_AUDIO                     0x01
-#define USB_CLASS_COMM                      0x02
-#define USB_CLASS_HID                       0x03
-#define USB_CLASS_PHYSICAL                  0x05
-#define USB_CLASS_STILL_IMAGE               0x06
-#define USB_CLASS_PRINTER                   0x07
-#define USB_CLASS_MASS_STORAGE              0x08
-#define USB_CLASS_HUB                       0x09
-#define USB_CLASS_CDC_DATA                  0x0a
-#define USB_CLASS_CSCID                     0x0b
-#define USB_CLASS_CONTENT_SEC               0x0d
-#define USB_CLASS_VIDEO                     0x0e
-#define USB_CLASS_WIRELESS_CONTROLLER       0xe0
-#define USB_CLASS_PERSONAL_HEALTHCARE       0x0f
-#define USB_CLASS_AUDIO_VIDEO               0x10
-#define USB_CLASS_BILLBOARD                 0x11
-#define USB_CLASS_USB_TYPE_C_BRIDGE         0x12
-#define USB_CLASS_MISC                      0xef
-#define USB_CLASS_APP_SPEC                  0xfe
-#define USB_CLASS_VENDOR_SPEC               0xff
-
-/**
- * @brief Vendor specific subclass code
- */
-#define USB_SUBCLASS_VENDOR_SPEC            0xff
-
-// ----------------------- Configuration Descriptor ----------------------------
-
-/**
- * @brief Size of a short USB configuration descriptor in bytes
- *
- * @note The size of a full USB configuration includes all the interface and endpoint
- *       descriptors of that configuration.
- */
-#define USB_DESC_CFG_SIZE       9
-
-/**
- * @brief Structure representing a short USB configuration descriptor
- *
- * @note The full USB configuration includes all the interface and endpoint
- *       descriptors of that configuration.
- */
-typedef union {
-    struct {
-        uint8_t bLength;
-        uint8_t bDescriptorType;
-        uint16_t wTotalLength;
-        uint8_t bNumInterfaces;
-        uint8_t bConfigurationValue;
-        uint8_t iConfiguration;
-        uint8_t bmAttributes;
-        uint8_t bMaxPower;
-    } USB_DESC_ATTR;
-    uint8_t val[USB_DESC_CFG_SIZE];
-} usb_desc_cfg_t;
-_Static_assert(sizeof(usb_desc_cfg_t) == USB_DESC_CFG_SIZE, "Size of usb_desc_cfg_t incorrect");
-
-/**
- * @brief Bit masks pertaining to the bmAttributes field of a configuration descriptor
- */
-#define USB_BM_ATTRIBUTES_ONE               (1 << 7)    //Must be set
-#define USB_BM_ATTRIBUTES_SELFPOWER         (1 << 6)    //Self powered
-#define USB_BM_ATTRIBUTES_WAKEUP            (1 << 5)    //Can wakeup
-#define USB_BM_ATTRIBUTES_BATTERY           (1 << 4)    //Battery powered
-
-// ------------------------- Interface Descriptor ------------------------------
-
-/**
- * @brief Size of a USB interface descriptor in bytes
- */
-#define USB_DESC_INTF_SIZE      9
-
-/**
- * @brief Structure representing a USB interface descriptor
- */
-typedef union {
-    struct {
-        uint8_t bLength;
-        uint8_t bDescriptorType;
-        uint8_t bInterfaceNumber;
-        uint8_t bAlternateSetting;
-        uint8_t bNumEndpoints;
-        uint8_t bInterfaceClass;
-        uint8_t bInterfaceSubClass;
-        uint8_t bInterfaceProtocol;
-        uint8_t iInterface;
-    } USB_DESC_ATTR;
-    uint8_t val[USB_DESC_INTF_SIZE];
-} usb_desc_intf_t;
-_Static_assert(sizeof(usb_desc_intf_t) == USB_DESC_INTF_SIZE, "Size of usb_desc_intf_t incorrect");
-
-// ------------------------- Endpoint Descriptor -------------------------------
-
-/**
- * @brief Size of a USB endpoint descriptor in bytes
- */
-#define USB_DESC_EP_SIZE        7
-
-/**
- * @brief Structure representing a USB endp;oint descriptor
- */
-typedef union {
-    struct {
-        uint8_t bLength;
-        uint8_t bDescriptorType;
-        uint8_t bEndpointAddress;
-        uint8_t bmAttributes;
-        uint16_t wMaxPacketSize;
-        uint8_t bInterval;
-    } USB_DESC_ATTR;
-    uint8_t val[USB_DESC_EP_SIZE];
-} usb_desc_ep_t;
-_Static_assert(sizeof(usb_desc_ep_t) == USB_DESC_EP_SIZE, "Size of usb_desc_ep_t incorrect");
-
-/**
- * @brief Bit masks pertaining to the bEndpointAddress field of an endpoint descriptor
- */
-#define USB_B_ENDPOINT_ADDRESS_EP_NUM_MASK              0x0f
-#define USB_B_ENDPOINT_ADDRESS_EP_DIR_MASK              0x80
-
-/**
- * @brief Bit masks pertaining to the bmAttributes field of an endpoint descriptor
- */
-#define USB_BM_ATTRIBUTES_XFERTYPE_MASK                 0x03
-#define USB_BM_ATTRIBUTES_XFER_CONTROL                  (0 << 0)
-#define USB_BM_ATTRIBUTES_XFER_ISOC                     (1 << 0)
-#define USB_BM_ATTRIBUTES_XFER_BULK                     (2 << 0)
-#define USB_BM_ATTRIBUTES_XFER_INT                      (3 << 0)
-#define USB_BM_ATTRIBUTES_SYNCTYPE_MASK                 0x0C    /* in bmAttributes */
-#define USB_BM_ATTRIBUTES_SYNC_NONE                     (0 << 2)
-#define USB_BM_ATTRIBUTES_SYNC_ASYNC                    (1 << 2)
-#define USB_BM_ATTRIBUTES_SYNC_ADAPTIVE                 (2 << 2)
-#define USB_BM_ATTRIBUTES_SYNC_SYNC                     (3 << 2)
-#define USB_BM_ATTRIBUTES_USAGETYPE_MASK                0x30
-#define USB_BM_ATTRIBUTES_USAGE_DATA                    (0 << 4)
-#define USB_BM_ATTRIBUTES_USAGE_FEEDBACK                (1 << 4)
-#define USB_BM_ATTRIBUTES_USAGE_IMPLICIT_FB             (2 << 4)
-
-/**
- * @brief Macro helpers to get information about an endpoint from its descriptor
- */
-#define USB_DESC_EP_GET_XFERTYPE(desc_ptr) ((usb_xfer_type_t) ((desc_ptr)->bmAttributes & USB_BM_ATTRIBUTES_XFERTYPE_MASK))
-#define USB_DESC_EP_GET_EP_NUM(desc_ptr) ((desc_ptr)->bEndpointAddress & USB_B_ENDPOINT_ADDRESS_EP_NUM_MASK)
-#define USB_DESC_EP_GET_EP_DIR(desc_ptr) (((desc_ptr)->bEndpointAddress & USB_B_ENDPOINT_ADDRESS_EP_DIR_MASK) ? 1 : 0)
-#define USB_DESC_EP_GET_MPS(desc_ptr) ((desc_ptr)->wMaxPacketSize & 0x7FF)
-
-
-// --------------------------- String Descriptor -------------------------------
-
-/**
- * @brief Size of a short USB string descriptor in bytes
- */
-#define USB_DESC_STR_SIZE       4
+typedef enum {
+    USB_HAL_XFER_TYPE_CTRL = 0,
+    USB_HAL_XFER_TYPE_ISOCHRONOUS = 1,
+    USB_HAL_XFER_TYPE_BULK = 2,
+    USB_HAL_XFER_TYPE_INTR = 3,
+} usb_hal_xfer_type_t;
 
 /**
- * @brief Structure representing a USB string descriptor
+ * @brief Bit masks to extract the endpoint number and endpoint masks from bEndpointAddress
  */
-typedef union {
-    struct {
-        uint8_t bLength;
-        uint8_t bDescriptorType;
-        uint16_t wData[1];        /* UTF-16LE encoded */
-    } USB_DESC_ATTR;
-    uint8_t val[USB_DESC_STR_SIZE];
-} usb_desc_str_t;
-_Static_assert(sizeof(usb_desc_str_t) == USB_DESC_STR_SIZE, "Size of usb_desc_str_t incorrect");
+#define USB_HAL_BENDPOINTADDRESS_NUM_MSK     0x0F
+#define USB_HAL_BENDPOINTADDRESS_DIR_MSK     0x80
 
 #ifdef __cplusplus
 }
diff --git a/components/usb/hcd.c b/components/usb/hcd.c
index 99b9bc8f5..2494a2aa9 100644
--- a/components/usb/hcd.c
+++ b/components/usb/hcd.c
@@ -13,7 +13,10 @@
 // limitations under the License.
 
 #include <string.h>
-#include "sys/queue.h"
+#include <sys/queue.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/task.h"
+#include "freertos/semphr.h"
 #include "esp_heap_caps.h"
 #include "esp_intr_alloc.h"
 #include "esp_timer.h"
@@ -23,9 +26,7 @@
 #include "soc/gpio_pins.h"
 #include "soc/gpio_sig_map.h"
 #include "driver/periph_ctrl.h"
-#include "freertos/FreeRTOS.h"
-#include "freertos/task.h"
-#include "freertos/semphr.h"
+#include "usb.h"
 #include "hcd.h"
 
 // ----------------------------------------------------- Macros --------------------------------------------------------
@@ -665,7 +666,7 @@ static hcd_pipe_event_t _intr_hdlr_chan(pipe_t *pipe, usbh_hal_chan_t *chan_obj,
         }
         case USBH_HAL_CHAN_EVENT_SLOT_HALT: {
             //A transfer descriptor list has partially completed. This currently only happens on control pipes
-            assert(pipe->ep_char.type == USB_XFER_TYPE_CTRL);
+            assert(pipe->ep_char.type == USB_HAL_XFER_TYPE_CTRL);
             _xfer_req_continue(pipe);    //Continue the transfer request.
             //We are continuing a transfer, so no event has occurred
             break;
@@ -1200,7 +1201,12 @@ esp_err_t hcd_port_get_speed(hcd_port_handle_t port_hdl, usb_speed_t *speed)
     HCD_ENTER_CRITICAL();
     //Device speed is only valid if there is a resetted device connected to the port
     HCD_CHECK_FROM_CRIT(port->flags.conn_devc_ena, ESP_ERR_INVALID_STATE);
-    *speed = usbh_hal_port_get_conn_speed(port->hal);
+    usb_hal_speed_t hal_speed = usbh_hal_port_get_conn_speed(port->hal);
+    if (hal_speed == USB_HAL_SPEED_FULL) {
+        *speed = USB_SPEED_FULL;
+    } else {
+        *speed = USB_SPEED_LOW;
+    }
     HCD_EXIT_CRITICAL();
     return ESP_OK;
 }
@@ -1387,7 +1393,7 @@ esp_err_t hcd_pipe_alloc(hcd_port_handle_t port_hdl, const hcd_pipe_config_t *pi
 
     esp_err_t ret = ESP_OK;
     //Get the type of pipe to allocate
-    usb_xfer_type_t type;
+    usb_transfer_type_t type;
     bool is_default_pipe;
     if (pipe_config->ep_desc == NULL) {  //A NULL ep_desc indicates we are allocating a default pipe
         type = USB_XFER_TYPE_CTRL;
@@ -1431,7 +1437,22 @@ esp_err_t hcd_pipe_alloc(hcd_port_handle_t port_hdl, const hcd_pipe_config_t *pi
     pipe->xfer_desc_list = xfer_desc_list;
     pipe->flags.xfer_desc_list_len = num_xfer_desc;
     pipe->chan_obj = chan_obj;
-    pipe->ep_char.type = type;
+    usb_hal_xfer_type_t hal_type;
+    switch (type) {
+        case USB_XFER_TYPE_CTRL:
+            hal_type = USB_HAL_XFER_TYPE_CTRL;
+            break;
+        case USB_XFER_TYPE_ISOCHRONOUS:
+            hal_type = USB_HAL_XFER_TYPE_ISOCHRONOUS;
+            break;
+        case USB_XFER_TYPE_BULK:
+            hal_type = USB_HAL_XFER_TYPE_ISOCHRONOUS;
+            break;
+        default:    //USB_XFER_TYPE_INTR
+            hal_type = USB_HAL_XFER_TYPE_INTR;
+            break;
+    }
+    pipe->ep_char.type = hal_type;
     if (is_default_pipe) {
         pipe->ep_char.bEndpointAddress = 0;
         //Set the default pipe's MPS to the worst case MPS for the device's speed
diff --git a/components/usb/private_include/hcd.h b/components/usb/private_include/hcd.h
index 50b75e245..3ad143de3 100644
--- a/components/usb/private_include/hcd.h
+++ b/components/usb/private_include/hcd.h
@@ -21,9 +21,8 @@ extern "C" {
 #include <stdint.h>
 #include <stdbool.h>
 #include <sys/queue.h>
-#include "hal/usb_types.h"
-#include "hal/usbh_hal.h"
 #include "esp_err.h"
+#include "usb.h"
 
 // ------------------------------------------------- Macros & Types ----------------------------------------------------
 
diff --git a/components/usb/private_include/usb.h b/components/usb/private_include/usb.h
new file mode 100644
index 000000000..79ad39547
--- /dev/null
+++ b/components/usb/private_include/usb.h
@@ -0,0 +1,444 @@
+// Copyright 2015-2020 Espressif Systems (Shanghai) PTE LTD
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*
+Note: This header file contains the types and macros pertaining to the USB2.0 protocol and are HW implementation
+agnostic. In other words, this header is only meant to be used in the HCD layer and above of the USB Host stack. For
+types and macros that are HW implementation specific (i.e., HAL layer and below), add them to the "usb_types.h" header
+instead.
+*/
+
+#pragma once
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include <stdint.h>
+
+#define USB_CTRL_REQ_ATTR       __attribute__((packed))
+#define USB_DESC_ATTR           __attribute__((packed))
+
+// ------------------------------------------------ Common USB Types ---------------------------------------------------
+
+// --------------------- Bus Related -----------------------
+
+/**
+ * @brief USB Standard Speeds
+ */
+typedef enum {
+    USB_SPEED_LOW = 0,                  /**< USB Low Speed (1.5 Mbit/s) */
+    USB_SPEED_FULL,                     /**< USB Full Speed (12 Mbit/s) */
+} usb_speed_t;
+
+// ------------------ Transfer Related ---------------------
+
+/**
+ * @brief The type of USB transfer
+ *
+ * @note The enum values need to match the bmAttributes field of an EP descriptor
+ */
+typedef enum {
+    USB_XFER_TYPE_CTRL = 0,
+    USB_XFER_TYPE_ISOCHRONOUS,
+    USB_XFER_TYPE_BULK,
+    USB_XFER_TYPE_INTR,
+} usb_transfer_type_t;
+
+/**
+ * @brief The status of a particular transfer
+ */
+typedef enum {
+    USB_TRANSFER_STATUS_COMPLETED,      /**< The transfer was successful (but may be short) */
+    USB_TRANSFER_STATUS_ERROR,          /**< The transfer failed because due to excessive errors (e.g. no response or CRC error) */
+    USB_TRANSFER_STATUS_TIMED_OUT,      /**< The transfer failed due to to a time out */
+    USB_TRANSFER_STATUS_CANCELLED,      /**< The transfer was cancelled */
+    USB_TRANSFER_STATUS_STALL,          /**< The transfer was stalled */
+    USB_TRANSFER_STATUS_NO_DEVICE,      /**< The transfer failed because the device is no longer valid (e.g., disconencted */
+    USB_TRANSFER_STATUS_OVERFLOW,       /**< The transfer as more data was sent than was requested */
+} usb_transfer_status_t;
+
+/**
+ * @brief Isochronous packet descriptor
+ *
+ * If the number of bytes in an IRP transfer is larger than the MPS of the
+ * endpoint, the IRP is split over multiple packets (one packet per bInterval
+ * of the endpoint). An array of Isochronous packet descriptos describes how
+ * an IRP should be split over multiple packets.
+ */
+typedef struct {
+    int length;                         /**< Number of bytes to transmit/receive in the packet */
+    int actual_length;                  /**< Actual number of bytes transmitted/received in the packet */
+    usb_transfer_status_t status;       /**< Status of the packet */
+} usb_iso_packet_desc_t;
+
+/**
+ * @brief USB IRP (I/O Request Packet). See USB2.0 Spec
+ *
+ * An identifiable request by a software client to move data between itself (on the
+ * host) and an endpoint of a device in an appropriate direction.
+ *
+ * This structure represents the barebones of the request. Different layers of
+ * USB drivers will wrap their own objects around this.
+ *
+ * See 10.5.3.1 os USB2.0 specification
+ * Bulk: Represnts a single bulk transfer which a pipe will transparently split
+ *       into multiple MPS transactions (until the last)
+ * Control: Represents a single contorl transfer with the setup packet at the
+ *          first 8 bytes of the buffer.
+ * Interrupt: Represnts a single interrupt transaction
+ * Isochronous: Represnts a buffer of a stream of bytes which the pipe will transparently
+ *              transfer the stream of bytes one or more service periods
+ */
+typedef struct {
+    int num_bytes;                      /**< Number of bytes in IRP. Control should exclude size of setup. IN should be integer multiple of MPS */
+    int actual_num_bytes;               /**< Actual number of bytes transmitted/receives in the IRP */
+    uint8_t *data_buffer;               /**< Pointer to data buffer. Must be DMA capable memory */
+    usb_transfer_status_t status;       /**< Status of the transfer */
+    int num_iso_packets;                /**< Only relevant to isochronous. Number of service periods to transfer data buffer over. Set to 0 for non-iso transfers */
+    usb_iso_packet_desc_t iso_packet_desc[0];   /**< Descriptors for each ISO packet */
+} usb_irp_t;
+
+// ---------------------------------------------------- Chapter 9 ------------------------------------------------------
+
+// ------------------- Control Request ---------------------
+
+/**
+ * @brief Size of a USB control transfer setup packet in bytes
+ */
+#define USB_CTRL_REQ_SIZE       8
+
+/**
+ * @brief Structure representing a USB control transfer setup packet
+ */
+typedef union {
+    struct {
+        uint8_t bRequestType;
+        uint8_t bRequest;
+        uint16_t wValue;
+        uint16_t wIndex;
+        uint16_t wLength;
+    } USB_CTRL_REQ_ATTR;
+    uint8_t val[USB_CTRL_REQ_SIZE];
+} usb_ctrl_req_t;
+_Static_assert(sizeof(usb_ctrl_req_t) == USB_CTRL_REQ_SIZE, "Size of usb_ctrl_req_t incorrect");
+
+/**
+ * @brief Bit masks pertaining to the bRequestType field of a setup packet
+ */
+#define USB_B_REQUEST_TYPE_DIR_OUT          (0X00 << 7)
+#define USB_B_REQUEST_TYPE_DIR_IN           (0x01 << 7)
+#define USB_B_REQUEST_TYPE_TYPE_STANDARD    (0x00 << 5)
+#define USB_B_REQUEST_TYPE_TYPE_CLASS       (0x01 << 5)
+#define USB_B_REQUEST_TYPE_TYPE_VENDOR      (0x02 << 5)
+#define USB_B_REQUEST_TYPE_TYPE_RESERVED    (0x03 << 5)
+#define USB_B_REQUEST_TYPE_TYPE_MASK        (0x03 << 5)
+#define USB_B_REQUEST_TYPE_RECIP_DEVICE     (0x00 << 0)
+#define USB_B_REQUEST_TYPE_RECIP_INTERFACE  (0x01 << 0)
+#define USB_B_REQUEST_TYPE_RECIP_ENDPOINT   (0x02 << 0)
+#define USB_B_REQUEST_TYPE_RECIP_OTHER      (0x03 << 0)
+#define USB_B_REQUEST_TYPE_RECIP_MASK       (0x1f << 0)
+
+/**
+ * @brief Bit masks pertaining to the bRequest field of a setup packet
+ */
+#define USB_B_REQUEST_GET_STATUS            0x00
+#define USB_B_REQUEST_CLEAR_FEATURE         0x01
+#define USB_B_REQUEST_SET_FEATURE           0x03
+#define USB_B_REQUEST_SET_ADDRESS           0x05
+#define USB_B_REQUEST_GET_DESCRIPTOR        0x06
+#define USB_B_REQUEST_SET_DESCRIPTOR        0x07
+#define USB_B_REQUEST_GET_CONFIGURATION     0x08
+#define USB_B_REQUEST_SET_CONFIGURATION     0x09
+#define USB_B_REQUEST_GET_INTERFACE         0x0A
+#define USB_B_REQUEST_SET_INTERFACE         0x0B
+#define USB_B_REQUEST_SYNCH_FRAME           0x0C
+
+/**
+ * @brief Bit masks pertaining to the wValue field of a setup packet
+ */
+#define USB_W_VALUE_DT_DEVICE               0x01
+#define USB_W_VALUE_DT_CONFIG               0x02
+#define USB_W_VALUE_DT_STRING               0x03
+#define USB_W_VALUE_DT_INTERFACE            0x04
+#define USB_W_VALUE_DT_ENDPOINT             0x05
+#define USB_W_VALUE_DT_DEVICE_QUALIFIER     0x06
+#define USB_W_VALUE_DT_OTHER_SPEED_CONFIG   0x07
+#define USB_W_VALUE_DT_INTERFACE_POWER      0x08
+
+/**
+ * @brief Initializer for a SET_ADDRESS request
+ *
+ * Sets the address of a connected device
+ */
+#define USB_CTRL_REQ_INIT_SET_ADDR(ctrl_req_ptr, addr) ({  \
+    (ctrl_req_ptr)->bRequestType = USB_B_REQUEST_TYPE_DIR_OUT | USB_B_REQUEST_TYPE_TYPE_STANDARD |USB_B_REQUEST_TYPE_RECIP_DEVICE;   \
+    (ctrl_req_ptr)->bRequest = USB_B_REQUEST_SET_ADDRESS;  \
+    (ctrl_req_ptr)->wValue = (addr);   \
+    (ctrl_req_ptr)->wIndex = 0;    \
+    (ctrl_req_ptr)->wLength = 0;   \
+})
+
+/**
+ * @brief Initializer for a request to get a device's device descriptor
+ */
+#define USB_CTRL_REQ_INIT_GET_DEVC_DESC(ctrl_req_ptr) ({ \
+    (ctrl_req_ptr)->bRequestType = USB_B_REQUEST_TYPE_DIR_IN | USB_B_REQUEST_TYPE_TYPE_STANDARD | USB_B_REQUEST_TYPE_RECIP_DEVICE;   \
+    (ctrl_req_ptr)->bRequest = USB_B_REQUEST_GET_DESCRIPTOR;   \
+    (ctrl_req_ptr)->wValue = (USB_W_VALUE_DT_DEVICE << 8); \
+    (ctrl_req_ptr)->wIndex = 0;    \
+    (ctrl_req_ptr)->wLength = 18;  \
+})
+
+/**
+ * @brief Initializer for a request to get a device's current configuration number
+ */
+#define USB_CTRL_REQ_INIT_GET_CONFIG(ctrl_req_ptr) ({  \
+    (ctrl_req_ptr)->bRequestType = USB_B_REQUEST_TYPE_DIR_IN | USB_B_REQUEST_TYPE_TYPE_STANDARD | USB_B_REQUEST_TYPE_RECIP_DEVICE;   \
+    (ctrl_req_ptr)->bRequest = USB_B_REQUEST_GET_CONFIGURATION;    \
+    (ctrl_req_ptr)->wValue = 0;    \
+    (ctrl_req_ptr)->wIndex = 0;    \
+    (ctrl_req_ptr)->wLength = 1;   \
+})
+
+/**
+ * @brief Initializer for a request to get one of the device's current configuration descriptor
+ *
+ * - desc_index indicates the configuration's index number
+ * - Number of bytes of the configuration descriptor to get
+ */
+#define USB_CTRL_REQ_INIT_GET_CFG_DESC(ctrl_req_ptr, desc_index, desc_len) ({  \
+    (ctrl_req_ptr)->bRequestType = USB_B_REQUEST_TYPE_DIR_IN | USB_B_REQUEST_TYPE_TYPE_STANDARD | USB_B_REQUEST_TYPE_RECIP_DEVICE;   \
+    (ctrl_req_ptr)->bRequest = USB_B_REQUEST_GET_DESCRIPTOR;   \
+    (ctrl_req_ptr)->wValue = (USB_W_VALUE_DT_CONFIG << 8) | ((desc_index) & 0xFF); \
+    (ctrl_req_ptr)->wIndex = 0;    \
+    (ctrl_req_ptr)->wLength = (desc_len);  \
+})
+
+/**
+ * @brief Initializer for a request to set a device's current configuration number
+ */
+#define USB_CTRL_REQ_INIT_SET_CONFIG(ctrl_req_ptr, config_num) ({  \
+    (ctrl_req_ptr)->bRequestType = USB_B_REQUEST_TYPE_DIR_OUT | USB_B_REQUEST_TYPE_TYPE_STANDARD | USB_B_REQUEST_TYPE_RECIP_DEVICE;   \
+    (ctrl_req_ptr)->bRequest = USB_B_REQUEST_SET_CONFIGURATION;    \
+    (ctrl_req_ptr)->wValue = (config_num); \
+    (ctrl_req_ptr)->wIndex = 0;    \
+    (ctrl_req_ptr)->wLength = 0;   \
+})
+
+// ------------------ Device Descriptor --------------------
+
+/**
+ * @brief Size of a USB device descriptor in bytes
+ */
+#define USB_DESC_DEV_SIZE       18
+
+/**
+ * @brief Structure representing a USB device descriptor
+ */
+typedef union {
+    struct {
+        uint8_t bLength;
+        uint8_t bDescriptorType;
+        uint16_t bcdUSB;
+        uint8_t bDeviceClass;
+        uint8_t bDeviceSubClass;
+        uint8_t bDeviceProtocol;
+        uint8_t bMaxPacketSize0;
+        uint16_t idVendor;
+        uint16_t idProduct;
+        uint16_t bcdDevice;
+        uint8_t iManufacturer;
+        uint8_t iProduct;
+        uint8_t iSerialNumber;
+        uint8_t bNumConfigurations;
+    } USB_DESC_ATTR;
+    uint8_t val[USB_DESC_DEV_SIZE];
+} usb_desc_devc_t;
+_Static_assert(sizeof(usb_desc_devc_t) == USB_DESC_DEV_SIZE, "Size of usb_desc_devc_t incorrect");
+
+/**
+ * @brief Possible base class values of the bDeviceClass field of a USB device descriptor
+ */
+#define USB_CLASS_PER_INTERFACE             0x00
+#define USB_CLASS_AUDIO                     0x01
+#define USB_CLASS_COMM                      0x02
+#define USB_CLASS_HID                       0x03
+#define USB_CLASS_PHYSICAL                  0x05
+#define USB_CLASS_STILL_IMAGE               0x06
+#define USB_CLASS_PRINTER                   0x07
+#define USB_CLASS_MASS_STORAGE              0x08
+#define USB_CLASS_HUB                       0x09
+#define USB_CLASS_CDC_DATA                  0x0a
+#define USB_CLASS_CSCID                     0x0b
+#define USB_CLASS_CONTENT_SEC               0x0d
+#define USB_CLASS_VIDEO                     0x0e
+#define USB_CLASS_WIRELESS_CONTROLLER       0xe0
+#define USB_CLASS_PERSONAL_HEALTHCARE       0x0f
+#define USB_CLASS_AUDIO_VIDEO               0x10
+#define USB_CLASS_BILLBOARD                 0x11
+#define USB_CLASS_USB_TYPE_C_BRIDGE         0x12
+#define USB_CLASS_MISC                      0xef
+#define USB_CLASS_APP_SPEC                  0xfe
+#define USB_CLASS_VENDOR_SPEC               0xff
+
+/**
+ * @brief Vendor specific subclass code
+ */
+#define USB_SUBCLASS_VENDOR_SPEC            0xff
+
+// -------------- Configuration Descriptor -----------------
+
+/**
+ * @brief Size of a short USB configuration descriptor in bytes
+ *
+ * @note The size of a full USB configuration includes all the interface and endpoint
+ *       descriptors of that configuration.
+ */
+#define USB_DESC_CFG_SIZE       9
+
+/**
+ * @brief Structure representing a short USB configuration descriptor
+ *
+ * @note The full USB configuration includes all the interface and endpoint
+ *       descriptors of that configuration.
+ */
+typedef union {
+    struct {
+        uint8_t bLength;
+        uint8_t bDescriptorType;
+        uint16_t wTotalLength;
+        uint8_t bNumInterfaces;
+        uint8_t bConfigurationValue;
+        uint8_t iConfiguration;
+        uint8_t bmAttributes;
+        uint8_t bMaxPower;
+    } USB_DESC_ATTR;
+    uint8_t val[USB_DESC_CFG_SIZE];
+} usb_desc_cfg_t;
+_Static_assert(sizeof(usb_desc_cfg_t) == USB_DESC_CFG_SIZE, "Size of usb_desc_cfg_t incorrect");
+
+/**
+ * @brief Bit masks pertaining to the bmAttributes field of a configuration descriptor
+ */
+#define USB_BM_ATTRIBUTES_ONE               (1 << 7)    //Must be set
+#define USB_BM_ATTRIBUTES_SELFPOWER         (1 << 6)    //Self powered
+#define USB_BM_ATTRIBUTES_WAKEUP            (1 << 5)    //Can wakeup
+#define USB_BM_ATTRIBUTES_BATTERY           (1 << 4)    //Battery powered
+
+// ---------------- Interface Descriptor -------------------
+
+/**
+ * @brief Size of a USB interface descriptor in bytes
+ */
+#define USB_DESC_INTF_SIZE      9
+
+/**
+ * @brief Structure representing a USB interface descriptor
+ */
+typedef union {
+    struct {
+        uint8_t bLength;
+        uint8_t bDescriptorType;
+        uint8_t bInterfaceNumber;
+        uint8_t bAlternateSetting;
+        uint8_t bNumEndpoints;
+        uint8_t bInterfaceClass;
+        uint8_t bInterfaceSubClass;
+        uint8_t bInterfaceProtocol;
+        uint8_t iInterface;
+    } USB_DESC_ATTR;
+    uint8_t val[USB_DESC_INTF_SIZE];
+} usb_desc_intf_t;
+_Static_assert(sizeof(usb_desc_intf_t) == USB_DESC_INTF_SIZE, "Size of usb_desc_intf_t incorrect");
+
+// ----------------- Endpoint Descriptor -------------------
+
+/**
+ * @brief Size of a USB endpoint descriptor in bytes
+ */
+#define USB_DESC_EP_SIZE        7
+
+/**
+ * @brief Structure representing a USB endp;oint descriptor
+ */
+typedef union {
+    struct {
+        uint8_t bLength;
+        uint8_t bDescriptorType;
+        uint8_t bEndpointAddress;
+        uint8_t bmAttributes;
+        uint16_t wMaxPacketSize;
+        uint8_t bInterval;
+    } USB_DESC_ATTR;
+    uint8_t val[USB_DESC_EP_SIZE];
+} usb_desc_ep_t;
+_Static_assert(sizeof(usb_desc_ep_t) == USB_DESC_EP_SIZE, "Size of usb_desc_ep_t incorrect");
+
+/**
+ * @brief Bit masks pertaining to the bEndpointAddress field of an endpoint descriptor
+ */
+#define USB_B_ENDPOINT_ADDRESS_EP_NUM_MASK              0x0f
+#define USB_B_ENDPOINT_ADDRESS_EP_DIR_MASK              0x80
+
+/**
+ * @brief Bit masks pertaining to the bmAttributes field of an endpoint descriptor
+ */
+#define USB_BM_ATTRIBUTES_XFERTYPE_MASK                 0x03
+#define USB_BM_ATTRIBUTES_XFER_CONTROL                  (0 << 0)
+#define USB_BM_ATTRIBUTES_XFER_ISOC                     (1 << 0)
+#define USB_BM_ATTRIBUTES_XFER_BULK                     (2 << 0)
+#define USB_BM_ATTRIBUTES_XFER_INT                      (3 << 0)
+#define USB_BM_ATTRIBUTES_SYNCTYPE_MASK                 0x0C    /* in bmAttributes */
+#define USB_BM_ATTRIBUTES_SYNC_NONE                     (0 << 2)
+#define USB_BM_ATTRIBUTES_SYNC_ASYNC                    (1 << 2)
+#define USB_BM_ATTRIBUTES_SYNC_ADAPTIVE                 (2 << 2)
+#define USB_BM_ATTRIBUTES_SYNC_SYNC                     (3 << 2)
+#define USB_BM_ATTRIBUTES_USAGETYPE_MASK                0x30
+#define USB_BM_ATTRIBUTES_USAGE_DATA                    (0 << 4)
+#define USB_BM_ATTRIBUTES_USAGE_FEEDBACK                (1 << 4)
+#define USB_BM_ATTRIBUTES_USAGE_IMPLICIT_FB             (2 << 4)
+
+/**
+ * @brief Macro helpers to get information about an endpoint from its descriptor
+ */
+#define USB_DESC_EP_GET_XFERTYPE(desc_ptr) ((usb_transfer_type_t) ((desc_ptr)->bmAttributes & USB_BM_ATTRIBUTES_XFERTYPE_MASK))
+#define USB_DESC_EP_GET_EP_NUM(desc_ptr) ((desc_ptr)->bEndpointAddress & USB_B_ENDPOINT_ADDRESS_EP_NUM_MASK)
+#define USB_DESC_EP_GET_EP_DIR(desc_ptr) (((desc_ptr)->bEndpointAddress & USB_B_ENDPOINT_ADDRESS_EP_DIR_MASK) ? 1 : 0)
+#define USB_DESC_EP_GET_MPS(desc_ptr) ((desc_ptr)->wMaxPacketSize & 0x7FF)
+
+// ------------------ String Descriptor --------------------
+
+/**
+ * @brief Size of a short USB string descriptor in bytes
+ */
+#define USB_DESC_STR_SIZE       4
+
+/**
+ * @brief Structure representing a USB string descriptor
+ */
+typedef union {
+    struct {
+        uint8_t bLength;
+        uint8_t bDescriptorType;
+        uint16_t wData[1];        /* UTF-16LE encoded */
+    } USB_DESC_ATTR;
+    uint8_t val[USB_DESC_STR_SIZE];
+} usb_desc_str_t;
+_Static_assert(sizeof(usb_desc_str_t) == USB_DESC_STR_SIZE, "Size of usb_desc_str_t incorrect");
+
+#ifdef __cplusplus
+}
+#endif
-- 
2.25.1


From cf95a8e6b2315cf8aa559acdaf9cbe38f96b1e64 Mon Sep 17 00:00:00 2001
From: Darian Leung <darian@espressif.com>
Date: Sat, 6 Mar 2021 05:46:25 +0800
Subject: [PATCH 2/9] USB HCD uses IRPs directly for transfer

This commit updates the HCD so that transfer requests are no longer used.
The USB IRP object is updated so that the it can be directly passed to the HCD
to start a transfer. HCD API, tests, and documentation updated accordingly.

Signed-off-by: Li Bo <libo@espressif.com>
---
 components/usb/hcd.c                 | 493 ++++++++++++--------------
 components/usb/maintainers.md        |  13 +-
 components/usb/private_include/hcd.h | 126 ++-----
 components/usb/private_include/usb.h |  46 ++-
 components/usb/test/test_hcd.c       | 500 ++++++++++++---------------
 5 files changed, 521 insertions(+), 657 deletions(-)

diff --git a/components/usb/hcd.c b/components/usb/hcd.c
index 2494a2aa9..02055c094 100644
--- a/components/usb/hcd.c
+++ b/components/usb/hcd.c
@@ -57,12 +57,22 @@
 
 #define NUM_PORTS                   1       //The controller only has one port.
 
-typedef enum {
-    XFER_REQ_STATE_IDLE,        //The transfer request is not enqueued
-    XFER_REQ_STATE_PENDING,     //The transfer request is enqueued and pending execution
-    XFER_REQ_STATE_INFLIGHT,    //The transfer request is currently being executed
-    XFER_REQ_STATE_DONE,        //The transfer request has completed executed or is retired, and is waiting to be dequeued
-} xfer_req_state_t;
+// ------------------------ Flags --------------------------
+
+/**
+ * @brief Bit masks for the HCD to use in the IRPs reserved_flags field
+ *
+ * The IRP object has a reserved_flags member for host stack's internal use. The following flags will be set in
+ * reserved_flags in order to keep track of state of an IRP within the HCD.
+ */
+#define IRP_STATE_IDLE         0x0     //The IRP is not enqueued in an HCD pipe
+#define IRP_STATE_PENDING      0x1     //The IRP is enqueued and pending execution
+#define IRP_STATE_INFLIGHT     0x2     //The IRP is currently in flight
+#define IRP_STATE_DONE         0x3     //The IRP has completed execution or is retired, and is waiting to be dequeued
+#define IRP_STATE_MASK         0x3     //Bit mask of all the IRP state flagse
+#define IRP_STATE_SET(reserved_flags, state)    (reserved_flags = (reserved_flags & ~IRP_STATE_MASK) | state)
+#define IRP_STATE_GET(reserved_flags)           (reserved_flags & IRP_STATE_MASK)
+
 
 // -------------------- Convenience ------------------------
 
@@ -85,31 +95,19 @@ typedef enum {
 
 // ------------------------------------------------------ Types --------------------------------------------------------
 
-typedef struct xfer_req_obj xfer_req_t;
 typedef struct pipe_obj pipe_t;
 typedef struct port_obj port_t;
 
-/**
- * @brief Object representing an HCD transfer request
- */
-struct xfer_req_obj {
-    TAILQ_ENTRY(xfer_req_obj) tailq_entry;  //TailQ entry for pending or done tailq in pipe object
-    pipe_t *pipe;   //Target pipe of transfer request
-    usb_irp_t *irp; //Target IRP
-    void *context;  //Context variable of transfer request
-    xfer_req_state_t state; //Current state of the transfer request
-};
-
 /**
  * @brief Object representing a pipe in the HCD layer
  */
 struct pipe_obj {
-    //Transfer requests related
-    TAILQ_HEAD(tailhead_xfer_req_pend, xfer_req_obj) pend_xfer_req_tailq;
-    TAILQ_HEAD(tailhead_xfer_req_done, xfer_req_obj) done_xfer_req_tailq;
-    int num_xfer_req_pending;
-    int num_xfer_req_done;
-    xfer_req_t *inflight_xfer_req;  //Pointer to the current transfer request being executed by the pipe. NULL if none.
+    //IRP queueing related
+    TAILQ_HEAD(tailhead_irp_pending, usb_irp_obj) pending_irp_tailq;
+    TAILQ_HEAD(tailhead_irp_done, usb_irp_obj) done_irp_tailq;
+    int num_irp_pending;
+    int num_irp_done;
+    usb_irp_t *inflight_irp;  //Pointer to the inflight IRP (i.e., the IRP currently being executed). NULL if none.
     //Port related
     port_t *port;                       //The port to which this pipe is routed through
     TAILQ_ENTRY(pipe_obj) tailq_entry;  //TailQ entry for port's list of pipes
@@ -148,7 +146,7 @@ struct port_obj {
     usbh_hal_context_t *hal;
     //Pipes routed through this port
     TAILQ_HEAD(tailhead_pipes_idle, pipe_obj) pipes_idle_tailq;
-    TAILQ_HEAD(tailhead_pipes_queued, pipe_obj) pipes_queued_tailq;
+    TAILQ_HEAD(tailhead_pipes_queued, pipe_obj) pipes_active_tailq;
     int num_pipes_idle;
     int num_pipes_queued;
     //Port status, state, and events
@@ -245,7 +243,7 @@ static bool _internal_pipe_event_notify(pipe_t *pipe, bool from_isr);
  * Entry:
  *  - The port or its connected device is no longer valid. This guarantees that none of the pipes will be transferring
  * Exit:
- *  - Each pipe will have any pending transfer request moved to their respective done tailq
+ *  - Each pipe will have any pending IRPs moved to their respective done tailq
  *  - Each pipe will be put into the invalid state
  *  - Generate a HCD_PIPE_EVENT_INVALID event on each pipe and run their respective callbacks
  *
@@ -261,8 +259,8 @@ static void _port_invalidate_all_pipes(port_t *port);
  * Entry:
  *  - The port is in the HCD_PORT_STATE_ENABLED state (i.e., there is a connected device which has been reset)
  * Exit:
- *  - All pipes of the port have either paused, or are waiting to complete their inflight transfer request to pause
- *  - If waiting for one or more pipes, _internal_port_event_wait() must be called after this function returns
+ *  - All pipes routed through the port have either paused, or are waiting to complete their inflight IRPs before pausing
+ *  - If waiting for one or more pipes to pause, _internal_port_event_wait() must be called after this function returns
  *
  * @param port Port object
  * @return true All pipes have been paused
@@ -279,7 +277,7 @@ static bool _port_pause_all_pipes(port_t *port);
  *  - The port is in the HCD_PORT_STATE_ENABLED state
  *  - All pipes are paused
  * Exit:
- *  - All pipes un-paused. If those pipes have pending transfer requests, they will be started.
+ *  - All pipes un-paused. If those pipes have pending IRPs, they will be started.
  *
  * @param port Port object
  */
@@ -368,66 +366,66 @@ static bool _port_debounce(port_t *port);
 // ------------------------ Pipe ---------------------------
 
 /**
- * @brief Get the next pending transfer request from the pending tailq
+ * @brief Get the next pending IRP from the pending tailq
  *
  * Entry:
- * - The inflight transfer request must be set to NULL (indicating the pipe currently has no inflight transfer request)
+ * - The inflight IRP must be set to NULL (indicating the pipe currently has no inflight IRP)
  * Exit:
- * - If (num_xfer_req_pending > 0), the first transfer request is removed from pend_xfer_req_tailq and and
- *   inflight_xfer_req is set to that transfer request.
- * - If there are no more queued transfer requests, inflight_xfer_req is left as NULL
+ * - If (num_irp_pending > 0), the first IRP is removed from pending_irp_tailq and and
+ *   inflight_irp is set to that IRP.
+ * - If there are no more queued IRPs, inflight_irp is left as NULL
  *
  * @param pipe Pipe object
- * @return true A pending transfer request is now set as the inflight transfer request
- * @return false No more pending transfer requests
+ * @return true A pending IRP is now set as the inflight IRP
+ * @return false No more pending IRPs
  */
-static bool _pipe_get_next_xfer_req(pipe_t *pipe);
+static bool _pipe_get_next_irp(pipe_t *pipe);
 
 /**
- * @brief Return the inflight transfer request to the done tailq
+ * @brief Return the pipe's current IRP (inflight_irp) to the done tailq
  *
  * Entry:
- *  - The inflight transfer request must already have been parsed (i.e., results have been checked)
+ *  - The inflight_irp must already have been parsed (i.e., results have been checked)
  * Exit:
- * - The inflight transfer request is returned to the done tailq and inflight_xfer_req is set to NULL
+ * - The IRP is returned to the done tailq and inflight_irp is set to NULL
  *
  * @param pipe Pipe object
  */
-static void _pipe_ret_cur_xfer_req(pipe_t *pipe);
+static void _pipe_return_cur_irp(pipe_t *pipe);
 
 /**
- * @brief Wait until a pipe's inflight transfer request is done
+ * @brief Wait until a pipe's inflight IRP is done
  *
- * If the pipe has an inflight transfer request, this function will block until it is done (via a internal pipe event).
- * If the pipe has no inflight transfer request, this function do nothing and return immediately.
+ * If the pipe has an inflight IRP, this function will block until it is done (via a internal pipe event).
+ * If the pipe has no inflight IRP, this function do nothing and return immediately.
  * If the pipe's state changes unexpectedely, this function will return false.
  *
  * @note This function is blocking (will exit and re-enter the critical section to do so)
  *
  * @param pipe Pipe object
- * @return true Pipes inflight transfer request is done
+ * @return true Pipes inflight IRP is done
  * @return false Pipes state unexpectedly changed
  */
 static bool _pipe_wait_done(pipe_t *pipe);
 
 /**
- * @brief Retires all transfer requests (those that were previously inflight or pending)
+ * @brief Retires all IRPs (those that were previously inflight or pending)
  *
- * Retiring all transfer requests will result in any pending transfer request being moved to the done tailq. This
- * function will update the IPR status of each transfer request.
+ * Retiring all IRPs will result in any pending IRP being moved to the done tailq. This
+ * function will update the IPR status of each IRP.
  *  - If the retiring is self-initiated (i.e., due to a pipe command), the IRP status will be set to USB_TRANSFER_STATUS_CANCELLED.
  *  - If the retiring is NOT self-initiated (i.e., the pipe is no longer valid), the IRP status will be set to USB_TRANSFER_STATUS_NO_DEVICE
  *
  * Entry:
- * - There can be no inflight transfer request (must already be parsed and returned to done queue)
+ * - There can be no inflight IRP (must already be parsed and returned to done queue)
  * Exit:
- * - If there was an inflight transfer request, it is parsed and returned to the done queue
- * - If there are any pending transfer requests:
+ * - If there was an inflight IRP, it is parsed and returned to the done queue
+ * - If there are any pending IRPs:
  *      - They are moved to the done tailq
  *
  * @param pipe Pipe object
- * @param cancelled Are we actively Pipe retire is initialized by the user due to a command, thus transfer request are actively
- *                  cancelled
+ * @param cancelled Are we actively Pipe retire is initialized by the user due to a command, thus IRP are
+ *                  actively cancelled.
  */
 static void _pipe_retire(pipe_t *pipe, bool self_initiated);
 
@@ -439,45 +437,45 @@ static void _pipe_retire(pipe_t *pipe, bool self_initiated);
  */
 static inline hcd_pipe_event_t pipe_decode_error_event(usbh_hal_chan_error_t chan_error);
 
-// ------------------ Transfer Requests --------------------
+// ----------------- Transfer Descriptors ------------------
 
 /**
- * @brief Fill a transfer request into the pipe's transfer descriptor list
+ * @brief Fill the inflight_irp into the pipe's transfer descriptor list
  *
  * Entry:
- *  - The pipe's inflight_xfer_req must be set to the next transfer request
+ *  - The pipe's inflight_irp must be set to the next IRP
  * Exit:
- *  - inflight_xfer_req filled into the pipe's transfer descriptor list
+ *  - inflight_irp filled into the pipe's transfer descriptor list
  *  - Starting PIDs and directions set
  *  - Channel slot acquired. Will need to call usbh_hal_chan_activate() to actually start execution
  *
- * @param pipe Pipe where inflight_xfer_req is already set to the next transfer request
+ * @param pipe Pipe where inflight_irp is already set to the next IRP
  */
-static void _xfer_req_fill(pipe_t *pipe);
+static void _xfer_desc_list_fill(pipe_t *pipe);
 
 /**
- * @brief Continue a transfer request
+ * @brief Continue the execution of the transfer descriptor list
  *
  * @note This is currently only used for control transfers
  *
- * @param pipe Pipe where inflight_xfer_req contains the transfer request to continue
+ * @param pipe Pipe object
  */
-static void _xfer_req_continue(pipe_t *pipe);
+static void _xfer_desc_list_continue(pipe_t *pipe);
 
 /**
- * @brief Parse the results of a pipe's transfer descriptor list into a transfer request
+ * @brief Parse the pipe's transfer descriptor list to fill the result of the transfers into the pipe's IRP
  *
  * Entry:
  *  - The pipe must have stop transferring either due a channel event or a port disconnection.
- *  - The pipe's state and last_event must be updated before parsing the transfer request as
- *    they will used to determine the resuult of the transfer request
+ *  - The pipe's state and last_event must be updated before parsing the IRP as they will used to determine the result
+ *    of the IRP
  * Exit:
- *  - The pipe's inflight_xfer_req is filled with result of the transfer request (i.e., the underlying IRP has its status set)
+ *  - The pipe's inflight_irp is filled with result of the IRP (i.e., the underlying IRP has its status set)
  *
- * @param pipe Pipe where inflight_xfer_req contains the completed transfer request
+ * @param pipe Pipe object
  * @param error_occurred Are we parsing after the pipe had an error (or has become invalid)
  */
-static void _xfer_req_parse(pipe_t *pipe, bool error_occurred);
+static void _xfer_desc_list_parse(pipe_t *pipe, bool error_occurred);
 
 // ----------------------------------------------- Interrupt Handling --------------------------------------------------
 
@@ -637,10 +635,10 @@ static hcd_pipe_event_t _intr_hdlr_chan(pipe_t *pipe, usbh_hal_chan_t *chan_obj,
     switch (chan_event) {
         case USBH_HAL_CHAN_EVENT_SLOT_DONE: {
             //An entire transfer descriptor list has completed execution
-            pipe->last_event = HCD_PIPE_EVENT_XFER_REQ_DONE;
-            event = HCD_PIPE_EVENT_XFER_REQ_DONE;
-            _xfer_req_parse(pipe, false);    //Parse results of transfer request
-            _pipe_ret_cur_xfer_req(pipe);    //Return the transfer request to the pipe's done tailq
+            pipe->last_event = HCD_PIPE_EVENT_IRP_DONE;
+            event = HCD_PIPE_EVENT_IRP_DONE;
+            _xfer_desc_list_parse(pipe, false);    //Parse results of IRP
+            _pipe_return_cur_irp(pipe);    //Return the IRP to the pipe's done tailq
             if (pipe->flags.waiting_xfer_done) {
                 //A port/pipe command is waiting for this pipe to complete its transfer. So don't load the next transfer
                 pipe->flags.waiting_xfer_done = 0;
@@ -657,9 +655,9 @@ static hcd_pipe_event_t _intr_hdlr_chan(pipe_t *pipe, usbh_hal_chan_t *chan_obj,
                     //Pipe command is waiting for transfer to complete
                     *yield |= _internal_pipe_event_notify(pipe, true);
                 }
-            } else if (_pipe_get_next_xfer_req(pipe)) {
-                //Fill the descriptor list with the transfer request and start the transfer
-                _xfer_req_fill(pipe);
+            } else if (_pipe_get_next_irp(pipe)) {
+                //Fill the descriptor list with the IRP and start the transfer
+                _xfer_desc_list_fill(pipe);
                 usbh_hal_chan_activate(chan_obj, 0);  //Start with the first descriptor
             }
             break;
@@ -667,7 +665,7 @@ static hcd_pipe_event_t _intr_hdlr_chan(pipe_t *pipe, usbh_hal_chan_t *chan_obj,
         case USBH_HAL_CHAN_EVENT_SLOT_HALT: {
             //A transfer descriptor list has partially completed. This currently only happens on control pipes
             assert(pipe->ep_char.type == USB_HAL_XFER_TYPE_CTRL);
-            _xfer_req_continue(pipe);    //Continue the transfer request.
+            _xfer_desc_list_continue(pipe);    //Continue the IRP.
             //We are continuing a transfer, so no event has occurred
             break;
         }
@@ -678,9 +676,9 @@ static hcd_pipe_event_t _intr_hdlr_chan(pipe_t *pipe, usbh_hal_chan_t *chan_obj,
             pipe->last_event = pipe_decode_error_event(chan_error);
             event = pipe->last_event;
             pipe->state = HCD_PIPE_STATE_HALTED;
-            //Parse the failed transfer request and update it's IRP status
-            _xfer_req_parse(pipe, true);
-            _pipe_ret_cur_xfer_req(pipe);    //Return the transfer request to the pipe's done tailq
+            //Parse the failed IRP and update it's IRP status
+            _xfer_desc_list_parse(pipe, true);
+            _pipe_return_cur_irp(pipe);    //Return the IRP to the pipe's done tailq
             break;
         }
         case USBH_HAL_CHAN_EVENT_HALT_REQ:  //We currently don't halt request so this event should never occur
@@ -704,7 +702,7 @@ static hcd_pipe_event_t _intr_hdlr_chan(pipe_t *pipe, usbh_hal_chan_t *chan_obj,
  */
 static void intr_hdlr_main(void *arg)
 {
-    port_t *port = (port_t *)arg;
+    port_t *port = (port_t *) arg;
     bool yield = false;
 
     HCD_ENTER_CRITICAL_ISR();
@@ -864,17 +862,17 @@ static void _port_invalidate_all_pipes(port_t *port)
     //This function should only be called when the port is invalid
     assert(!port->flags.conn_devc_ena);
     pipe_t *pipe;
-    //Process all pipes that have queued transfer requests
-    TAILQ_FOREACH(pipe, &port->pipes_queued_tailq, tailq_entry) {
+    //Process all pipes that have queued IRPs
+    TAILQ_FOREACH(pipe, &port->pipes_active_tailq, tailq_entry) {
         //Mark the pipe as invalid and set an invalid event
         pipe->state = HCD_PIPE_STATE_INVALID;
         pipe->last_event = HCD_PIPE_EVENT_INVALID;
         //If the pipe had an inflight transfer, parse and return it
-        if (pipe->inflight_xfer_req != NULL) {
-            _xfer_req_parse(pipe, true);
-            _pipe_ret_cur_xfer_req(pipe);
+        if (pipe->inflight_irp != NULL) {
+            _xfer_desc_list_parse(pipe, true);
+            _pipe_return_cur_irp(pipe);
         }
-        //Retire any remaining transfer requests
+        //Retire any remaining IRPs
         _pipe_retire(pipe, false);
         if (pipe->task_waiting_pipe_notif != NULL) {
             //Unblock the thread/task waiting for a notification from the pipe as the pipe is no longer valid.
@@ -904,9 +902,9 @@ static bool _port_pause_all_pipes(port_t *port)
     assert(port->state == HCD_PORT_STATE_ENABLED);
     pipe_t *pipe;
     int num_pipes_waiting_done = 0;
-    //Process all pipes that have queued transfer requests
-    TAILQ_FOREACH(pipe, &port->pipes_queued_tailq, tailq_entry) {
-        if (pipe->inflight_xfer_req != NULL) {
+    //Process all pipes that have queued IRPs
+    TAILQ_FOREACH(pipe, &port->pipes_active_tailq, tailq_entry) {
+        if (pipe->inflight_irp != NULL) {
             //Pipe has an inflight transfer. Indicate to the pipe we are waiting the transfer to complete
             pipe->flags.waiting_xfer_done = 1;
             num_pipes_waiting_done++;
@@ -936,12 +934,12 @@ static void _port_unpause_all_pipes(port_t *port)
     TAILQ_FOREACH(pipe, &port->pipes_idle_tailq, tailq_entry) {
         pipe->flags.paused = 0;
     }
-    //Process all pipes that have queued transfer requests
-    TAILQ_FOREACH(pipe, &port->pipes_queued_tailq, tailq_entry) {
+    //Process all pipes that have queued IRPs
+    TAILQ_FOREACH(pipe, &port->pipes_active_tailq, tailq_entry) {
         pipe->flags.paused = 0;
-        //If the pipe has more pending transfer request, start them.
-        if (_pipe_get_next_xfer_req(pipe)) {
-            _xfer_req_fill(pipe);
+        //If the pipe has more pending IRP, start them.
+        if (_pipe_get_next_irp(pipe)) {
+            _xfer_desc_list_fill(pipe);
             usbh_hal_chan_activate(pipe->chan_obj, 0);
         }
     }
@@ -1084,7 +1082,7 @@ esp_err_t hcd_port_init(int port_number, hcd_port_config_t *port_config, hcd_por
     //Port object memory and resources (such as mutex) already be allocated. Just need to initialize necessary fields only
     port_t *port_obj = s_hcd_obj->port_obj;
     TAILQ_INIT(&port_obj->pipes_idle_tailq);
-    TAILQ_INIT(&port_obj->pipes_queued_tailq);
+    TAILQ_INIT(&port_obj->pipes_active_tailq);
     port_obj->state = HCD_PORT_STATE_NOT_POWERED;
     port_obj->last_event = HCD_PORT_EVENT_NONE;
     port_obj->callback = port_config->callback;
@@ -1291,17 +1289,18 @@ void *hcd_port_get_ctx(hcd_port_handle_t port_hdl)
 
 // ----------------------- Private -------------------------
 
-static bool _pipe_get_next_xfer_req(pipe_t *pipe)
+static bool _pipe_get_next_irp(pipe_t *pipe)
 {
-    assert(pipe->inflight_xfer_req == NULL);
+    assert(pipe->inflight_irp == NULL);
     bool ret;
-    //This function assigns the next pending transfer request to the inflight_xfer_req
-    if (pipe->num_xfer_req_pending > 0) {
-        //Set inflight_xfer_req to the next pending transfer request
-        pipe->inflight_xfer_req = TAILQ_FIRST(&pipe->pend_xfer_req_tailq);
-        TAILQ_REMOVE(&pipe->pend_xfer_req_tailq, pipe->inflight_xfer_req, tailq_entry);
-        pipe->inflight_xfer_req->state = XFER_REQ_STATE_INFLIGHT;
-        pipe->num_xfer_req_pending--;
+    //This function assigns the next pending IRP to the inflight_irp
+    if (pipe->num_irp_pending > 0) {
+        //Set inflight_irp to the next pending IRP
+        pipe->inflight_irp = TAILQ_FIRST(&pipe->pending_irp_tailq);
+        TAILQ_REMOVE(&pipe->pending_irp_tailq, pipe->inflight_irp, tailq_entry);
+        pipe->num_irp_pending--;
+        //Update the IRP's current state
+        IRP_STATE_SET(pipe->inflight_irp->reserved_flags, IRP_STATE_INFLIGHT);
         ret =  true;
     } else {
         ret = false;
@@ -1309,20 +1308,21 @@ static bool _pipe_get_next_xfer_req(pipe_t *pipe)
     return ret;
 }
 
-static void _pipe_ret_cur_xfer_req(pipe_t *pipe)
+static void _pipe_return_cur_irp(pipe_t *pipe)
 {
-    assert(pipe->inflight_xfer_req != NULL);
-    //Add the transfer request to the pipe's done tailq
-    TAILQ_INSERT_TAIL(&pipe->done_xfer_req_tailq, pipe->inflight_xfer_req, tailq_entry);
-    pipe->inflight_xfer_req->state = XFER_REQ_STATE_DONE;
-    pipe->inflight_xfer_req = NULL;
-    pipe->num_xfer_req_done++;
+    assert(pipe->inflight_irp != NULL);
+    //Add the IRP to the pipe's done tailq
+    TAILQ_INSERT_TAIL(&pipe->done_irp_tailq, pipe->inflight_irp, tailq_entry);
+    //Update the IRP's current state
+    IRP_STATE_SET(pipe->inflight_irp->reserved_flags, IRP_STATE_DONE);
+    pipe->inflight_irp = NULL;
+    pipe->num_irp_done++;
 }
 
 static bool _pipe_wait_done(pipe_t *pipe)
 {
-    //Check if there is a currently inflight transfer request
-    if (pipe->inflight_xfer_req != NULL) {
+    //Check if there is a currently inflight IRP
+    if (pipe->inflight_irp != NULL) {
         //Wait for pipe to complete its transfer
         pipe->flags.waiting_xfer_done = 1;
         _internal_pipe_event_wait(pipe);
@@ -1340,20 +1340,21 @@ static bool _pipe_wait_done(pipe_t *pipe)
 
 static void _pipe_retire(pipe_t *pipe, bool self_initiated)
 {
-    //Cannot have any inflight transfer request
-    assert(pipe->inflight_xfer_req == NULL);
-    if (pipe->num_xfer_req_pending > 0) {
-        //Process all remaining pending transfer requests
-        xfer_req_t *xfer_req;
-        TAILQ_FOREACH(xfer_req, &pipe->pend_xfer_req_tailq, tailq_entry) {
-            xfer_req->state = XFER_REQ_STATE_DONE;
-            //If we are initiating the retire, mark the transfer request as cancelled
-            xfer_req->irp->status = (self_initiated) ? USB_TRANSFER_STATUS_CANCELLED : USB_TRANSFER_STATUS_NO_DEVICE;
+    //Cannot have any inflight IRP
+    assert(pipe->inflight_irp == NULL);
+    if (pipe->num_irp_pending > 0) {
+        //Process all remaining pending IRPs
+        usb_irp_t *irp;
+        TAILQ_FOREACH(irp, &pipe->pending_irp_tailq, tailq_entry) {
+            //Update the IRP's current state
+            IRP_STATE_SET(irp->reserved_flags, IRP_STATE_DONE);
+            //If we are initiating the retire, mark the IRP as cancelled
+            irp->status = (self_initiated) ? USB_TRANSFER_STATUS_CANCELLED : USB_TRANSFER_STATUS_NO_DEVICE;
         }
         //Concatenated pending tailq to the done tailq
-        TAILQ_CONCAT(&pipe->done_xfer_req_tailq, &pipe->pend_xfer_req_tailq, tailq_entry);
-        pipe->num_xfer_req_done += pipe->num_xfer_req_pending;
-        pipe->num_xfer_req_pending = 0;
+        TAILQ_CONCAT(&pipe->done_irp_tailq, &pipe->pending_irp_tailq, tailq_entry);
+        pipe->num_irp_done += pipe->num_irp_pending;
+        pipe->num_irp_pending = 0;
     }
 }
 
@@ -1365,7 +1366,7 @@ static inline hcd_pipe_event_t pipe_decode_error_event(usbh_hal_chan_error_t cha
             event = HCD_PIPE_EVENT_ERROR_XFER;
             break;
         case USBH_HAL_CHAN_ERROR_BNA:
-            event = HCD_PIPE_EVENT_ERROR_XFER_NOT_AVAIL;
+            event = HCD_PIPE_EVENT_ERROR_IRP_NOT_AVAIL;
             break;
         case USBH_HAL_CHAN_ERROR_PKT_BBL:
             event = HCD_PIPE_EVENT_ERROR_OVERFLOW;
@@ -1431,28 +1432,14 @@ esp_err_t hcd_pipe_alloc(hcd_port_handle_t port_hdl, const hcd_pipe_config_t *pi
     }
 
     //Initialize pipe object
-    TAILQ_INIT(&pipe->pend_xfer_req_tailq);
-    TAILQ_INIT(&pipe->done_xfer_req_tailq);
+    TAILQ_INIT(&pipe->pending_irp_tailq);
+    TAILQ_INIT(&pipe->done_irp_tailq);
     pipe->port = port;
     pipe->xfer_desc_list = xfer_desc_list;
     pipe->flags.xfer_desc_list_len = num_xfer_desc;
     pipe->chan_obj = chan_obj;
-    usb_hal_xfer_type_t hal_type;
-    switch (type) {
-        case USB_XFER_TYPE_CTRL:
-            hal_type = USB_HAL_XFER_TYPE_CTRL;
-            break;
-        case USB_XFER_TYPE_ISOCHRONOUS:
-            hal_type = USB_HAL_XFER_TYPE_ISOCHRONOUS;
-            break;
-        case USB_XFER_TYPE_BULK:
-            hal_type = USB_HAL_XFER_TYPE_ISOCHRONOUS;
-            break;
-        default:    //USB_XFER_TYPE_INTR
-            hal_type = USB_HAL_XFER_TYPE_INTR;
-            break;
-    }
-    pipe->ep_char.type = hal_type;
+    //The HAL transfer type is the same as the USB transfer type so we just cast it
+    pipe->ep_char.type = (usb_hal_xfer_type_t)type;
     if (is_default_pipe) {
         pipe->ep_char.bEndpointAddress = 0;
         //Set the default pipe's MPS to the worst case MPS for the device's speed
@@ -1501,12 +1488,12 @@ esp_err_t hcd_pipe_free(hcd_pipe_handle_t pipe_hdl)
 {
     pipe_t *pipe = (pipe_t *)pipe_hdl;
     HCD_ENTER_CRITICAL();
-    //Check that all transfer requests have been removed and pipe has no pending events
-    HCD_CHECK_FROM_CRIT(pipe->inflight_xfer_req == NULL
-                        && pipe->num_xfer_req_pending == 0
-                        && pipe->num_xfer_req_done == 0,
+    //Check that all IRPs have been removed and pipe has no pending events
+    HCD_CHECK_FROM_CRIT(pipe->inflight_irp == NULL
+                        && pipe->num_irp_pending == 0
+                        && pipe->num_irp_done == 0,
                         ESP_ERR_INVALID_STATE);
-    //Remove pipe from the list of idle pipes (it must be in the idle list because it should have no queued transfer requests)
+    //Remove pipe from the list of idle pipes (it must be in the idle list because it should have no queued IRPs)
     TAILQ_REMOVE(&pipe->port->pipes_idle_tailq, pipe, tailq_entry);
     pipe->port->num_pipes_idle--;
     usbh_hal_chan_free(pipe->port->hal, pipe->chan_obj);
@@ -1526,10 +1513,10 @@ esp_err_t hcd_pipe_update(hcd_pipe_handle_t pipe_hdl, uint8_t dev_addr, int mps)
     //Check if pipe is in the correct state to be updated
     HCD_CHECK_FROM_CRIT(pipe->state != HCD_PIPE_STATE_INVALID
                         && !pipe->flags.pipe_cmd_processing
-                        && pipe->num_xfer_req_pending == 0
-                        && pipe->num_xfer_req_done == 0,
+                        && pipe->num_irp_pending == 0
+                        && pipe->num_irp_done == 0,
                         ESP_ERR_INVALID_STATE);
-    //Check that all transfer requests have been removed and pipe has no pending events
+    //Check that all IRPs have been removed and pipe has no pending events
     pipe->ep_char.dev_addr = dev_addr;
     pipe->ep_char.mps = mps;
     usbh_hal_chan_set_ep_char(pipe->chan_obj, &pipe->ep_char);
@@ -1539,7 +1526,7 @@ esp_err_t hcd_pipe_update(hcd_pipe_handle_t pipe_hdl, uint8_t dev_addr, int mps)
 
 void *hcd_pipe_get_ctx(hcd_pipe_handle_t pipe_hdl)
 {
-    pipe_t *pipe = (pipe_t *) pipe_hdl;
+    pipe_t *pipe = (pipe_t *)pipe_hdl;
     void *ret;
     HCD_ENTER_CRITICAL();
     ret = pipe->context;
@@ -1550,7 +1537,7 @@ void *hcd_pipe_get_ctx(hcd_pipe_handle_t pipe_hdl)
 hcd_pipe_state_t hcd_pipe_get_state(hcd_pipe_handle_t pipe_hdl)
 {
     hcd_pipe_state_t ret;
-    pipe_t *pipe = (pipe_t *) pipe_hdl;
+    pipe_t *pipe = (pipe_t *)pipe_hdl;
     HCD_ENTER_CRITICAL();
     //If there is no enabled device, all existing pipes are invalid.
     if (pipe->port->state != HCD_PORT_STATE_ENABLED
@@ -1566,7 +1553,7 @@ hcd_pipe_state_t hcd_pipe_get_state(hcd_pipe_handle_t pipe_hdl)
 
 esp_err_t hcd_pipe_command(hcd_pipe_handle_t pipe_hdl, hcd_pipe_cmd_t command)
 {
-    pipe_t *pipe = (pipe_t *) pipe_hdl;
+    pipe_t *pipe = (pipe_t *)pipe_hdl;
     bool ret = ESP_OK;
 
     HCD_ENTER_CRITICAL();
@@ -1577,7 +1564,7 @@ esp_err_t hcd_pipe_command(hcd_pipe_handle_t pipe_hdl, hcd_pipe_cmd_t command)
         pipe->flags.pipe_cmd_processing = 1;
         switch (command) {
             case HCD_PIPE_CMD_ABORT: {
-                //Retire all scheduled transfer requests. Pipe's state remains unchanged
+                //Retire all scheduled IRPs. Pipe's state remains unchanged
                 if (!_pipe_wait_done(pipe)) {   //Stop any on going transfers
                     ret = ESP_ERR_INVALID_RESPONSE;
                     break;
@@ -1586,7 +1573,7 @@ esp_err_t hcd_pipe_command(hcd_pipe_handle_t pipe_hdl, hcd_pipe_cmd_t command)
                 break;
             }
             case HCD_PIPE_CMD_RESET: {
-                //Retire all scheduled transfer requests. Pipe's state moves to active
+                //Retire all scheduled IRPs. Pipe's state moves to active
                 if (!_pipe_wait_done(pipe)) {   //Stop any on going transfers
                     ret = ESP_ERR_INVALID_RESPONSE;
                     break;
@@ -1600,9 +1587,9 @@ esp_err_t hcd_pipe_command(hcd_pipe_handle_t pipe_hdl, hcd_pipe_cmd_t command)
                 if (pipe->state == HCD_PIPE_STATE_HALTED) {
                     pipe->state = HCD_PIPE_STATE_ACTIVE;
                     //Start the next pending transfer if it exists
-                    if (_pipe_get_next_xfer_req(pipe)) {
-                        //Fill the descriptor list with the transfer request and start the transfer
-                        _xfer_req_fill(pipe);
+                    if (_pipe_get_next_irp(pipe)) {
+                        //Fill the descriptor list with the IRP and start the transfer
+                        _xfer_desc_list_fill(pipe);
                         usbh_hal_chan_activate(pipe->chan_obj, 0);  //Start with the first descriptor
                     }
                 }
@@ -1626,7 +1613,7 @@ esp_err_t hcd_pipe_command(hcd_pipe_handle_t pipe_hdl, hcd_pipe_cmd_t command)
 
 hcd_pipe_event_t hcd_pipe_get_event(hcd_pipe_handle_t pipe_hdl)
 {
-    pipe_t *pipe = (pipe_t *) pipe_hdl;
+    pipe_t *pipe = (pipe_t *)pipe_hdl;
     hcd_pipe_event_t ret;
     HCD_ENTER_CRITICAL();
     ret = pipe->last_event;
@@ -1635,16 +1622,16 @@ hcd_pipe_event_t hcd_pipe_get_event(hcd_pipe_handle_t pipe_hdl)
     return ret;
 }
 
-// ----------------------------------------------- HCD Transfer Requests -----------------------------------------------
+// ---------------------------------------------- HCD Transfer Descriptors ---------------------------------------------
 
 // ----------------------- Private -------------------------
 
-static void _xfer_req_fill(pipe_t *pipe)
+static void _xfer_desc_list_fill(pipe_t *pipe)
 {
-    //inflight_xfer_req of the pipe must already set to the target transfer request
-    assert(pipe->inflight_xfer_req != NULL);
-    //Fill transfer descriptor list with a single transfer request
-    usb_irp_t *usb_irp = pipe->inflight_xfer_req->irp;
+    //inflight_irp of the pipe must already set to the target IRP
+    assert(pipe->inflight_irp != NULL);
+    //Fill transfer descriptor list with a single IRP
+    usb_irp_t *usb_irp = pipe->inflight_irp;
     switch (pipe->ep_char.type) {
         case USB_XFER_TYPE_CTRL: {
             //Get information about the contorl transfer by analyzing the setup packet (the first 8 bytes)
@@ -1685,7 +1672,7 @@ static void _xfer_req_fill(pipe_t *pipe)
     usbh_hal_chan_slot_acquire(pipe->chan_obj, pipe->xfer_desc_list, pipe->flags.xfer_desc_list_len, (void *)pipe);
 }
 
-static void _xfer_req_continue(pipe_t *pipe)
+static void _xfer_desc_list_continue(pipe_t *pipe)
 {
     int next_idx = usbh_hal_chan_get_next_desc_index(pipe->chan_obj);
     bool next_dir_is_in;    //Next descriptor direction is IN
@@ -1716,9 +1703,9 @@ static void _xfer_req_continue(pipe_t *pipe)
     usbh_hal_chan_activate(pipe->chan_obj, num_to_skip);    //Start the next stage
 }
 
-static void _xfer_req_parse(pipe_t *pipe, bool error_occurred)
+static void _xfer_desc_list_parse(pipe_t *pipe, bool error_occurred)
 {
-    assert(pipe->inflight_xfer_req != NULL);
+    assert(pipe->inflight_irp != NULL);
     //Release the slot
     void *xfer_desc_list;
     int xfer_desc_len;
@@ -1727,7 +1714,7 @@ static void _xfer_req_parse(pipe_t *pipe, bool error_occurred)
     (void) xfer_desc_len;
 
     //Parse the transfer descriptor list for the result of the transfer
-    usb_irp_t *usb_irp = pipe->inflight_xfer_req->irp;
+    usb_irp_t *irp = pipe->inflight_irp;
     usb_transfer_status_t xfer_status;
     int xfer_rem_len;
     if (error_occurred) {
@@ -1747,13 +1734,13 @@ static void _xfer_req_parse(pipe_t *pipe, bool error_occurred)
                     xfer_status = USB_TRANSFER_STATUS_STALL;
                     break;
                 default:
-                    //HCD_PIPE_EVENT_ERROR_XFER_NOT_AVAIL should never occur
+                    //HCD_PIPE_EVENT_ERROR_IRP_NOT_AVAIL should never occur
                     abort();
                     break;
             }
         }
         //We assume no bytes transmitted because of an error.
-        xfer_rem_len = usb_irp->num_bytes;
+        xfer_rem_len = irp->num_bytes;
     } else {
         int desc_status;
         switch (pipe->ep_char.type) {
@@ -1785,144 +1772,104 @@ static void _xfer_req_parse(pipe_t *pipe, bool error_occurred)
         assert(desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS);
     }
     //Write back results to IRP
-    usb_irp->actual_num_bytes = usb_irp->num_bytes - xfer_rem_len;
-    usb_irp->status = xfer_status;
+    irp->actual_num_bytes = irp->num_bytes - xfer_rem_len;
+    irp->status = xfer_status;
 }
 
 // ----------------------- Public --------------------------
 
-hcd_xfer_req_handle_t hcd_xfer_req_alloc()
-{
-    xfer_req_t *xfer_req = calloc(1, sizeof(xfer_req_t));
-    xfer_req->state = XFER_REQ_STATE_IDLE;
-    return (hcd_xfer_req_handle_t) xfer_req;
-}
-
-void hcd_xfer_req_free(hcd_xfer_req_handle_t req_hdl)
-{
-    if (req_hdl == NULL) {
-        return;
-    }
-    xfer_req_t *xfer_req = (xfer_req_t *) req_hdl;
-    //Cannot free a transfer request that is still being used
-    assert(xfer_req->state == XFER_REQ_STATE_IDLE);
-    free(xfer_req);
-}
-
-void hcd_xfer_req_set_target(hcd_xfer_req_handle_t req_hdl, hcd_pipe_handle_t pipe_hdl, usb_irp_t *irp, void *context)
-{
-    xfer_req_t *xfer_req = (xfer_req_t *) req_hdl;
-    //Can only set an transfer request's target when the transfer request is idl
-    assert(xfer_req->state == XFER_REQ_STATE_IDLE);
-    xfer_req->pipe = (pipe_t *) pipe_hdl;
-    xfer_req->irp = irp;
-    xfer_req->context = context;
-}
-
-void hcd_xfer_req_get_target(hcd_xfer_req_handle_t req_hdl, hcd_pipe_handle_t *pipe_hdl, usb_irp_t **irp, void **context)
+esp_err_t hcd_irp_enqueue(hcd_pipe_handle_t pipe_hdl, usb_irp_t *irp)
 {
-    xfer_req_t *xfer_req = (xfer_req_t *) req_hdl;
-    *pipe_hdl = (hcd_pipe_handle_t) xfer_req->pipe;
-    *irp = xfer_req->irp;
-    *context = xfer_req->context;
-}
-
-esp_err_t hcd_xfer_req_enqueue(hcd_xfer_req_handle_t req_hdl)
-{
-    xfer_req_t *xfer_req = (xfer_req_t *) req_hdl;
-    HCD_CHECK(xfer_req->pipe != NULL && xfer_req->irp != NULL       //The transfer request's target must be set
-              && xfer_req->state == XFER_REQ_STATE_IDLE,    //The transfer request cannot be already enqueued
+    //Check that IRP has not already been enqueued
+    HCD_CHECK(irp->reserved_ptr == NULL
+              && IRP_STATE_GET(irp->reserved_flags) == IRP_STATE_IDLE,
               ESP_ERR_INVALID_STATE);
-    pipe_t *pipe = xfer_req->pipe;
+    pipe_t *pipe = (pipe_t *)pipe_hdl;
+
     HCD_ENTER_CRITICAL();
+    //Check that pipe and port are in the corrrect state to receive IRPs
     HCD_CHECK_FROM_CRIT(pipe->port->state == HCD_PORT_STATE_ENABLED     //The pipe's port must be in the correct state
                         && pipe->state == HCD_PIPE_STATE_ACTIVE         //The pipe must be in the correct state
                         && !pipe->flags.pipe_cmd_processing,            //Pipe cannot currently be processing a pipe command
                         ESP_ERR_INVALID_STATE);
+    //Use the IRP's reserved_ptr to store the pipe's
+    irp->reserved_ptr = (void *)pipe;
+
     //Check if we can start execution on the pipe immediately
-    if (!pipe->flags.paused && pipe->num_xfer_req_pending == 0 && pipe->inflight_xfer_req == NULL) {
+    if (!pipe->flags.paused && pipe->num_irp_pending == 0 && pipe->inflight_irp == NULL) {
         //Pipe isn't executing any transfers. Start immediately
-        pipe->inflight_xfer_req = xfer_req;
-        _xfer_req_fill(pipe);
+        pipe->inflight_irp = irp;
+        _xfer_desc_list_fill(pipe);
         usbh_hal_chan_activate(pipe->chan_obj, 0);  //Start with the first descriptor
-        xfer_req->state = XFER_REQ_STATE_INFLIGHT;
-        if (pipe->num_xfer_req_done == 0) {
-            //This is the first transfer request to be enqueued into the pipe. Move the pipe to the list of queued pipes
+        //use the IRP's reserved_flags to store the IRP's current state
+        IRP_STATE_SET(irp->reserved_flags, IRP_STATE_INFLIGHT);
+        if (pipe->num_irp_done == 0) {
+            //This is the first IRP to be enqueued into the pipe. Move the pipe to the list of active pipes
             TAILQ_REMOVE(&pipe->port->pipes_idle_tailq, pipe, tailq_entry);
-            TAILQ_INSERT_TAIL(&pipe->port->pipes_queued_tailq, pipe, tailq_entry);
+            TAILQ_INSERT_TAIL(&pipe->port->pipes_active_tailq, pipe, tailq_entry);
             pipe->port->num_pipes_idle--;
             pipe->port->num_pipes_queued++;
         }
     } else {
-        //Add the transfer request to the pipe's pending tailq
-        TAILQ_INSERT_TAIL(&pipe->pend_xfer_req_tailq, xfer_req, tailq_entry);
-        pipe->num_xfer_req_pending++;
-        xfer_req->state = XFER_REQ_STATE_PENDING;
+        //Add the IRP to the pipe's pending tailq
+        TAILQ_INSERT_TAIL(&pipe->pending_irp_tailq, irp, tailq_entry);
+        pipe->num_irp_pending++;
+        //use the IRP's reserved_flags to store the IRP's current state
+        IRP_STATE_SET(irp->reserved_flags, IRP_STATE_PENDING);
     }
     HCD_EXIT_CRITICAL();
     return ESP_OK;
 }
 
-hcd_xfer_req_handle_t hcd_xfer_req_dequeue(hcd_pipe_handle_t pipe_hdl)
+usb_irp_t *hcd_irp_dequeue(hcd_pipe_handle_t pipe_hdl)
 {
     pipe_t *pipe = (pipe_t *)pipe_hdl;
-    hcd_xfer_req_handle_t ret;
+    usb_irp_t *irp;
 
     HCD_ENTER_CRITICAL();
-    if (pipe->num_xfer_req_done > 0) {
-        xfer_req_t *xfer_req = TAILQ_FIRST(&pipe->done_xfer_req_tailq);
-        TAILQ_REMOVE(&pipe->done_xfer_req_tailq, xfer_req, tailq_entry);
-        pipe->num_xfer_req_done--;
-        assert(xfer_req->state == XFER_REQ_STATE_DONE);
-        xfer_req->state = XFER_REQ_STATE_IDLE;
-        ret = (hcd_xfer_req_handle_t) xfer_req;
-        if (pipe->num_xfer_req_done == 0 && pipe->num_xfer_req_pending == 0) {
-            //This pipe has no more enqueued transfers. Move the pipe to the list of idle pipes
-            TAILQ_REMOVE(&pipe->port->pipes_queued_tailq, pipe, tailq_entry);
+    if (pipe->num_irp_done > 0) {
+        irp = TAILQ_FIRST(&pipe->done_irp_tailq);
+        TAILQ_REMOVE(&pipe->done_irp_tailq, irp, tailq_entry);
+        pipe->num_irp_done--;
+        //Check the IRP's reserved fields then reset them
+        assert(irp->reserved_ptr == (void *)pipe && IRP_STATE_GET(irp->reserved_flags) == IRP_STATE_DONE);  //The IRP's reserved field should have been set to this pipe
+        irp->reserved_ptr = NULL;
+        IRP_STATE_SET(irp->reserved_flags, IRP_STATE_IDLE);
+        if (pipe->num_irp_done == 0 && pipe->num_irp_pending == 0) {
+            //This pipe has no more enqueued IRPs. Move the pipe to the list of idle pipes
+            TAILQ_REMOVE(&pipe->port->pipes_active_tailq, pipe, tailq_entry);
             TAILQ_INSERT_TAIL(&pipe->port->pipes_idle_tailq, pipe, tailq_entry);
             pipe->port->num_pipes_idle++;
             pipe->port->num_pipes_queued--;
         }
     } else {
-        ret = NULL;
+        //No more IRPs to dequeue from this pipe
+        irp = NULL;
     }
     HCD_EXIT_CRITICAL();
-    return ret;
+    return irp;
 }
 
-esp_err_t hcd_xfer_req_abort(hcd_xfer_req_handle_t req_hdl)
+esp_err_t hcd_irp_abort(usb_irp_t *irp)
 {
-    xfer_req_t *xfer_req = (xfer_req_t *) req_hdl;
-    esp_err_t ret;
-
     HCD_ENTER_CRITICAL();
-    switch (xfer_req->state) {
-        case XFER_REQ_STATE_PENDING: {
-            //Transfer request has not been executed so it can be aborted
-            pipe_t *pipe = xfer_req->pipe;
-            //Remove it form the pending queue
-            TAILQ_REMOVE(&pipe->pend_xfer_req_tailq, xfer_req, tailq_entry);
-            pipe->num_xfer_req_pending--;
-            //Add it to the done queue
-            TAILQ_INSERT_TAIL(&pipe->done_xfer_req_tailq, xfer_req, tailq_entry);
-            pipe->num_xfer_req_done++;
-            //Update the transfer request and associated IRP's status
-            xfer_req->state = XFER_REQ_STATE_DONE;
-            xfer_req->irp->status = USB_TRANSFER_STATUS_CANCELLED;
-            ret = ESP_OK;
-            break;
-        }
-        case XFER_REQ_STATE_IDLE: {
-            //Cannot abort a transfer request that was never enqueued
-            ret = ESP_ERR_INVALID_STATE;
-            break;
-        }
-        default :{
-            //Transfer request is currently or has already been executed. Nothing to do.
-            ret = ESP_OK;
-            break;
-        }
-    }
+    //Check that the IRP was enqueued to begin with
+    HCD_CHECK_FROM_CRIT(irp->reserved_ptr != NULL
+                        && IRP_STATE_GET(irp->reserved_flags) != IRP_STATE_IDLE,
+                        ESP_ERR_INVALID_STATE);
+    if (IRP_STATE_GET(irp->reserved_flags) == IRP_STATE_PENDING) {
+        //IRP has not been executed so it can be aborted
+        pipe_t *pipe = (pipe_t *)irp->reserved_ptr;
+        //Remove it form the pending queue
+        TAILQ_REMOVE(&pipe->pending_irp_tailq, irp, tailq_entry);
+        pipe->num_irp_pending--;
+        //Add it to the done queue
+        TAILQ_INSERT_TAIL(&pipe->done_irp_tailq, irp, tailq_entry);
+        pipe->num_irp_done++;
+        //Update the IRP's current state and status
+        IRP_STATE_SET(irp->reserved_flags, IRP_STATE_DONE);
+        irp->status = USB_TRANSFER_STATUS_CANCELLED;
+    }// Otherwise, the IRP is inflight or already done thus cannot be aborted
     HCD_EXIT_CRITICAL();
-    return ret;
+    return ESP_OK;
 }
diff --git a/components/usb/maintainers.md b/components/usb/maintainers.md
index e9d6af7a9..29e2519ba 100644
--- a/components/usb/maintainers.md
+++ b/components/usb/maintainers.md
@@ -39,10 +39,10 @@ The HAL layer abstracts the DWC_OTG operating in Host Mode using Internal Scatte
 
 # Host Controller Driver (HCD)
 
-The HCD (Host Controller Driver) abstracts the DWC_OTG as N number of ports and an arbitrary number of pipes that can be routed through one of the ports to a device. However note that the underlying hardware controller only has one port, so technically only one port can ever be enabled.
+The HCD (Host Controller Driver) abstracts the DWC_OTG as N number of ports and an arbitrary number of pipes that can be routed through one of the ports to a device. However note that **the underlying hardware controller only has a single port, so technically only one port can ever be enabled**.
 
 - In other words, the HCD essentially implements a root hub (not fully behavioral compliant) that contains a single port.
-- Pipes are "an association between an endpoint on a device and software on the host". Transfer requests (where each transfer request represents an entire USB transfer) can be enqueued into a pipe for transmission, and dequeued from a pipe when completed.
+- Pipes are "an association between an endpoint on a device and software on the host". IRPs (I/O Request Packets) that each represent a USB transfer can be enqueued into a pipe for transmission, and dequeued from a pipe when completed.
 
 The HCD currently has the following limitations:
 
@@ -63,10 +63,11 @@ The HCD currently has the following limitations:
 ## HCD Pipes
 
 - Pipes can be opened to a particular endpoint based on a descriptor provided on allocation. If opening a default pipe, a `NULL` descriptor can be provided.
-- Transfer requests can be enqueued into a pipe. Pipes use a linked list internally, so there is in-theory no limit to the number of transfer requests that can be enqueued.
-- Transfer requests need to be dequeued once they are completed.
-- Transfer requests are essentially wrappers for USB IRPs (I/O Request Packets). Once allocated, transfer request need to have their target IRP and pipe set before being enqueued.
-- Since the IRP is a `typedef` used throughout the entire Host stack, each layer simply needs to pass the pointer of the IRP to the next layer thus minimizing the amount of copying required.
+- IRPs can be enqueued into a pipe. Pipes use a linked list internally, so there is in-theory no limit to the number of IRPs that can be enqueued.
+- IRPs need to be dequeued once they are completed.
+- IRPs need to have the transfer information (such as data buffer, transfer length in bytes) filled before they should be enqueued.
+- IRPs will be owned by the HCD until they are dequeued. Thus users should not attempt to modify an IRP object until it is dequeued.
+- The IRP is defined in `usb.h` instead of `hcd.h` so that it can be used throughout the entire Host stack. Each layer simply needs to pass the pointer of the IRP to the next layer thus minimizing the amount of copying required.
 
 ## HCD SW Arch
 
diff --git a/components/usb/private_include/hcd.h b/components/usb/private_include/hcd.h
index 3ad143de3..48d4547cb 100644
--- a/components/usb/private_include/hcd.h
+++ b/components/usb/private_include/hcd.h
@@ -51,14 +51,14 @@ typedef enum {
  * @brief States of an HCD pipe
  *
  * Active:
- *  - Pipe is able to transmit data. Transfer request can be enqueued.
- *  - Event if pipe has no transfer requests enqueued, it can still be in the active state.
+ *  - Pipe is able to transmit data. IRPs can be enqueued.
+ *  - Event if pipe has no IRPs enqueued, it can still be in the active state.
  * Halted:
- *  - An error has occurred on the pipe. Transfer request will no longer be executed.
+ *  - An error has occurred on the pipe. IRPs will no longer be executed.
  *  - Halt should be cleared using the clear command
  * Invalid:
  *  - The underlying device that the pipe connects is not longer valid, thus making the pipe invalid.
- *  - Pending transfer requests should be dequeued and the pipe should be freed.
+ *  - Pending IRPs should be dequeued and the pipe should be freed.
  */
 typedef enum {
     HCD_PIPE_STATE_ACTIVE,          /**< The pipe is active */
@@ -91,10 +91,10 @@ typedef enum {
  */
 typedef enum {
     HCD_PIPE_EVENT_NONE,                    /**< The pipe has no events (used to indicate no events when polling) */
-    HCD_PIPE_EVENT_XFER_REQ_DONE,           /**< The pipe has completed a transfer request and can be dequeued */
+    HCD_PIPE_EVENT_IRP_DONE,                /**< The pipe has completed an IRP. The IRP can be dequeued */
     HCD_PIPE_EVENT_INVALID,                 /**< The pipe is invalid because  */
     HCD_PIPE_EVENT_ERROR_XFER,              /**< Excessive (three consecutive) transaction errors (e.g., no ACK, bad CRC etc) */
-    HCD_PIPE_EVENT_ERROR_XFER_NOT_AVAIL,    /**< Transfer request was not available */
+    HCD_PIPE_EVENT_ERROR_IRP_NOT_AVAIL,     /**< IRP was not available */
     HCD_PIPE_EVENT_ERROR_OVERFLOW,          /**< Received more data than requested. Usually a Packet babble error
                                                  (i.e., an IN packet has exceeded the endpoint's MPS) */
     HCD_PIPE_EVENT_ERROR_STALL,             /**< Pipe received a STALL response received */
@@ -120,8 +120,8 @@ typedef enum {
  * The pipe commands represent the list of pipe manipulations outlined in 10.5.2.2. of USB2.0 specification.
  */
 typedef enum {
-    HCD_PIPE_CMD_ABORT,             /**< Retire all scheduled transfer requests. Pipe's state remains unchanged */
-    HCD_PIPE_CMD_RESET,             /**< Retire all scheduled transfer requests. Pipe's state moves to active */
+    HCD_PIPE_CMD_ABORT,             /**< Retire all scheduled IRPs. Pipe's state remains unchanged */
+    HCD_PIPE_CMD_RESET,             /**< Retire all scheduled IRPs. Pipe's state moves to active */
     HCD_PIPE_CMD_CLEAR,             /**< Pipe's state moves from halted to active */
     HCD_PIPE_CMD_HALT               /**< Pipe's state moves to halted */
 } hcd_pipe_cmd_t;
@@ -138,11 +138,6 @@ typedef void * hcd_port_handle_t;
  */
 typedef void * hcd_pipe_handle_t;
 
-/**
- * @brief HCD transfer request handle type
- */
-typedef void * hcd_xfer_req_handle_t;
-
 /**
  * @brief Port event callback type
  *
@@ -360,7 +355,7 @@ esp_err_t hcd_pipe_alloc(hcd_port_handle_t port_hdl, const hcd_pipe_config_t *pi
  *
  * Frees the resources used by an HCD pipe. The pipe's handle should be discarded after calling this function. The pipe
  * must be in following condition before it can be freed:
- * - All transfers have been dequeued
+ * - All IRPs have been dequeued
  *
  * @param pipe_hdl Pipe handle
  *
@@ -376,7 +371,7 @@ esp_err_t hcd_pipe_free(hcd_pipe_handle_t pipe_hdl);
  * address and maximum packet size. This function can only be called on a pipe that has met the following conditions:
  * - Pipe is still valid (i.e., not in the HCD_PIPE_STATE_INVALID state)
  * - Pipe is not currently processing a command
- * - All transfer request have been dequeued from the pipe
+ * - All IRPs have been dequeued from the pipe
  *
  * @param pipe_hdl Pipe handle
  * @param dev_addr New device address
@@ -406,12 +401,12 @@ hcd_pipe_state_t hcd_pipe_get_state(hcd_pipe_handle_t pipe_hdl);
 /**
  * @brief Execute a command on a particular pipe
  *
- * Pipe commands allow a pipe to be manipulated (such as clearing a halt, retiring all transfer requests etc). The
- * following conditions must for a pipe command to be issued:
+ * Pipe commands allow a pipe to be manipulated (such as clearing a halt, retiring all IRPs etc). The following
+ * conditions must for a pipe command to be issued:
  * - Pipe is still valid (i.e., not in the HCD_PIPE_STATE_INVALID)
  * - No other thread/task processing a command on the pipe concurrently (will return)
  *
- * @note Some pipe commands will block until the pipe's current inflight transfer is completed. If the pipe's state
+ * @note Some pipe commands will block until the pipe's current inflight IRP is complete. If the pipe's state
  *       changes unexpectedley, this function will return ESP_ERR_INVALID_RESPONSE
  *
  * @param pipe_hdl Pipe handle
@@ -433,92 +428,47 @@ esp_err_t hcd_pipe_command(hcd_pipe_handle_t pipe_hdl, hcd_pipe_cmd_t command);
  */
 hcd_pipe_event_t hcd_pipe_get_event(hcd_pipe_handle_t pipe_hdl);
 
-// ----------------------------------------------- HCD Transfer Requests -----------------------------------------------
-
-/**
- * @brief Allocate a transfer request
- *
- * @note The allocate transfer request will not have its target set (i.e., no target pipe and associated IRP). Call
- *       hcd_xfer_req_set_target() before enqueueing the transfer request
- *
- * @return hcd_xfer_req_handle_t Transfer request handle or NULL if failed.
- */
-hcd_xfer_req_handle_t hcd_xfer_req_alloc(void);
-
-/**
- * @brief Free a transfer request
- *
- * @note The transfer request must be dequeued before it can be freed
- *
- * @param req_hdl Transfer request handle
- */
-void hcd_xfer_req_free(hcd_xfer_req_handle_t req_hdl);
+// ---------------------------------------------------- HCD IRPs -------------------------------------------------------
 
 /**
- * @brief Set a transfer request's target
+ * @brief Enqueue an IRP to a particular pipe
  *
- * Setting a transfer request's target will associate a transfer request with a pipe and a USB IRP (i.e., the data). A
- * transfer request's target must be set before it can be enqueued.
+ * The following conditions must be met before an IRP can be enqueued:
+ * - The IRP is properly initialized (data buffer and transfer length are set)
+ * - The IRP must not already be enqueued
+ * - The pipe must be in the HCD_PIPE_STATE_ACTIVE state
  *
- * @note This should only be called when a transfer requests that are not currently enqueued
- *
- * @param req_hdl Transfer request handle
- * @param pipe_hdl Target pipe's handle
- * @param irp Target IRP handle
- * @param context Context variable to associate transfer request with upper layer object
- */
-void hcd_xfer_req_set_target(hcd_xfer_req_handle_t req_hdl, hcd_pipe_handle_t pipe_hdl, usb_irp_t *irp, void *context);
-
-/**
- * @brief Get the target of a transfer request
- *
- * @note This should only be called when a transfer requests that are not currently enqueued
- *
- * @param[in] req_hdl Transfer request handle
- * @param[out] pipe_hdl Target pipe's handle
- * @param[out] irp Target IRP's handle
- * @param[out] context Context variable
- */
-void hcd_xfer_req_get_target(hcd_xfer_req_handle_t req_hdl, hcd_pipe_handle_t *pipe_hdl, usb_irp_t **irp, void **context);
-
-/**
- * @brief Enqueue a transfer request
- *
- * The following conditions must be met for a transfer request to be enqueued:
- * - The transfer request's target must be set
- * - Transfer request must not already be enqueued
- * - The target pipe must be in the HCD_PIPE_STATE_ACTIVE state
- *
- * @param req_hdl Transfer request handle
- * @retval ESP_OK: Transfer request enqueued successfully
- * @retval ESP_ERR_INVALID_STATE: Conditions not met to enqueue transfer request
+ * @param pipe_hdl Pipe handle
+ * @param irp I/O Request Packet to enqueue
+ * @retval ESP_OK: IRP enqueued successfully
+ * @retval ESP_ERR_INVALID_STATE: Conditions not met to enqueue IRP
  */
-esp_err_t hcd_xfer_req_enqueue(hcd_xfer_req_handle_t req_hdl);
+esp_err_t hcd_irp_enqueue(hcd_pipe_handle_t pipe_hdl, usb_irp_t *irp);
 
 /**
- * @brief Dequeue a completed transfer request from a pipe
+ * @brief Dequeue an IRP from a particular pipe
  *
- * This function should be called on a pipe after it receives an pipe event. If a pipe has multiple transfer requests
- * that can be dequeued, this function must be called repeatedely until all transfer requests are dequeued. If a pipe
- * has no more transfer requests to dequeue, this function will return NULL.
+ * This function should be called on a pipe after a pipe receives a HCD_PIPE_EVENT_IRP_DONE event. If a pipe has
+ * multiple IRPs that can be dequeued, this function should be called repeatedely until all IRPs are dequeued. If a pipe
+ * has no more IRPs to dequeue, this function will return NULL.
  *
  * @param pipe_hdl Pipe handle
- * @return hcd_xfer_req_handle_t Transfer request handle or NULL if no more transfer requests to dequeue.
+ * @return usb_irp_t* Dequeued I/O Request Packet, or NULL if no more IRPs to dequeue
  */
-hcd_xfer_req_handle_t hcd_xfer_req_dequeue(hcd_pipe_handle_t pipe_hdl);
+usb_irp_t *hcd_irp_dequeue(hcd_pipe_handle_t pipe_hdl);
 
 /**
- * @brief Abort an ongoing transfer request
+ * @brief Abort an enqueued IRP
  *
- * This function will attempt to abort an enqueued transfer request. If the transfer request has not yet been executed,
- * it will be marked as "cancelled" and can be dequeued. If a transfer request is already in progress or has completed,
- * it will not be affected by this function.
+ * This function will attempt to abort an IRP that is already enqueued. If the IRP has yet to be executed, it will be
+ * "cancelled" and can then be dequeued. If the IRP is currenty inflight or has already completed, the IRP will not be
+ * affected by this function.
  *
- * @param req_hdl Transfer request handle
- * @retval ESP_OK: Transfer request successfully aborted, or did not need to be aborted
- * @retval ESP_ERR_INVALID_STATE: Transfer request was never enqueued
+ * @param irp I/O Request Packet to abort
+ * @retval ESP_OK: IRP successfully aborted, or was not affected by this function
+ * @retval ESP_ERR_INVALID_STATE: IRP was never enqueued
  */
-esp_err_t hcd_xfer_req_abort(hcd_xfer_req_handle_t req_hdl);
+esp_err_t hcd_irp_abort(usb_irp_t *irp);
 
 #ifdef __cplusplus
 }
diff --git a/components/usb/private_include/usb.h b/components/usb/private_include/usb.h
index 79ad39547..cfed578de 100644
--- a/components/usb/private_include/usb.h
+++ b/components/usb/private_include/usb.h
@@ -27,6 +27,7 @@ extern "C"
 #endif
 
 #include <stdint.h>
+#include <sys/queue.h>
 
 #define USB_CTRL_REQ_ATTR       __attribute__((packed))
 #define USB_DESC_ATTR           __attribute__((packed))
@@ -87,29 +88,38 @@ typedef struct {
 /**
  * @brief USB IRP (I/O Request Packet). See USB2.0 Spec
  *
- * An identifiable request by a software client to move data between itself (on the
- * host) and an endpoint of a device in an appropriate direction.
- *
- * This structure represents the barebones of the request. Different layers of
- * USB drivers will wrap their own objects around this.
+ * An IRP is used to represent data transfer request form a software client to and endpoint over the USB bus. The same
+ * IRP object type is used at each layer of the USB stack. This minimizes copying/conversion across the different layers
+ * of the stack as each layer will pass a pointer to this type of object. lathus allows
  *
  * See 10.5.3.1 os USB2.0 specification
- * Bulk: Represnts a single bulk transfer which a pipe will transparently split
- *       into multiple MPS transactions (until the last)
- * Control: Represents a single contorl transfer with the setup packet at the
- *          first 8 bytes of the buffer.
+ * Bulk: Represnts a single bulk transfer which a pipe will transparently split into multiple MPS transactions (until
+ *       the last)
+ * Control: Represents a single contorl transfer with the setup packet at the first 8 bytes of the buffer.
  * Interrupt: Represnts a single interrupt transaction
- * Isochronous: Represnts a buffer of a stream of bytes which the pipe will transparently
- *              transfer the stream of bytes one or more service periods
+ * Isochronous: Represnts a buffer of a stream of bytes which the pipe will transparently transfer the stream of bytes
+ *              one or more service periods
+ *
+ * @note The tailq_entry and reserved variables are used by the USB Host stack internally. Users should not modify those fields.
+ * @note Once an IRP is submitted, users should not modify the IRP as the Host stack takes ownership of the IRP.
  */
-typedef struct {
-    int num_bytes;                      /**< Number of bytes in IRP. Control should exclude size of setup. IN should be integer multiple of MPS */
-    int actual_num_bytes;               /**< Actual number of bytes transmitted/receives in the IRP */
-    uint8_t *data_buffer;               /**< Pointer to data buffer. Must be DMA capable memory */
-    usb_transfer_status_t status;       /**< Status of the transfer */
-    int num_iso_packets;                /**< Only relevant to isochronous. Number of service periods to transfer data buffer over. Set to 0 for non-iso transfers */
+struct usb_irp_obj {
+    //Internal members
+    TAILQ_ENTRY(usb_irp_obj) tailq_entry;   /**< TAILQ entry that allows this objecct to be added to linked lists. Users should NOT modify this field */
+    void *reserved_ptr;                     /**< Reserved pointer variable for internal use in the stack. Users should set this to NULL on allocation and NOT modify this afterwards */
+    uint32_t reserved_flags;                   /**< Reserved variable for flags used internally in the stack. Users should set this to 0 on allocation and NOT modify this afterwards */
+    //Public members
+    uint8_t *data_buffer;                   /**< Pointer to data buffer. Must be DMA capable memory */
+    int num_bytes;                          /**< Number of bytes in IRP. Control should exclude size of setup. IN should be integer multiple of MPS */
+    int actual_num_bytes;                   /**< Actual number of bytes transmitted/receives in the IRP */
+    usb_transfer_status_t status;           /**< Status of the transfer */
+    uint32_t timeout;                       /**< Timeout (in milliseconds) of the packet */
+    void *context;                          /**< Context variable used to associate the IRP object with another object */
+    int num_iso_packets;                    /**< Only relevant to isochronous. Number of service periods to transfer data buffer over. Set to 0 for non-iso transfers */
     usb_iso_packet_desc_t iso_packet_desc[0];   /**< Descriptors for each ISO packet */
-} usb_irp_t;
+};
+
+typedef struct usb_irp_obj usb_irp_t;
 
 // ---------------------------------------------------- Chapter 9 ------------------------------------------------------
 
diff --git a/components/usb/test/test_hcd.c b/components/usb/test/test_hcd.c
index e5919176b..33aa64019 100644
--- a/components/usb/test/test_hcd.c
+++ b/components/usb/test/test_hcd.c
@@ -17,13 +17,14 @@
 #include "freertos/semphr.h"
 #include "unity.h"
 #include "test_utils.h"
+#include "soc/gpio_pins.h"
+#include "soc/gpio_sig_map.h"
 #include "esp_intr_alloc.h"
 #include "esp_err.h"
 #include "esp_attr.h"
 #include "esp_rom_gpio.h"
-#include "soc/gpio_pins.h"
-#include "soc/gpio_sig_map.h"
 #include "hal/usbh_ll.h"
+#include "usb.h"
 #include "hcd.h"
 
 // -------------------------------------------------- PHY Control ------------------------------------------------------
@@ -48,8 +49,8 @@ static void phy_force_conn_state(bool connected, TickType_t delay_ticks)
 // ------------------------------------------------ Helper Functions ---------------------------------------------------
 
 #define EVENT_QUEUE_LEN         5
-#define NUM_XFER_REQS           3
-#define XFER_DATA_MAX_LEN       256     //Just assume that will only IN/OUT 256 bytes for now
+#define NUM_IRPS                3
+#define TRANSFER_DATA_MAX_BYTES 256     //Just assume that will only IN/OUT 256 bytes for now
 #define PORT_NUM                1
 
 typedef struct {
@@ -214,13 +215,11 @@ static void wait_for_disconnection(hcd_port_handle_t port_hdl, QueueHandle_t por
     TEST_ASSERT_EQUAL(HCD_PORT_STATE_NOT_POWERED, hcd_port_get_state(port_hdl));
 }
 
-static void alloc_pipe_and_xfer_reqs(hcd_port_handle_t port_hdl,
-                                     QueueHandle_t pipe_evt_queue,
-                                     hcd_pipe_handle_t *pipe_hdl,
-                                     hcd_xfer_req_handle_t *req_hdls,
-                                     uint8_t **data_buffers,
-                                     usb_irp_t **irps,
-                                     int num_xfers)
+static void alloc_pipe_and_irp_list(hcd_port_handle_t port_hdl,
+                                    QueueHandle_t pipe_evt_queue,
+                                    int num_irps,
+                                    hcd_pipe_handle_t *pipe_hdl,
+                                    usb_irp_t ***irp_list)
 {
     //We don't support hubs yet. Just get the speed of the port to determine the speed of the device
     usb_speed_t port_speed;
@@ -238,38 +237,37 @@ static void alloc_pipe_and_xfer_reqs(hcd_port_handle_t port_hdl,
     };
     TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_alloc(port_hdl, &config, pipe_hdl));
     TEST_ASSERT_NOT_EQUAL(NULL, *pipe_hdl);
-    //Create transfer requests (and other required objects such as IRPs and data buffers)
-    printf("Creating transfer requests\n");
-    for (int i = 0; i < num_xfers; i++) {
-        //Allocate transfer request object
-        req_hdls[i] = hcd_xfer_req_alloc();
-        TEST_ASSERT_NOT_EQUAL(NULL, req_hdls[i]);
-        //Allocate data buffers
-        data_buffers[i] = heap_caps_malloc(sizeof(usb_ctrl_req_t) + XFER_DATA_MAX_LEN, MALLOC_CAP_DMA);
-        TEST_ASSERT_NOT_EQUAL(NULL, data_buffers[i]);
-        //Allocate IRP object
-        irps[i] = heap_caps_malloc(sizeof(usb_irp_t), MALLOC_CAP_DEFAULT);
-        TEST_ASSERT_NOT_EQUAL(NULL, irps[i]);
-        //Set the transfer request's target
-        hcd_xfer_req_set_target(req_hdls[i], *pipe_hdl, irps[i], NULL);
+    //Create IRPs and their data buffers
+    printf("Creating IRPs and IRP list\n");
+    *irp_list = heap_caps_malloc(sizeof(usb_irp_t *) * num_irps, MALLOC_CAP_DEFAULT);
+    TEST_ASSERT_NOT_EQUAL(NULL, *irp_list);
+    for (int i = 0; i < num_irps; i++) {
+        //Allocate IRP
+        usb_irp_t *irp = heap_caps_calloc(1, sizeof(usb_irp_t), MALLOC_CAP_DEFAULT);
+        TEST_ASSERT_NOT_EQUAL(NULL, irp);
+        //Allocate data buffer
+        uint8_t *data_buffer = heap_caps_malloc(sizeof(usb_ctrl_req_t) + TRANSFER_DATA_MAX_BYTES, MALLOC_CAP_DMA);
+        TEST_ASSERT_NOT_EQUAL(NULL, data_buffer);
+        //Initialize IRP and IRP list
+        irp->data_buffer = data_buffer;
+        irp->num_iso_packets = 0;
+        (*irp_list)[i] = irp;
     }
 }
 
-static void free_pipe_and_xfer_reqs(hcd_pipe_handle_t pipe_hdl,
-                                    hcd_xfer_req_handle_t *req_hdls,
-                                    uint8_t **data_buffers,
-                                    usb_irp_t **irps,
-                                    int num_xfers)
+static void free_pipe_and_irp_list(hcd_pipe_handle_t pipe_hdl,
+                                   int num_irps,
+                                   usb_irp_t **irp_list)
 {
-    printf("Freeing transfer requets\n");
-    //Free transfer requests (and their associated objects such as IRPs and data buffers)
-    for (int i = 0; i < num_xfers; i++) {
-        heap_caps_free(irps[i]);
-        heap_caps_free(data_buffers[i]);
-        hcd_xfer_req_free(req_hdls[i]);
-    }
+    printf("Freeing IRPs and IRP list\n");
+    for (int i = 0; i < num_irps; i++) {
+        usb_irp_t *irp = irp_list[i] ;
+        //Free data buffer
+        heap_caps_free(irp->data_buffer);
+        heap_caps_free(irp);
+    }
+    heap_caps_free(irp_list);
     printf("Freeing default pipe\n");
-    //Delete the pipe
     TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_free(pipe_hdl));
 }
 
@@ -280,13 +278,13 @@ Test a port sudden disconnect and port recovery
 
 Purpose: Test that when sudden disconnection happens on an HCD port, the port will
     - Generate the HCD_PORT_EVENT_SUDDEN_DISCONN and be put into the HCD_PORT_STATE_RECOVERY state
-    - Ongoing transfers requests and pipes are handled correctly
+    - Ongoing IRPs and pipes are handled correctly
 
 Procedure:
-    - Setup HCD, a default pipe, and multiple transfer requests
+    - Setup HCD, a default pipe, and multiple IRPs
     - Start transfers but immediately trigger a disconnect
     - Check that HCD_PORT_EVENT_SUDDEN_DISCONN event is generated
-    - Check that default pipe is invalid and transfer requests can be dequeued
+    - Check that default pipe is invalid and IRPs can be dequeued
     - Recover the port and try to connect then disconnect again (to make sure the port works port recovery)
     - Teardown HCD
 */
@@ -299,24 +297,21 @@ TEST_CASE("Test HCD port sudden disconnect", "[hcd][ignore]")
     wait_for_connection(port_hdl, port_evt_queue);
     vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
 
-    //Allocate transfer requests
+    //Allocate default pipe and IRPs
     hcd_pipe_handle_t default_pipe;
-    hcd_xfer_req_handle_t req_hdls[NUM_XFER_REQS];
-    uint8_t *data_buffers[NUM_XFER_REQS];
-    usb_irp_t *irps[NUM_XFER_REQS];
-    alloc_pipe_and_xfer_reqs(port_hdl, pipe_evt_queue, &default_pipe, req_hdls, data_buffers, irps, NUM_XFER_REQS);
+    usb_irp_t **irp_list;
+    alloc_pipe_and_irp_list(port_hdl, pipe_evt_queue, NUM_IRPS, &default_pipe, &irp_list);
 
-    //Initialize transfer requests to send a "Get Device Descriptor" request
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        irps[i]->num_bytes = 64;    //1 worst case MPS
-        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *) data_buffers[i], 0, XFER_DATA_MAX_LEN);
-        irps[i]->data_buffer = data_buffers[i];
-        irps[i]->num_iso_packets = 0;
+    //Initialize IRPs to send a "Get Device Descriptor" request
+    for (int i = 0; i < NUM_IRPS; i++) {
+        irp_list[i]->num_bytes = 64;    //1 worst case MPS
+        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *) irp_list[i]->data_buffer, 0, TRANSFER_DATA_MAX_BYTES);
+        irp_list[i]->context = (void *)0xDEADBEEF;
     }
 
-    //Enqueue those transfer requests
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_xfer_req_enqueue(req_hdls[i]));
+    //Enqueue those IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
     }
     phy_force_conn_state(false, 0);    //Force disconnected state on PHY
 
@@ -326,28 +321,23 @@ TEST_CASE("Test HCD port sudden disconnect", "[hcd][ignore]")
     printf("Sudden disconnect\n");
 
     //Handling the disconenction event should have invalidated all pipes.
-    //Pipe should have received (zero or more HCD_PIPE_EVENT_XFER_REQ_DONE) followed by a HCD_PIPE_EVENT_INVALID (MUST OCCUR)
+    //Pipe should have received (zero or more HCD_PIPE_EVENT_IRP_DONE) followed by a HCD_PIPE_EVENT_INVALID (MUST OCCUR)
     int num_pipe_events = EVENT_QUEUE_LEN - uxQueueSpacesAvailable(pipe_evt_queue);
     for (int i = 0; i < num_pipe_events - 1; i++) {
-        expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_XFER_REQ_DONE);
+        expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_IRP_DONE);
     }
     expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_INVALID);
     TEST_ASSERT_EQUAL(hcd_pipe_get_state(default_pipe), HCD_PIPE_STATE_INVALID);
 
-    //Dequeue transfer requests
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        hcd_xfer_req_handle_t req_hdl = hcd_xfer_req_dequeue(default_pipe);
-        hcd_pipe_handle_t pipe_hdl;
-        usb_irp_t *irp;
-        void *context;
-        hcd_xfer_req_get_target(req_hdl, &pipe_hdl, &irp, &context);
-        TEST_ASSERT_EQUAL(default_pipe, pipe_hdl);
-        TEST_ASSERT_EQUAL(irps[i], irp);
+    //Dequeue IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
+        TEST_ASSERT_NOT_EQUAL(NULL, irp);
         TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_COMPLETED || irp->status == USB_TRANSFER_STATUS_NO_DEVICE);
-        TEST_ASSERT_EQUAL(NULL, context);
+        TEST_ASSERT(irp->context == (void *)0xDEADBEEF);
     }
-    //Free transfer requests
-    free_pipe_and_xfer_reqs(default_pipe, req_hdls, data_buffers, irps, NUM_XFER_REQS);
+    //Free IRPs
+    free_pipe_and_irp_list(default_pipe, NUM_IRPS, irp_list);
 
     //Recover the port should return to the to NOT POWERED state
     TEST_ASSERT_EQUAL(ESP_OK, hcd_port_recover(port_hdl));
@@ -368,10 +358,10 @@ Purpose:
     - When resuming, pipes with pending transfer should be started after the bus is resumed.
 
 Procedure:
-    - Setup HCD, a port, a default pipe, and multiple transfer requests
+    - Setup HCD, a port, a default pipe, and multiple IRPS
     - Start transfers but immediately suspend the port
     - Resume the port
-    - Check all transfer requests have also be resumed and completed on port resume
+    - Check all IRPs have also be resumed and completed on port resume
     - Teardown
 */
 TEST_CASE("Test HCD port suspend and resume", "[hcd][ignore]")
@@ -383,23 +373,23 @@ TEST_CASE("Test HCD port suspend and resume", "[hcd][ignore]")
     wait_for_connection(port_hdl, port_evt_queue);
     vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
 
-    //Allocate transfer requests
+    //Allocate default pipe and IRPs
     hcd_pipe_handle_t default_pipe;
-    hcd_xfer_req_handle_t req_hdls[NUM_XFER_REQS];
-    uint8_t *data_buffers[NUM_XFER_REQS];
-    usb_irp_t *irps[NUM_XFER_REQS];
-    alloc_pipe_and_xfer_reqs(port_hdl, pipe_evt_queue, &default_pipe, req_hdls, data_buffers, irps, NUM_XFER_REQS);
-    //Initialize transfer requests to send a "Get Device Descriptor" request
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        irps[i]->num_bytes = 64;    //1 worst case MPS
-        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *) data_buffers[i], 0, XFER_DATA_MAX_LEN);
-        irps[i]->data_buffer = data_buffers[i];
-        irps[i]->num_iso_packets = 0;
-    }
-    //Enqueue those transfer requests
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_xfer_req_enqueue(req_hdls[i]));
+    usb_irp_t **irp_list;
+    alloc_pipe_and_irp_list(port_hdl, pipe_evt_queue, NUM_IRPS, &default_pipe, &irp_list);
+
+    //Initialize IRPs to send a "Get Device Descriptor" request
+    for (int i = 0; i < NUM_IRPS; i++) {
+        irp_list[i]->num_bytes = 64;    //1 worst case MPS
+        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *)irp_list[i]->data_buffer, 0, TRANSFER_DATA_MAX_BYTES);
+        irp_list[i]->context = (void *)0xDEADBEEF;
+    }
+
+    //Enqueue those IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
     }
+
     //Immediately suspend the bus whilst pies are active
     TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_SUSPEND));
     TEST_ASSERT_EQUAL(HCD_PORT_STATE_SUSPENDED, hcd_port_get_state(port_hdl));
@@ -410,22 +400,18 @@ TEST_CASE("Test HCD port suspend and resume", "[hcd][ignore]")
     TEST_ASSERT_EQUAL(HCD_PORT_STATE_ENABLED, hcd_port_get_state(port_hdl));
     vTaskDelay(pdMS_TO_TICKS(100)); //Give some time for resumed transfers to complete
 
-    expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_XFER_REQ_DONE);
-    //Dequeue transfer requests
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        hcd_xfer_req_handle_t req_hdl = hcd_xfer_req_dequeue(default_pipe);
-        hcd_pipe_handle_t pipe_hdl;
-        usb_irp_t *irp;
-        void *context;
-        hcd_xfer_req_get_target(req_hdl, &pipe_hdl, &irp, &context);
-        TEST_ASSERT_EQUAL(default_pipe, pipe_hdl);
-        TEST_ASSERT_EQUAL(irps[i], irp);
+    //Dequeue IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_IRP_DONE);
+        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
+        TEST_ASSERT_NOT_EQUAL(NULL, irp);
         TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_COMPLETED);
-        TEST_ASSERT_EQUAL(NULL, context);
+        TEST_ASSERT(irp->context == (void *)0xDEADBEEF);
     }
+    //Free IRPs
+    free_pipe_and_irp_list(default_pipe, NUM_IRPS, irp_list);
 
-    //Free transfer requests
-    free_pipe_and_xfer_reqs(default_pipe, req_hdls, data_buffers, irps, NUM_XFER_REQS);
+    //Cleanup
     vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
     wait_for_disconnection(port_hdl, port_evt_queue, false);
     teardown(port_evt_queue, pipe_evt_queue, port_hdl);
@@ -440,7 +426,7 @@ Purpose:
     - After disabling the port, all pipes should become invalid.
 
 Procedure:
-    - Setup HCD, a default pipe, and multiple transfer requests
+    - Setup HCD, a default pipe, and multiple IRPs
     - Start transfers but immediately disable the port
     - Check pipe received invalid event
     - Check that transfer are either done or not executed
@@ -455,47 +441,44 @@ TEST_CASE("Test HCD port disable", "[hcd][ignore]")
     wait_for_connection(port_hdl, port_evt_queue);
     vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
 
-    //Allocate transfer requests
+    //Allocate default pipe and IRPs
     hcd_pipe_handle_t default_pipe;
-    hcd_xfer_req_handle_t req_hdls[NUM_XFER_REQS];
-    uint8_t *data_buffers[NUM_XFER_REQS];
-    usb_irp_t *irps[NUM_XFER_REQS];
-    alloc_pipe_and_xfer_reqs(port_hdl, pipe_evt_queue, &default_pipe, req_hdls, data_buffers, irps, NUM_XFER_REQS);
-    //Initialize transfer requests to send a "Get Device Descriptor" request
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        irps[i]->num_bytes = 64;    //1 worst case MPS
-        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *) data_buffers[i], 0, XFER_DATA_MAX_LEN);
-        irps[i]->data_buffer = data_buffers[i];
-        irps[i]->num_iso_packets = 0;
-    }
-    //Enqueue those transfer requests
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_xfer_req_enqueue(req_hdls[i]));
+    usb_irp_t **irp_list;
+    alloc_pipe_and_irp_list(port_hdl, pipe_evt_queue, NUM_IRPS, &default_pipe, &irp_list);
+
+    //Initialize IRPs to send a "Get Device Descriptor" request
+    for (int i = 0; i < NUM_IRPS; i++) {
+        irp_list[i]->num_bytes = 64;    //1 worst case MPS
+        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *) irp_list[i]->data_buffer, 0, TRANSFER_DATA_MAX_BYTES);
+        irp_list[i]->context = (void *)0xDEADBEEF;
+    }
+
+    //Enqueue those IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
     }
     //Immediately disable port
     TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_DISABLE));
     TEST_ASSERT_EQUAL(HCD_PORT_STATE_DISABLED, hcd_port_get_state(port_hdl));
     printf("Disabled\n");
-    //Pipe should have received (zero or more HCD_PIPE_EVENT_XFER_REQ_DONE) followed by a HCD_PIPE_EVENT_INVALID (MUST OCCUR)
+
+    //Pipe should have received (zero or more HCD_PIPE_EVENT_IRP_DONE) followed by a HCD_PIPE_EVENT_INVALID (MUST OCCUR)
     int num_pipe_events = EVENT_QUEUE_LEN - uxQueueSpacesAvailable(pipe_evt_queue);
     for (int i = 0; i < num_pipe_events - 1; i++) {
-        expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_XFER_REQ_DONE);
+        expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_IRP_DONE);
     }
     expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_INVALID);
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        hcd_xfer_req_handle_t req_hdl = hcd_xfer_req_dequeue(default_pipe);
-        hcd_pipe_handle_t pipe_hdl;
-        usb_irp_t *irp;
-        void *context;
-        hcd_xfer_req_get_target(req_hdl, &pipe_hdl, &irp, &context);
-        TEST_ASSERT_EQUAL(default_pipe, pipe_hdl);
-        TEST_ASSERT_EQUAL(irps[i], irp);
+
+    //Dequeue IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
+        TEST_ASSERT_NOT_EQUAL(NULL, irp);
         TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_COMPLETED || irp->status == USB_TRANSFER_STATUS_NO_DEVICE);
-        TEST_ASSERT_EQUAL(NULL, context);
+        TEST_ASSERT(irp->context == (void *)0xDEADBEEF);
     }
+    //Free IRPs
+    free_pipe_and_irp_list(default_pipe, NUM_IRPS, irp_list);
 
-    //Free transfer requests
-    free_pipe_and_xfer_reqs(default_pipe, req_hdls, data_buffers, irps, NUM_XFER_REQS);
     //Already disabled. Disconnect and teardown
     wait_for_disconnection(port_hdl, port_evt_queue, true);
     teardown(port_evt_queue, pipe_evt_queue, port_hdl);
@@ -562,24 +545,25 @@ TEST_CASE("Test HCD port command bailout", "[hcd][ignore]")
 }
 
 // --------------------------------------------------- Pipe Tests ------------------------------------------------------
+
 /*
-Test HCD Transfer Requests (normal completion and early abort)
+Test HCD IRPs (normal completion and early abort)
 
 Purpose:
     - Test that pipes can be created
-    - Transfer requests can be created and enqueued
-    - Pipe returns HCD_PIPE_EVENT_XFER_REQ_DONE
-    - Test that transfer requests can be aborted when enqueued
+    - IRPs can be created and enqueued
+    - Pipe returns HCD_PIPE_EVENT_IRP_DONE
+    - Test that IRPs can be aborted when enqueued
 
 Procedure:
     - Setup
-    - Allocate transfer requests. Initialize as Get Device Descriptor request
-    - Enqueue transfer requests
-    - Expect HCD_PIPE_EVENT_XFER_REQ_DONE. Deallocate transfer requests
-    - Requeue transfer requests, but abort them immediately
+    - Allocate IRPs. Initialize as Get Device Descriptor request
+    - Enqueue IRPs
+    - Expect HCD_PIPE_EVENT_IRP_DONE. Deallocate IRPs
+    - Requeue IRPs, but abort them immediately
     - Teardown
 */
-TEST_CASE("Test HCD pipe transfer request", "[hcd][ignore]")
+TEST_CASE("Test HCD IRP enqueue", "[hcd][ignore]")
 {
     QueueHandle_t port_evt_queue;
     QueueHandle_t pipe_evt_queue;
@@ -588,69 +572,56 @@ TEST_CASE("Test HCD pipe transfer request", "[hcd][ignore]")
     wait_for_connection(port_hdl, port_evt_queue);
     vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
 
-    //Allocate transfer requests
+    //Allocate default pipe and IRPs
     hcd_pipe_handle_t default_pipe;
-    hcd_xfer_req_handle_t req_hdls[NUM_XFER_REQS];
-    uint8_t *data_buffers[NUM_XFER_REQS];
-    usb_irp_t *irps[NUM_XFER_REQS];
-    alloc_pipe_and_xfer_reqs(port_hdl, pipe_evt_queue, &default_pipe, req_hdls, data_buffers, irps, NUM_XFER_REQS);
-
-    //Initialize transfer requests to send a "Get Device Descriptor" request
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        irps[i]->num_bytes = 64;    //1 worst case MPS
-        USB_CTRL_REQ_INIT_GET_DEVC_DESC((usb_ctrl_req_t *) data_buffers[i]);
-        irps[i]->data_buffer = data_buffers[i];
-        irps[i]->num_iso_packets = 0;
-    }
-
-    //Enqueue those transfer requests
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_xfer_req_enqueue(req_hdls[i]));
-    }
-    //Wait for each done event of each transfer request
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_XFER_REQ_DONE);
-    }
-
-    //Dequeue transfer requests and check results.
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        hcd_xfer_req_handle_t req_hdl = hcd_xfer_req_dequeue(default_pipe);
-        TEST_ASSERT_EQUAL(req_hdls[i], req_hdl);
-        hcd_pipe_handle_t pipe_hdl;
-        usb_irp_t *irp;
-        void *context;
-        hcd_xfer_req_get_target(req_hdl, &pipe_hdl, &irp, &context);
-        TEST_ASSERT_EQUAL(default_pipe, pipe_hdl);
-        TEST_ASSERT_EQUAL(irp, irps[i]);
-        TEST_ASSERT_EQUAL(USB_TRANSFER_STATUS_COMPLETED, irp->status);
-        TEST_ASSERT_EQUAL(NULL, context);
+    usb_irp_t **irp_list;
+    alloc_pipe_and_irp_list(port_hdl, pipe_evt_queue, NUM_IRPS, &default_pipe, &irp_list);
+
+    //Initialize IRPs to send a "Get Config Descriptor 0" request
+    for (int i = 0; i < NUM_IRPS; i++) {
+        irp_list[i]->num_bytes = 64;    //1 worst case MPS
+        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *) irp_list[i]->data_buffer, 0, TRANSFER_DATA_MAX_BYTES);
+        irp_list[i]->context = (void *)0xDEADBEEF;
+    }
+
+    //Enqueue those IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
+    }
+
+    //Wait for each done event of each IRP
+    for (int i = 0; i < NUM_IRPS; i++) {
+        expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_IRP_DONE);
+    }
+
+    //Dequeue IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
+        TEST_ASSERT_NOT_EQUAL(NULL, irp);
+        TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_COMPLETED);
+        TEST_ASSERT(irp->context == (void *)0xDEADBEEF);
     }
 
     //Enqueue them again but abort them short after
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_xfer_req_enqueue(req_hdls[i]));
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
     }
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        hcd_xfer_req_abort(req_hdls[i]);
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_abort(irp_list[i]));
     }
     vTaskDelay(pdMS_TO_TICKS(100)); //Give some time for any inflight transfers to complete
 
-    expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_XFER_REQ_DONE);
-    //Dequeue transfer rqeuests and check results of aborted transfer request
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        hcd_xfer_req_handle_t req_hdl = hcd_xfer_req_dequeue(default_pipe);
-        hcd_pipe_handle_t pipe_hdl;
-        usb_irp_t *irp;
-        void *context;
-        hcd_xfer_req_get_target(req_hdl, &pipe_hdl, &irp, &context);
-        TEST_ASSERT_EQUAL(default_pipe, pipe_hdl);
-        //No need to check req_hdl or IRP order as abort will cause them to dequeu out of order
+    expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_IRP_DONE);
+    //Wait for the IRPs to complete and dequeue them, then check results
+    for (int i = 0; i < NUM_IRPS; i++) {
+        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
+        TEST_ASSERT_NOT_EQUAL(NULL, irp);
         TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_COMPLETED || irp->status == USB_TRANSFER_STATUS_CANCELLED);
-        TEST_ASSERT_EQUAL(NULL, context);
+        TEST_ASSERT(irp->context == (void *)0xDEADBEEF);
     }
 
-    //Free transfer requests
-    free_pipe_and_xfer_reqs(default_pipe, req_hdls, data_buffers, irps, NUM_XFER_REQS);
+    //Free IRPs and default pipe
+    free_pipe_and_irp_list(default_pipe, NUM_IRPS, irp_list);
 
     vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
     wait_for_disconnection(port_hdl, port_evt_queue, false);
@@ -662,13 +633,13 @@ Test HCD pipe STALL condition, abort, and clear
 
 Purpose:
     - Test that a pipe can react to a STALL (i.e., a HCD_PIPE_EVENT_HALTED event)
-    - The HCD_PIPE_CMD_ABORT can retire all transfer requests
+    - The HCD_PIPE_CMD_ABORT can retire all IRPs
     - Pipe clear command can return the pipe to being active
 
 Procedure:
-    - Setup HCD and a port, a default pipe, and multiple transfer requests
-    - Corrupt the first transfer request, then enqueue all of them.
-    - The corrupted transfer request should trigger a STALL response from the endpoint
+    - Setup HCD and a port, a default pipe, and multiple IRPs
+    - Corrupt the first IRP, then enqueue all of them.
+    - The corrupted IRP should trigger a STALL response from the endpoint
     - Check that the correct pipe event, error, and state is returned from the pipe
     - Check that the other transfers can be retired using the abort command
     - Check that the halt can be cleared by using the clear command
@@ -684,24 +655,23 @@ TEST_CASE("Test HCD pipe STALL", "[hcd][ignore]")
     wait_for_connection(port_hdl, port_evt_queue);
     vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
 
-    //Allocate transfer requests
+    //Allocate default pipe and IRPs
     hcd_pipe_handle_t default_pipe;
-    hcd_xfer_req_handle_t req_hdls[NUM_XFER_REQS];
-    uint8_t *data_buffers[NUM_XFER_REQS];
-    usb_irp_t *irps[NUM_XFER_REQS];
-    alloc_pipe_and_xfer_reqs(port_hdl, pipe_evt_queue, &default_pipe, req_hdls, data_buffers, irps, NUM_XFER_REQS);
-    //Initialize transfer requests to send a "Get Device Descriptor" request
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        irps[i]->num_bytes = 64;    //1 worst case MPS
-        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *) data_buffers[i], 0, XFER_DATA_MAX_LEN);
-        irps[i]->data_buffer = data_buffers[i];
-        irps[i]->num_iso_packets = 0;
+    usb_irp_t **irp_list;
+    alloc_pipe_and_irp_list(port_hdl, pipe_evt_queue, NUM_IRPS, &default_pipe, &irp_list);
+
+    //Initialize IRPs to send a "Get Device Descriptor" request
+    for (int i = 0; i < NUM_IRPS; i++) {
+        irp_list[i]->num_bytes = 64;    //1 worst case MPS
+        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *) irp_list[i]->data_buffer, 0, TRANSFER_DATA_MAX_BYTES);
+        irp_list[i]->context = (void *)0xDEADBEEF;
     }
     //Corrupt first transfer so that it triggers a STALL
-    ((usb_ctrl_req_t *) data_buffers[0])->bRequest = 0xAA;
-    //Enqueue those transfer requests
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_xfer_req_enqueue(req_hdls[i]));
+    ((usb_ctrl_req_t *)irp_list[0]->data_buffer)->bRequest = 0xAA;
+
+    //Enqueue those IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
     }
     vTaskDelay(pdMS_TO_TICKS(100)); //Give some time for transfers to complete
 
@@ -709,47 +679,39 @@ TEST_CASE("Test HCD pipe STALL", "[hcd][ignore]")
     printf("Expecting STALL\n");
     expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_ERROR_STALL);
     TEST_ASSERT_EQUAL(HCD_PIPE_STATE_HALTED, hcd_pipe_get_state(default_pipe));
+
     //Call the pipe abort command to retire all transfers then dequeue all transfers
     TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_command(default_pipe, HCD_PIPE_CMD_ABORT));
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        hcd_xfer_req_handle_t req_hdl = hcd_xfer_req_dequeue(default_pipe);
-        hcd_pipe_handle_t pipe_hdl;
-        usb_irp_t *irp;
-        void *context;
-        hcd_xfer_req_get_target(req_hdl, &pipe_hdl, &irp, &context);
-        TEST_ASSERT_EQUAL(default_pipe, pipe_hdl);
-        TEST_ASSERT_EQUAL(irp, irps[i]);
+    //Dequeue IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
+        TEST_ASSERT_NOT_EQUAL(NULL, irp);
         TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_STALL || irp->status == USB_TRANSFER_STATUS_CANCELLED);
-        TEST_ASSERT_EQUAL(NULL, context);
+        TEST_ASSERT(irp->context == (void *)0xDEADBEEF);
     }
 
     //Call the clear command to un-stall the pipe
     TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_command(default_pipe, HCD_PIPE_CMD_CLEAR));
     TEST_ASSERT_EQUAL(HCD_PIPE_STATE_ACTIVE, hcd_pipe_get_state(default_pipe));
+
     //Correct first transfer then requeue
-    USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *) data_buffers[0], 0, XFER_DATA_MAX_LEN);
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_xfer_req_enqueue(req_hdls[i]));
+    USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *) irp_list[0]->data_buffer, 0, TRANSFER_DATA_MAX_BYTES);
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
     }
     vTaskDelay(pdMS_TO_TICKS(100)); //Give some time for transfers to complete
 
-    expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_XFER_REQ_DONE);
-    //Dequeue transfer requests and check results.
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        hcd_xfer_req_handle_t req_hdl = hcd_xfer_req_dequeue(default_pipe);
-        TEST_ASSERT_EQUAL(req_hdls[i], req_hdl);
-        hcd_pipe_handle_t pipe_hdl;
-        usb_irp_t *irp;
-        void *context;
-        hcd_xfer_req_get_target(req_hdl, &pipe_hdl, &irp, &context);
-        TEST_ASSERT_EQUAL(default_pipe, pipe_hdl);
-        TEST_ASSERT_EQUAL(irp, irps[i]);
-        TEST_ASSERT_EQUAL(USB_TRANSFER_STATUS_COMPLETED, irp->status);
-        TEST_ASSERT_EQUAL(NULL, context);
-    }
-
-    //Free transfer requests
-    free_pipe_and_xfer_reqs(default_pipe, req_hdls, data_buffers, irps, NUM_XFER_REQS);
+    //Wait for the IRPs to complete and dequeue them, then check results
+    for (int i = 0; i < NUM_IRPS; i++) {
+        expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_IRP_DONE);
+        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
+        TEST_ASSERT_NOT_EQUAL(NULL, irp);
+        TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_COMPLETED);
+        TEST_ASSERT(irp->context == (void *)0xDEADBEEF);
+    }
+    //Free IRPs
+    free_pipe_and_irp_list(default_pipe, NUM_IRPS, irp_list);
+
     vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
     wait_for_disconnection(port_hdl, port_evt_queue, false);
     teardown(port_evt_queue, pipe_evt_queue, port_hdl);
@@ -759,16 +721,16 @@ TEST_CASE("Test HCD pipe STALL", "[hcd][ignore]")
 Test Pipe runtime halt and clear
 
 Purpose:
-    - Test that a pipe can be halted with a command whilst there are ongoing transfer requests
+    - Test that a pipe can be halted with a command whilst there are ongoing IRPs
     - Test that a pipe can be un-halted with a HCD_PIPE_CMD_CLEAR
-    - Test that enqueued transfer requests are resumed when pipe is cleared
+    - Test that enqueued IRPs are resumed when pipe is cleared
 
 Procedure:
-    - Setup HCD, a default pipe, and multiple transfer requests
-    - Enqueue transfer requests but execute a HCD_PIPE_CMD_HALT command immediately after. Halt command should let on
-      the current going transfer request finish before actually halting the pipe.
-    - Clear the pipe halt using a HCD_PIPE_CMD_HALT command. Enqueued transfer requests will be resumed
-    - Check that all transfer requests have completed successfully.
+    - Setup HCD, a default pipe, and multiple IRPs
+    - Enqueue IRPs but execute a HCD_PIPE_CMD_HALT command immediately after. Halt command should let on
+      the current going IRP finish before actually halting the pipe.
+    - Clear the pipe halt using a HCD_PIPE_CMD_HALT command. Enqueued IRPs will be resumed
+    - Check that all IRPs have completed successfully.
     - Teardown
 */
 TEST_CASE("Test HCD pipe runtime halt and clear", "[hcd][ignore]")
@@ -780,24 +742,22 @@ TEST_CASE("Test HCD pipe runtime halt and clear", "[hcd][ignore]")
     wait_for_connection(port_hdl, port_evt_queue);
     vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
 
-    //Allocate transfer requests
+    //Allocate default pipe and IRPs
     hcd_pipe_handle_t default_pipe;
-    hcd_xfer_req_handle_t req_hdls[NUM_XFER_REQS];
-    uint8_t *data_buffers[NUM_XFER_REQS];
-    usb_irp_t *irps[NUM_XFER_REQS];
-    alloc_pipe_and_xfer_reqs(port_hdl, pipe_evt_queue, &default_pipe, req_hdls, data_buffers, irps, NUM_XFER_REQS);
+    usb_irp_t **irp_list;
+    alloc_pipe_and_irp_list(port_hdl, pipe_evt_queue, NUM_IRPS, &default_pipe, &irp_list);
 
-    //Initialize transfer requests to send a "Get Device Descriptor" request
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        irps[i]->num_bytes = 64;    //1 worst case MPS
-        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *) data_buffers[i], 0, XFER_DATA_MAX_LEN);
-        irps[i]->data_buffer = data_buffers[i];
-        irps[i]->num_iso_packets = 0;
+    //Initialize IRPs to send a "Get Device Descriptor" request
+    for (int i = 0; i < NUM_IRPS; i++) {
+        irp_list[i]->num_bytes = 64;    //1 worst case MPS
+        USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *)irp_list[i]->data_buffer, 0, TRANSFER_DATA_MAX_BYTES);
+        irp_list[i]->context = (void *)0xDEADBEEF;
     }
-    printf("Enqueuing transfer requests\n");
-    //Enqueue those transfer requests
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        TEST_ASSERT_EQUAL(ESP_OK, hcd_xfer_req_enqueue(req_hdls[i]));
+
+    printf("Enqueuing IRPs\n");
+    //Enqueue those IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(default_pipe, irp_list[i]));
     }
 
     //Halt the pipe immediately
@@ -805,28 +765,24 @@ TEST_CASE("Test HCD pipe runtime halt and clear", "[hcd][ignore]")
     TEST_ASSERT_EQUAL(HCD_PIPE_STATE_HALTED, hcd_pipe_get_state(default_pipe));
     printf("Pipe halted\n");
     vTaskDelay(pdMS_TO_TICKS(100)); //Give some time for current inflight transfer to complete
+
     //Clear command to un-halt the pipe
     TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_command(default_pipe, HCD_PIPE_CMD_CLEAR));
     TEST_ASSERT_EQUAL(HCD_PIPE_STATE_ACTIVE, hcd_pipe_get_state(default_pipe));
     printf("Pipe cleared\n");
     vTaskDelay(pdMS_TO_TICKS(100)); //Give some time pending for transfers to restart and complete
 
-    expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_XFER_REQ_DONE);
-    for (int i = 0; i < NUM_XFER_REQS; i++) {
-        hcd_xfer_req_handle_t req_hdl = hcd_xfer_req_dequeue(default_pipe);
-        TEST_ASSERT_EQUAL(req_hdls[i], req_hdl);
-        hcd_pipe_handle_t pipe_hdl;
-        usb_irp_t *irp;
-        void *context;
-        hcd_xfer_req_get_target(req_hdl, &pipe_hdl, &irp, &context);
-        TEST_ASSERT_EQUAL(default_pipe, pipe_hdl);
-        TEST_ASSERT_EQUAL(irp, irps[i]);
+    //Dequeue IRPs
+    for (int i = 0; i < NUM_IRPS; i++) {
+        expect_pipe_event(pipe_evt_queue, default_pipe, HCD_PIPE_EVENT_IRP_DONE);
+        usb_irp_t *irp = hcd_irp_dequeue(default_pipe);
+        TEST_ASSERT_NOT_EQUAL(NULL, irp);
         TEST_ASSERT(irp->status == USB_TRANSFER_STATUS_COMPLETED);
-        TEST_ASSERT_EQUAL(NULL, context);
+        TEST_ASSERT(irp->context == (void *)0xDEADBEEF);
     }
+    //Free IRPs
+    free_pipe_and_irp_list(default_pipe, NUM_IRPS, irp_list);
 
-    //Free transfer requests
-    free_pipe_and_xfer_reqs(default_pipe, req_hdls, data_buffers, irps, NUM_XFER_REQS);
     vTaskDelay(pdMS_TO_TICKS(100)); //Short delay send of SOF (for FS) or EOPs (for LS)
     wait_for_disconnection(port_hdl, port_evt_queue, false);
     teardown(port_evt_queue, pipe_evt_queue, port_hdl);
-- 
2.25.1


From cb897e20ac4d9e28bb0ac7129e65ad783d69e014 Mon Sep 17 00:00:00 2001
From: Darian Leung <darian@espressif.com>
Date: Thu, 11 Mar 2021 20:50:05 +0800
Subject: [PATCH 3/9] Add intr and isco HCD support - Changed internal impl to
 use multi buffering - All ctrl test cases passed - Still need to add tests
 for different types of pipes - Need to update docs

Signed-off-by: Li Bo <libo@espressif.com>
---
 components/hal/esp32s2/include/hal/usbh_hal.h |  321 ++--
 components/hal/esp32s2/include/hal/usbh_ll.h  |  116 +-
 components/hal/esp32s2/usbh_hal.c             |  162 +-
 components/hal/include/hal/usb_types.h        |   29 +
 components/usb/hcd.c                          | 1315 ++++++++++++-----
 components/usb/private_include/hcd.h          |    2 +-
 components/usb/private_include/usb.h          |   12 +-
 components/usb/test/test_hcd.c                |    3 +-
 8 files changed, 1317 insertions(+), 643 deletions(-)

diff --git a/components/hal/esp32s2/include/hal/usbh_hal.h b/components/hal/esp32s2/include/hal/usbh_hal.h
index 0a777f59d..c9772e35e 100644
--- a/components/hal/esp32s2/include/hal/usbh_hal.h
+++ b/components/hal/esp32s2/include/hal/usbh_hal.h
@@ -20,7 +20,7 @@ extern "C" {
 
 /*
 NOTE: Thread safety is the responsibility fo the HAL user. All USB Host HAL
-      functions should be called from critical sections unless specified otherwise
+      functions must be called from critical sections unless specified otherwise
 */
 
 #include <stdlib.h>
@@ -29,22 +29,31 @@ NOTE: Thread safety is the responsibility fo the HAL user. All USB Host HAL
 #include "soc/usb_wrap_struct.h"
 #include "hal/usbh_ll.h"
 #include "hal/usb_types.h"
+#include "esp_rom_sys.h"
 
-/* -----------------------------------------------------------------------------
-------------------------------- Macros and Types -------------------------------
------------------------------------------------------------------------------ */
+// ------------------------------------------------ Macros and Types ---------------------------------------------------
 
-// ---------------------------- Constants/Configs ------------------------------
+// ------------------ Constants/Configs --------------------
 
 #define USBH_HAL_DMA_MEM_ALIGN              512
+#define USBH_HAL_FRAME_LIST_MEM_ALIGN       512     //The frame list needs to be 512 bytes aligned (contrary to the databook)
 #define USBH_HAL_NUM_CHAN                   8
 #define USBH_HAL_XFER_DESC_SIZE             (sizeof(usbh_ll_dma_qtd_t))
+#define USBH_HAL_FIFO_TOTAL_USABLE_LINES    200     //Although we have a 256 lines, only 200 lines are usuable due to EPINFO_CTL
 
-// ------------------------------- HAL States ----------------------------------
+/**
+ * @brief FIFO size configuration structure
+ */
+typedef struct {
+    uint32_t rx_fifo_lines;                 /**< Size of the RX FIFO in terms the number of FIFO lines */
+    uint32_t nptx_fifo_lines;               /**< Size of the Non-periodic FIFO in terms the number of FIFO lines */
+    uint32_t ptx_fifo_lines;                /**< Size of the Periodic FIFO in terms the number of FIFO lines */
+} usbh_hal_fifo_config_t;
+
+// --------------------- HAL States ------------------------
 
 /**
  * @brief Channel states
- *
  */
 typedef enum {
     USBH_HAL_CHAN_STATE_HALTED = 0,         /**< The channel is halted. No transfer descriptor list is being executed */
@@ -52,7 +61,7 @@ typedef enum {
     USBH_HAL_CHAN_STATE_ERROR,              /**< The channel is in the error state */
 } usbh_hal_chan_state_t;
 
-// ------------------------------- HAL Events ----------------------------------
+// --------------------- HAL Events ------------------------
 
 /**
  * @brief Host port HAL events
@@ -72,13 +81,13 @@ typedef enum {
  * @brief Channel events
  */
 typedef enum {
-    USBH_HAL_CHAN_EVENT_SLOT_DONE,          /**< The channel has completed execution of an entire transfer descriptor list. Channel is now halted */
-    USBH_HAL_CHAN_EVENT_SLOT_HALT,          /**< The channel as completed execution of a single transfer descriptor in a list. Channel is now halted */
+    USBH_HAL_CHAN_EVENT_SLOT_HOC,           /**< The channel has completed execution of a transfer descriptor that had the HOC set. Channel is now halted */
     USBH_HAL_CHAN_EVENT_ERROR,              /**< The channel has encountered an error. Channel is now halted. */
     USBH_HAL_CHAN_EVENT_HALT_REQ,           /**< The channel has been successfully halted as requested */
+    USBH_HAL_CHAN_EVENT_NONE,               /**< No event (interrupt ran for internal processing) */
 } usbh_hal_chan_event_t;
 
-// ------------------------------- HAL Errors ----------------------------------
+// --------------------- HAL Errors ------------------------
 
 /**
  * @brief Channel errors
@@ -90,30 +99,28 @@ typedef enum {
     USBH_HAL_CHAN_ERROR_STALL,              /**< STALL response received */
 } usbh_hal_chan_error_t;
 
-// ----------------------- Transfer Descriptor Related -------------------------
+// ------------- Transfer Descriptor Related ---------------
 
 /**
  * @brief Flags used to describe the type of transfer descriptor to fill
  */
-#define USBH_HAL_XFER_DESC_FLAG_IN          0x01
-#define USBH_HAL_XFER_DESC_FLAG_SETUP       0x02
-#define USBH_HAL_XFER_DESC_FLAG_NULL        0x04
-#define USBH_HAL_XFER_DESC_FLAG_HALT        0x08
+#define USBH_HAL_XFER_DESC_FLAG_IN          0x01    /**< Indicates this transfer descriptor is of the IN direction */
+#define USBH_HAL_XFER_DESC_FLAG_SETUP       0x02    /**< Indicates this transfer descriptor is an OUT setup */
+#define USBH_HAL_XFER_DESC_FLAG_HOC         0x04    /**< Indicates that the channel will be halted after this transfer descriptor completes */
 
 /**
  * @brief Status value of a transfer descriptor
  *
- * A transfer descriptor's status remains unexecuted until the entire transfer
- * descriptor completes (either successfully or an error). Therefore, if a
- * channel halt is requested before a transfer descriptor completes, the
- * transfer descriptoor remains unexecuted.
+ * A transfer descriptor's status remains unexecuted until the entire transfer descriptor completes (either successfully
+ * or an error). Therefore, if a channel halt is requested before a transfer descriptor completes, the transfer
+ * descriptor remains unexecuted.
  */
 #define USBH_HAL_XFER_DESC_STS_SUCCESS      USBH_LL_QTD_STATUS_SUCCESS
 #define USBH_HAL_XFER_DESC_STS_PKTERR       USBH_LL_QTD_STATUS_PKTERR
 #define USBH_HAL_XFER_DESC_STS_BUFFER_ERR   USBH_LL_QTD_STATUS_BUFFER
 #define USBH_HAL_XFER_DESC_STS_NOT_EXECUTED USBH_LL_QTD_STATUS_NOT_EXECUTED
 
-// ------------------------------ Object Types ---------------------------------
+// -------------------- Object Types -----------------------
 
 /**
  * @brief Endpoint characteristics structure
@@ -131,6 +138,14 @@ typedef struct {
         };
         uint32_t val;
     };
+    union {
+        struct {
+            usb_hal_interval_t interval: 8;     /**< The interval of the endpoint */
+            uint32_t phase_offset_frames: 8;    /**< Phase offset in number of frames */
+            uint32_t reserved16: 16;
+        };
+        uint32_t val;
+    } periodic;                                 /**< Characteristic for periodic (interrupt/isochronous) endpoints only */
 } usbh_hal_ep_char_t;
 
 /**
@@ -143,29 +158,32 @@ typedef struct {
             uint32_t active: 1;             /**< The channel is enabled */
             uint32_t halt_requested: 1;     /**< A halt has been requested */
             uint32_t error_pending: 1;      /**< The channel is waiting for the error to be handled */
+            uint32_t reserved: 1;
             uint32_t chan_idx: 4;           /**< The index number of the channel */
-            uint32_t reserved25: 25;
+            usb_hal_xfer_type_t type: 2;    /**< The transfer type of the channel */
+            uint32_t reserved22: 22;
         };
         uint32_t val;
     } flags;                                /**< Flags regarding channel's status and information */
     usb_host_chan_regs_t *regs;             /**< Pointer to the channel's register set */
     usbh_hal_chan_error_t error;            /**< The last error that occurred on the channel */
     void *chan_ctx;                         /**< Context variable for the owner of the channel */
+#if 0
     //Transfer Descriptor List Slot
     struct {
         union {
             struct {
                 uint32_t slot_acquired: 1;  /**< The transfer descriptor list slot has been acquired */
                 uint32_t reserved7: 7;
-                uint32_t cur_qtd_idx: 8;    /**< Index of the first QTD in chain of QTDs being executed */
                 uint32_t qtd_list_len: 8;   /**< Length of QTD list in number of QTDs */
-                uint32_t reserved8: 8;
+                uint32_t reserved16: 16;
             };
             uint32_t val;
         } flags;
         void *owner_ctx;                    /**< Context variable for the owner of the slot */
         usbh_ll_dma_qtd_t *xfer_desc_list;  /**< Pointer to transfer descriptor list */
     } slot;
+#endif
 } usbh_hal_chan_t;
 
 /**
@@ -176,10 +194,15 @@ typedef struct {
     usbh_dev_t *dev;                            /**< Pointer to base address of DWC_OTG registers */
     usb_wrap_dev_t *wrap_dev;                   /**< Pointer to base address of USB Wrapper registers */
     //Host Port related
+    uint32_t *periodic_frame_list;              /**< Pointer to scheduling frame list */
     union {
         struct {
-            uint32_t dbnc_lock_enabled: 1;  /**< Debounce lock enabled */
-            uint32_t reserved31: 31;
+            uint32_t dbnc_lock_enabled: 1;      /**< Debounce lock enabled */
+            uint32_t fifo_sizes_set: 1;         /**< Whether the FIFO sizes have been set or not */
+            uint32_t periodic_sched_enabled: 1; /**< Periodic scheduling (for interrupt and isochronous transfers) is enabled */
+            uint32_t reserved: 5;
+            usb_hal_frame_list_len_t frame_list_len: 8; /**< Length of the periodic scheduling frame list */
+            uint32_t reserved16: 16;
         };
         uint32_t val;
     } flags;
@@ -191,9 +214,7 @@ typedef struct {
     } channels;
 } usbh_hal_context_t;
 
-/* -----------------------------------------------------------------------------
---------------------------------- Core (Global) --------------------------------
------------------------------------------------------------------------------ */
+// -------------------------------------------------- Core (Global) ----------------------------------------------------
 
 /**
  * @brief Initialize the HAL context and check if DWC_OTG is alive
@@ -219,7 +240,7 @@ void usbh_hal_init(usbh_hal_context_t *hal);
  * @brief Deinitialize the HAL context
  *
  * Entry:
- * - All channels should be properly disabled, and any pending events handled
+ * - All channels must be properly disabled, and any pending events handled
  * Exit:
  * - DWC_OTG global interrupt disabled
  * - HAL context deinitialized
@@ -231,13 +252,9 @@ void usbh_hal_deinit(usbh_hal_context_t *hal);
 /**
  * @brief Issue a soft reset to the controller
  *
- * This should be called when the host port encounters an error event or has
- * been disconnected. Before calling this, users are responsible for safely
- * freeing all channels as a soft reset will wipe all host port nd channel
- * registers.
- *
- * This function will result in the host port being put back into same state as
- * after calling usbh_hal_init().
+ * This should be called when the host port encounters an error event or has been disconnected. Before calling this,
+ * users are responsible for safely freeing all channels as a soft reset will wipe all host port and channel registers.
+ * This function will result in the host port being put back into same state as after calling usbh_hal_init().
  *
  * @note This has nothing to do with a USB bus reset. It simply resets the peripheral
  *
@@ -245,11 +262,24 @@ void usbh_hal_deinit(usbh_hal_context_t *hal);
  */
 void usbh_hal_core_soft_reset(usbh_hal_context_t *hal);
 
-/* -----------------------------------------------------------------------------
----------------------------------- Host Port ----------------------------------
------------------------------------------------------------------------------ */
+/**
+ * @brief Set FIFO sizes
+ *
+ * This function will set the sizes of each of the FIFOs (RX FIFO, Non-periodic TX FIFO, Periodic TX FIFO) and must be
+ * called at least once before allocating the channel. Based on the type of endpoints (and the endpionts' MPS), there
+ * may be situations where this function may need to be called again to resize the FIFOs. If resizing FIFOs dynamically,
+ * it is the user's responsibility to ensure there are no active channels when this function is called.
+ *
+ * @note The totol size of all the FIFOs must be less than or equal to USBH_HAL_FIFO_TOTAL_USABLE_LINES
+ *
+ * @param hal Context of the HAL layer
+ * @param fifo_config FIFO configuration
+ */
+void usbh_hal_set_fifo_size(usbh_hal_context_t *hal, const usbh_hal_fifo_config_t *fifo_config);
+
+// ---------------------------------------------------- Host Port ------------------------------------------------------
 
-// ---------------------------- Host Port Control ------------------------------
+// ------------------ Host Port Control --------------------
 
 /**
  * @brief Enable the host port's interrupt allowing port and channel events to occur
@@ -298,9 +328,8 @@ static inline void usbh_hal_port_toggle_power(usbh_hal_context_t *hal, bool powe
  * Exit:
  * - On release of the reset signal, a USBH_HAL_PORT_EVENT_ENABLED will be generated
  *
- * @note If the host port is already enabled, then issuing a reset will cause
- *       it be disabled and generate a USBH_HAL_PORT_EVENT_DISABLED event. The
- *       host port will not be enabled until the reset signal is released (thus
+ * @note If the host port is already enabled, then issuing a reset will cause it be disabled and generate a
+ *       USBH_HAL_PORT_EVENT_DISABLED event. The host port will not be enabled until the reset signal is released (thus
  *       generating the USBH_HAL_PORT_EVENT_ENABLED event)
  *
  * @param hal Context of the HAL layer
@@ -371,9 +400,8 @@ static inline void usbh_hal_port_toggle_resume(usbh_hal_context_t *hal, bool ena
 /**
  * @brief Check whether the resume signal is being driven
  *
- * If a remote wakeup event occurs, the core will automatically drive and clear
- * the resume signal for the required amount of time. Call this function to
- * check whether the resume signal has completed.
+ * If a remote wakeup event occurs, the core will automatically drive and clear the resume signal for the required
+ * amount of time. Call this function to check whether the resume signal has completed.
  *
  * @param hal Context of the HAL layer
  * @return true Resume signal is still being driven
@@ -384,7 +412,78 @@ static inline bool usbh_hal_port_check_resume(usbh_hal_context_t *hal)
     return usbh_ll_hprt_get_port_resume(hal->dev);
 }
 
-// -------------------------- Host Port Status/State ---------------------------
+// ---------------- Host Port Scheduling -------------------
+
+/**
+ * @brief Sets the periodic scheduling frame list
+ *
+ * @note This function must be called before attempting configuring any channels to be period via
+ *       usbh_hal_chan_set_ep_char()
+ *
+ * @param hal Context of the HAL layer
+ * @param frame_list Base address of the frame list
+ * @param frame_list_len Number of entries in the frame list (can only be 8, 16, 32, 64)
+ */
+static inline void usbh_hal_port_set_frame_list(usbh_hal_context_t *hal, uint32_t *frame_list, usb_hal_frame_list_len_t len)
+{
+    assert(!hal->flags.periodic_sched_enabled);
+    //Clear and save frame list
+    hal->periodic_frame_list = frame_list;
+    hal->flags.frame_list_len = len;
+}
+
+/**
+ * @brief Get the pointer to the periodic scheduling frame list
+ *
+ * @param hal Context of the HAL layer
+ * @return uint32_t* Base address of the periodic scheduling frame list
+ */
+static inline uint32_t *usbh_hal_port_get_frame_list(usbh_hal_context_t *hal)
+{
+    return hal->periodic_frame_list;
+}
+
+/**
+ * @brief Enable periodic scheduling
+ *
+ * @note The periodic frame list must be set via usbh_hal_port_set_frame_list() should be set before calling this function
+ * @note This function must be called before activating any periodic channels
+ *
+ * @param hal Context of the HAL layer
+ */
+static inline void usbh_hal_port_periodic_enable(usbh_hal_context_t *hal)
+{
+    assert(hal->periodic_frame_list != NULL && !hal->flags.periodic_sched_enabled);
+    usbh_ll_set_frame_list_base_addr(hal->dev, (uint32_t)hal->periodic_frame_list);
+    usbh_ll_hcfg_set_num_frame_list_entries(hal->dev, hal->flags.frame_list_len);
+    usbh_ll_hcfg_en_perio_sched(hal->dev);
+    hal->flags.periodic_sched_enabled = 1;
+}
+
+/**
+ * @brief Disable periodic scheduling
+ *
+ * Disabling periodic scheduling will save a bit of DMA bandwith (as the controller will no longer fetch the schedule
+ * from the frame list).
+ *
+ * @note Before disabling periodic scheduling, it is the user's responsibility to ensure that all periodic channels have
+ *       halted safely.
+ *
+ * @param hal Context of the HAL layer
+ */
+static inline void usbh_hal_port_periodic_disable(usbh_hal_context_t *hal)
+{
+    assert(hal->flags.periodic_sched_enabled);
+    usbh_ll_hcfg_dis_perio_sched(hal->dev);
+    hal->flags.periodic_sched_enabled = 0;
+}
+
+static inline uint32_t usbh_hal_port_get_cur_frame_num(usbh_hal_context_t *hal)
+{
+    return usbh_ll_get_frm_num(hal->dev);
+}
+
+// --------------- Host Port Status/State ------------------
 
 /**
  * @brief Check if a device is currently connected to the host port
@@ -423,7 +522,7 @@ static inline usb_hal_speed_t usbh_hal_port_get_conn_speed(usbh_hal_context_t *h
 /**
  * @brief Disable the debounce lock
  *
- * This function should be called after calling usbh_hal_port_check_if_connected()
+ * This function must be called after calling usbh_hal_port_check_if_connected()
  * and will allow connection/disconnection events to occur again. Any pending
  * connection or disconenction interrupts are cleared.
  *
@@ -439,11 +538,9 @@ static inline void usbh_hal_disable_debounce_lock(usbh_hal_context_t *hal)
     usb_ll_en_intrs(hal->dev, USB_LL_INTR_CORE_PRTINT | USB_LL_INTR_CORE_DISCONNINT);
 }
 
-/* -----------------------------------------------------------------------------
------------------------------------ Channel ------------------------------------
-------------------------------------------------------------------------------*/
+// ----------------------------------------------------- Channel -------------------------------------------------------
 
-// --------------------------- Channel Allocation ------------------------------
+// ----------------- Channel Allocation --------------------
 
 /**
  * @brief Allocate a channel
@@ -475,7 +572,7 @@ static inline void *usbh_hal_chan_get_context(usbh_hal_chan_t *chan_obj)
     return chan_obj->chan_ctx;
 }
 
-// ---------------------------- Channel Control --------------------------------
+// ------------------- Channel Control ---------------------
 
 /**
  * @brief Get the current state of a channel
@@ -502,10 +599,11 @@ static inline usbh_hal_chan_state_t usbh_hal_chan_get_state(usbh_hal_chan_t *cha
  * @note the channel must be in the disabled state in order to change its EP
  *       information
  *
+ * @param hal Context of the HAL layer
  * @param chan_obj Channel object
  * @param ep_char Endpoint characteristics
  */
-void usbh_hal_chan_set_ep_char(usbh_hal_chan_t *chan_obj, usbh_hal_ep_char_t *ep_char);
+void usbh_hal_chan_set_ep_char(usbh_hal_context_t *hal, usbh_hal_chan_t *chan_obj, usbh_hal_ep_char_t *ep_char);
 
 /**
  * @brief Set the direction of the channel
@@ -587,70 +685,97 @@ static inline void usbh_hal_chan_clear_error(usbh_hal_chan_t *chan_obj)
     chan_obj->flags.error_pending = 0;
 }
 
-/* -----------------------------------------------------------------------------
--------------------------- Transfer Descriptor List ----------------------------
-------------------------------------------------------------------------------*/
+// -------------------------------------------- Transfer Descriptor List -----------------------------------------------
 
 /**
  * @brief Fill a single entry in a transfer descriptor list
  *
- * - A single entry corresponds to a USB transfer in a particular direction
- *   (e.g., a BULK OUT).
- * - The channel will automatically split the transfer into multiple MPS sized
- *   packets of the endpoint.
- * - For multi direction transfers (such as the various stages of a control transfer),
- *   the direction and PID of channel must be managed manually. Set the
- *   USBH_HAL_XFER_DESC_FLAG_HALT flag to halt on each entry to flip the direction
- *   and PID of the channel.
- * - For IN transfer entries, set the USBH_HAL_XFER_DESC_FLAG_IN. The transfer
- *   size must also be an integer multiple of the endpoint's MPS
- *
- * @note The USBH_HAL_XFER_DESC_FLAG_HALT must be set on the last descriptor of
- *       the list so that an interrupt is generated at the end of the list
- * @note The USBH_HAL_XFER_DESC_FLAG_HALT can be set on every descriptor if users
- *       prefer to manually step through the list (such as change EP directions in between)
+ * - Depending on the transfer type, a single transfer descriptor may corresponds
+ *      - A stage of a transfer (for control transfers)
+ *      - A frame of a transfer interval (for interrupt and isoc)
+ *      - An entire transfer (for bulk transfers)
+ * - Check the various USBH_HAL_XFER_DESC_FLAG_ flags for filling a specific type of descriptor
+ * - For IN transfer entries, set the USBH_HAL_XFER_DESC_FLAG_IN. The transfer size must also be an integer multiple of
+ *   the endpoint's MPS
+ *
  * @note Critical section is not required for this function
  *
- * @param xfer_desc_list Transfer descriptor list
- * @param xfer_desc_idx Transfer descriptor index
+ * @param desc_list Transfer descriptor list
+ * @param desc_idx Transfer descriptor index
  * @param xfer_data_buff Transfer data buffer
  * @param xfer_len Transfer length
  * @param flags Transfer flags
  */
-static inline void usbh_hal_xfer_desc_fill(void *xfer_desc_list, int xfer_desc_idx, uint8_t *xfer_data_buff, int xfer_len, uint32_t flags)
+static inline void usbh_hal_xfer_desc_fill(void *desc_list, uint32_t desc_idx, uint8_t *xfer_data_buff, int xfer_len, uint32_t flags)
 {
-    //Check if the channel should be halted on completion of this xfer descriptor
-    bool halt_on_xfer_cplt = flags & USBH_HAL_XFER_DESC_FLAG_HALT;
-    usbh_ll_dma_qtd_t *qtd_list = (usbh_ll_dma_qtd_t *)xfer_desc_list;
-    if (flags & USBH_HAL_XFER_DESC_FLAG_NULL) {
-        usbh_ll_set_qtd_null(&qtd_list[xfer_desc_idx]);
-    } else if (flags & USBH_HAL_XFER_DESC_FLAG_IN) {
-        usbh_ll_set_qtd_in(&qtd_list[xfer_desc_idx], xfer_data_buff, xfer_len, halt_on_xfer_cplt);
+    usbh_ll_dma_qtd_t *qtd_list = (usbh_ll_dma_qtd_t *)desc_list;
+    if (flags & USBH_HAL_XFER_DESC_FLAG_IN) {
+        usbh_ll_set_qtd_in(&qtd_list[desc_idx],
+                           xfer_data_buff, xfer_len,
+                           flags & USBH_HAL_XFER_DESC_FLAG_HOC);
     } else {
-        usbh_ll_set_qtd_out(&qtd_list[xfer_desc_idx], xfer_data_buff, xfer_len, halt_on_xfer_cplt, (flags & USBH_HAL_XFER_DESC_FLAG_SETUP));
+        usbh_ll_set_qtd_out(&qtd_list[desc_idx],
+                            xfer_data_buff,
+                            xfer_len,
+                            flags & USBH_HAL_XFER_DESC_FLAG_HOC,
+                            flags & USBH_HAL_XFER_DESC_FLAG_SETUP);
     }
 }
 
 /**
- * @brief Parse a transfer decriptors results
+ * @brief Clear a transfer descriptor (sets all its fields to NULL)
+ *
+ * @param desc_list Transfer descriptor list
+ * @param desc_idx Transfer descriptor index
+ */
+static inline void usbh_hal_xfer_desc_clear(void *desc_list, uint32_t desc_idx)
+{
+    usbh_ll_dma_qtd_t *qtd_list = (usbh_ll_dma_qtd_t *)desc_list;
+    usbh_ll_set_qtd_null(&qtd_list[desc_idx]);
+}
+
+/**
+ * @brief Parse a transfer decriptor's results
  *
- * @param xfer_desc_list Transfer descriptor list
- * @param xfer_desc_idx Transfer descriptor index
+ * @param desc_list Transfer descriptor list
+ * @param desc_idx Transfer descriptor index
  * @param[out] xfer_rem_len Remaining length of the transfer in bytes
  * @param[out] xfer_status Status of the transfer
  *
  * @note Critical section is not required for this function
  */
-static inline void usbh_hal_xfer_desc_parse(void *xfer_desc_list, int xfer_desc_idx, int *xfer_rem_len, int *xfer_status)
+static inline void usbh_hal_xfer_desc_parse(void *desc_list, uint32_t desc_idx, int *xfer_rem_len, int *xfer_status)
 {
-    usbh_ll_dma_qtd_t *qtd_list = (usbh_ll_dma_qtd_t *)xfer_desc_list;
-    usbh_ll_get_qtd_status(&qtd_list[xfer_desc_idx], xfer_rem_len, xfer_status);
+    usbh_ll_dma_qtd_t *qtd_list = (usbh_ll_dma_qtd_t *)desc_list;
+    usbh_ll_get_qtd_status(&qtd_list[desc_idx], xfer_rem_len, xfer_status);
+    //Clear the QTD to prevent it from being read again
+    usbh_ll_set_qtd_null(&qtd_list[desc_idx]);
 }
 
-/* -----------------------------------------------------------------------------
--------------------------------- Channel Slot ----------------------------------
-------------------------------------------------------------------------------*/
+// -------------------------------------------------- Channel Slot -----------------------------------------------------
+
+static inline void usbh_hal_chan_activate(usbh_hal_chan_t *chan_obj, void *xfer_desc_list, int desc_list_len, int start_idx)
+{
+    //Cannot activate a channel that has already been enabled or is pending error handling
+    assert(!chan_obj->flags.active && !chan_obj->flags.error_pending);
+    //Set start address of the QTD list and starting QTD index
+    usbh_ll_chan_set_dma_addr_non_iso(chan_obj->regs, xfer_desc_list, start_idx);
+    usbh_ll_chan_set_qtd_list_len(chan_obj->regs, desc_list_len);
+    usbh_ll_chan_start(chan_obj->regs); //Start the channel
+    chan_obj->flags.active = 1;
+}
 
+/**
+ * @brief Get the current descriptor transfer descriptor index
+ *
+ * @param chan_obj Channel object
+ * @return int Descriptor index
+ */
+static inline int usbh_hal_chan_slot_get_cur_idx(usbh_hal_chan_t *chan_obj)
+{
+    return usbh_ll_chan_get_ctd(chan_obj->regs);
+}
+#if 0
 /**
  * @brief Acquire a slot
  *
@@ -668,7 +793,6 @@ static inline void usbh_hal_chan_slot_acquire(usbh_hal_chan_t *chan_obj, void *x
     assert(!chan_obj->slot.flags.slot_acquired);
     chan_obj->slot.xfer_desc_list = (usbh_ll_dma_qtd_t *)xfer_desc_list;
     chan_obj->slot.owner_ctx = owner_ctx;
-    chan_obj->slot.flags.cur_qtd_idx = 0;   //Start from the first descriptor
     chan_obj->slot.flags.qtd_list_len = desc_list_len;
     chan_obj->slot.flags.slot_acquired = 1;
     //Store the descriptor list length in the HCTSIZ register. Address of desc list is set when channel is activated
@@ -718,10 +842,11 @@ static inline void usbh_hal_chan_slot_release(usbh_hal_chan_t *chan_obj, void **
  * descriptor completes execution and has the HALT flag set, an event will be
  * generated.
  *
+ * @param hal Context of the HAL layer
  * @param chan_obj Channel object
  * @param num_to_skip Number of transfer descriptors to skip over
  */
-void usbh_hal_chan_activate(usbh_hal_chan_t *chan_obj, int num_to_skip);
+void usbh_hal_chan_activate(usbh_hal_context_t *hal, usbh_hal_chan_t *chan_obj, int num_to_skip);
 
 /**
  * @brief Get next transfer descriptor index
@@ -736,7 +861,7 @@ static inline int usbh_hal_chan_get_next_desc_index(usbh_hal_chan_t *chan_obj)
 {
     return chan_obj->slot.flags.cur_qtd_idx;
 }
-
+#endif
 /**
  * @brief Request to halt a channel
  *
@@ -756,9 +881,7 @@ static inline int usbh_hal_chan_get_next_desc_index(usbh_hal_chan_t *chan_obj)
  */
 bool usbh_hal_chan_slot_request_halt(usbh_hal_chan_t *chan_obj);
 
-/* -----------------------------------------------------------------------------
--------------------------------- Event Handling --------------------------------
------------------------------------------------------------------------------ */
+// ------------------------------------------------- Event Handling ----------------------------------------------------
 
 /**
  * @brief Decode global and host port interrupts
diff --git a/components/hal/esp32s2/include/hal/usbh_ll.h b/components/hal/esp32s2/include/hal/usbh_ll.h
index 13d609d93..0eec08955 100644
--- a/components/hal/esp32s2/include/hal/usbh_ll.h
+++ b/components/hal/esp32s2/include/hal/usbh_ll.h
@@ -159,16 +159,6 @@ typedef struct {
     uint8_t *buffer;
 } usbh_ll_dma_qtd_t;
 
-/*
- * Enumeration of different possible lengths of the periodic frame list
- */
-typedef enum {
-    USBH_LL_FRAME_LIST_LEN_8 = 0,
-    USBH_LL_FRAME_LIST_LEN_16,
-    USBH_LL_FRAME_LIST_LEN_32,
-    USBH_LL_FRAME_LIST_LEN_64,
-} usbh_ll_frame_list_len_t;
-
 /* -----------------------------------------------------------------------------
 ------------------------------ USB Wrap Registers ------------------------------
 ----------------------------------------------------------------------------- */
@@ -249,18 +239,33 @@ static inline bool usb_ll_check_dma_req_in_progress(usbh_dev_t *hw)
     return hw->grstctl_reg.dmareq;
 }
 
-static inline void usb_ll_flush_tx_fifo(usbh_dev_t *hw, uint32_t chan_num)
+static inline void usb_ll_flush_nptx_fifo(usbh_dev_t *hw)
 {
-    usb_grstctl_reg_t grstctl;
-    grstctl.val = hw->grstctl_reg.val;
-    grstctl.txfnum = chan_num;      //Set channel number to flush
-    grstctl.txfflsh = 1;            //Flush that channel's TX FIFO
-    hw->grstctl_reg.val = grstctl.val;
+    hw->grstctl_reg.txfnum = 0;     //Set the TX FIFO number to 0 to select the non-periodic TX FIFO
+    hw->grstctl_reg.txfflsh = 1;    //Flush the selected TX FIFO
+    //Wait for the flushing to complete
+    while (hw->grstctl_reg.txfflsh) {
+        ;
+    }
+}
+
+static inline void usb_ll_flush_ptx_fifo(usbh_dev_t *hw)
+{
+    hw->grstctl_reg.txfnum = 1;     //Set the TX FIFO number to 1 to select the periodic TX FIFO
+    hw->grstctl_reg.txfflsh = 1;    //FLush the select TX FIFO
+    //Wait for the flushing to complete
+    while (hw->grstctl_reg.txfflsh) {
+        ;
+    }
 }
 
 static inline void usb_ll_flush_rx_fifo(usbh_dev_t *hw)
 {
     hw->grstctl_reg.rxfflsh = 1;
+    //Wait for the flushing to complete
+    while (hw->grstctl_reg.rxfflsh) {
+        ;
+    }
 }
 
 static inline void usb_ll_reset_frame_counter(usbh_dev_t *hw)
@@ -320,20 +325,20 @@ static inline void usb_ll_dis_intrs(usbh_dev_t *hw, uint32_t intr_mask)
 
 // --------------------------- GRXFSIZ Register --------------------------------
 
-static inline void usb_ll_set_rx_fifo_size(usbh_dev_t *hw, uint32_t size)
+static inline void usb_ll_set_rx_fifo_size(usbh_dev_t *hw, uint32_t num_lines)
 {
     //Set size in words
-    hw->grxfsiz_reg.rxfdep = size;
+    hw->grxfsiz_reg.rxfdep = num_lines;
 }
 
 // -------------------------- GNPTXFSIZ Register -------------------------------
 
-static inline void usb_ll_set_nptx_fifo_size(usbh_dev_t *hw, uint32_t addr, uint32_t size)
+static inline void usb_ll_set_nptx_fifo_size(usbh_dev_t *hw, uint32_t addr, uint32_t num_lines)
 {
     usb_gnptxfsiz_reg_t gnptxfsiz;
     gnptxfsiz.val = hw->gnptxfsiz_reg.val;
     gnptxfsiz.nptxfstaddr = addr;
-    gnptxfsiz.nptxfdep = size;
+    gnptxfsiz.nptxfdep = num_lines;
     hw->gnptxfsiz_reg.val = gnptxfsiz.val;
 }
 
@@ -364,12 +369,12 @@ static inline void usb_ll_get_hardware_config(usbh_dev_t *hw, uint32_t *ghwcfg1,
 
 // --------------------------- HPTXFSIZ Register -------------------------------
 
-static inline void usbh_ll_set_ptx_fifo_size(usbh_dev_t *hw, uint32_t addr, uint32_t size)
+static inline void usbh_ll_set_ptx_fifo_size(usbh_dev_t *hw, uint32_t addr, uint32_t num_lines)
 {
     usb_hptxfsiz_reg_t hptxfsiz;
     hptxfsiz.val = hw->hptxfsiz_reg.val;
     hptxfsiz.ptxfstaddr = addr;
-    hptxfsiz.ptxfsize = size;
+    hptxfsiz.ptxfsize = num_lines;
     hw->hptxfsiz_reg.val = hptxfsiz.val;
 }
 
@@ -394,9 +399,24 @@ static inline void usbh_ll_hcfg_dis_perio_sched(usbh_dev_t *hw)
  *
  * @param num_entires Number of entires in the frame list
  */
-static inline void usbh_ll_hcfg_set_num_frame_list_entries(usbh_dev_t *hw, usbh_ll_frame_list_len_t num_entries)
-{
-    hw->hcfg_reg.frlisten = num_entries;
+static inline void usbh_ll_hcfg_set_num_frame_list_entries(usbh_dev_t *hw, usb_hal_frame_list_len_t num_entries)
+{
+    uint32_t frlisten;
+    switch (num_entries) {
+        case USB_HAL_FRAME_LIST_LEN_8:
+            frlisten = 0;
+            break;
+        case USB_HAL_FRAME_LIST_LEN_16:
+            frlisten = 1;
+            break;
+        case USB_HAL_FRAME_LIST_LEN_32:
+            frlisten = 2;
+            break;
+        default: //USB_HAL_FRAME_LIST_LEN_64
+            frlisten = 3;
+            break;
+    }
+    hw->hcfg_reg.frlisten = frlisten;
 }
 
 static inline void usbh_ll_hcfg_en_scatt_gatt_dma(usbh_dev_t *hw)
@@ -417,7 +437,8 @@ static inline void usbh_ll_hcfg_set_fsls_pclk_sel(usbh_dev_t *hw)
 /**
  * @brief Sets some default values to HCFG to operate in Host mode with scatter/gather DMA
  *
- * @param hw
+ * @param hw Start address of the USB Wrap registers
+ * @param speed Speed to initialize the host port at
  */
 static inline void usbh_ll_hcfg_set_defaults(usbh_dev_t *hw, usb_hal_speed_t speed)
 {
@@ -429,7 +450,8 @@ static inline void usbh_ll_hcfg_set_defaults(usbh_dev_t *hw, usb_hal_speed_t spe
           so the values of FSLSPclkSel and FrInt have to be adjusted accordingly.
     */
     hw->hcfg_reg.fslspclksel = (speed == USB_HAL_SPEED_FULL) ? 1 : 2;
-    hw->hcfg_reg.perschedena = 0;   //Disable perio sched
+    //By default we disable periodic scheduling. It can be enabled separately later
+    hw->hcfg_reg.perschedena = 0;
 }
 
 // ----------------------------- HFIR Register ---------------------------------
@@ -498,11 +520,27 @@ static inline void usbh_ll_haintmsk_dis_chan_intr(usbh_dev_t *hw, uint32_t mask)
 
 // --------------------------- HFLBAddr Register -------------------------------
 
+/**
+ * @brief Set the base address of the scheduling frame list
+ *
+ * @note For some reason, this address must be 512 bytes aligned or else a bunch of frames will not be scheduled when
+ *       the frame list rolls over. However, according to the databook, there is no mention of the HFLBAddr needing to
+ *       be aligned.
+ *
+ * @param hw Start address of the DWC_OTG registers
+ * @param addr Base address of the scheduling frame list
+ */
 static inline void usbh_ll_set_frame_list_base_addr(usbh_dev_t *hw, uint32_t addr)
 {
     hw->hflbaddr_reg.hflbaddr = addr;
 }
 
+/**
+ * @brief Get the base address of the scheduling frame list
+ *
+ * @param hw Start address of the DWC_OTG registers
+ * @return uint32_t Base address of the scheduling frame list
+ */
 static inline uint32_t usbh_ll_get_frame_list_base_addr(usbh_dev_t *hw)
 {
     return hw->hflbaddr_reg.hflbaddr;
@@ -519,6 +557,7 @@ static inline uint32_t usbh_ll_hprt_get_test_ctl(usbh_dev_t *hw)
 {
     return hw->hprt_reg.prttstctl;
 }
+
 static inline void usbh_ll_hprt_set_test_ctl(usbh_dev_t *hw, uint32_t test_mode)
 {
     usb_hprt_reg_t hprt;
@@ -594,6 +633,7 @@ static inline bool usbh_ll_hprt_get_port_resume(usbh_dev_t *hw)
 {
     return hw->hprt_reg.prtres;
 }
+
 static inline bool usbh_ll_hprt_get_port_overcur(usbh_dev_t *hw)
 {
     return hw->hprt_reg.prtovrcurract;
@@ -755,9 +795,7 @@ static inline void usbh_ll_chan_set_dma_addr_non_iso(volatile usb_host_chan_regs
 
 static inline void usbh_ll_chan_set_dma_addr_iso(volatile usb_host_chan_regs_t *chan,
                                                 void *dmaaddr,
-                                                uint32_t ntd,
-                                                uint32_t pktcnt,
-                                                uint32_t ctd)
+                                                uint32_t ntd)
 {
     int n;
     if (ntd == 2) {
@@ -836,15 +874,15 @@ static inline usb_host_chan_regs_t *usbh_ll_get_chan_regs(usbh_dev_t *dev, int c
  * @param data_buff Pointer to buffer containing the data to transfer
  * @param xfer_len Number of bytes in transfer. Setting 0 will do a zero length IN transfer.
  *                 Non zero length must be mulitple of the endpoint's MPS.
- * @param halt_on_cplt Generate a channel halted interrupt on completion of QTD
+ * @param hoc Halt on complete (will generate an interrupt and halt the channel)
  */
-static inline void usbh_ll_set_qtd_in(usbh_ll_dma_qtd_t *qtd, uint8_t *data_buff, int xfer_len, bool halt_on_cplt)
+static inline void usbh_ll_set_qtd_in(usbh_ll_dma_qtd_t *qtd, uint8_t *data_buff, int xfer_len, bool hoc)
 {
     qtd->buffer = data_buff;        //Set pointer to data buffer
     qtd->buffer_status_val = 0;     //Reset all flags to zero
     qtd->in_non_iso.xfer_size = xfer_len;
-    if (halt_on_cplt) {
-        qtd->in_non_iso.intr_cplt = 1;  //Used to indicate successful completion
+    if (hoc) {
+        qtd->in_non_iso.intr_cplt = 1;  //We need to set this to distinguish between a halt due to a QTD
         qtd->in_non_iso.eol = 1;        //Used to halt the channel at this qtd
     }
     qtd->in_non_iso.active = 1;
@@ -857,11 +895,11 @@ static inline void usbh_ll_set_qtd_in(usbh_ll_dma_qtd_t *qtd, uint8_t *data_buff
  * @param data_buff Pointer to buffer containing the data to transfer
  * @param xfer_len Number of bytes to transfer. Setting 0 will do a zero length transfer.
  *                 For ctrl setup packets, this should be set to 8.
- * @param halt_on_cplt Generate a channel halted interrupt on completion of QTD.
+ * @param hoc Halt on complete (will generate an interrupt)
  * @param is_setup Indicates whether this is a control transfer setup packet or a normal OUT Data transfer.
  *                 (As per the USB protocol, setup packets cannot be STALLd or NAKd by the device)
  */
-static inline void usbh_ll_set_qtd_out(usbh_ll_dma_qtd_t *qtd, uint8_t *data_buff, int xfer_len, bool halt_on_cplt, bool is_setup)
+static inline void usbh_ll_set_qtd_out(usbh_ll_dma_qtd_t *qtd, uint8_t *data_buff, int xfer_len, bool hoc, bool is_setup)
 {
     qtd->buffer = data_buff;        //Set pointer to data buffer
     qtd->buffer_status_val = 0;     //Reset all flags to zero
@@ -869,9 +907,9 @@ static inline void usbh_ll_set_qtd_out(usbh_ll_dma_qtd_t *qtd, uint8_t *data_buf
     if (is_setup) {
         qtd->out_non_iso.is_setup = 1;
     }
-    if (halt_on_cplt) {
-        qtd->out_non_iso.intr_cplt = 1;  //Used to indicate successful completion
-        qtd->out_non_iso.eol = 1;        //Used to halt the channel at this qtd
+    if (hoc) {
+        qtd->in_non_iso.intr_cplt = 1;  //We need to set this to distinguish between a halt due to a QTD
+        qtd->in_non_iso.eol = 1;        //Used to halt the channel at this qtd
     }
     qtd->out_non_iso.active = 1;
 }
diff --git a/components/hal/esp32s2/usbh_hal.c b/components/hal/esp32s2/usbh_hal.c
index b3b30942b..e90865d68 100644
--- a/components/hal/esp32s2/usbh_hal.c
+++ b/components/hal/esp32s2/usbh_hal.c
@@ -19,11 +19,9 @@
 #include "hal/usbh_hal.h"
 #include "hal/usbh_ll.h"
 
-/* -----------------------------------------------------------------------------
-------------------------------- Macros and Types -------------------------------
------------------------------------------------------------------------------ */
+// ------------------------------------------------ Macros and Types ---------------------------------------------------
 
-// -------------------------------- Constants ----------------------------------
+// ---------------------- Constants ------------------------
 
 #define CORE_REG_GSNPSID    0x4F54400A
 #define CORE_REG_GHWCFG1    0x00000000
@@ -31,33 +29,10 @@
 #define CORE_REG_GHWCFG3    0x00C804B5
 #define CORE_REG_GHWCFG4    0xD3F0A030
 
-// ------------------------------ Configurable ---------------------------------
+// -------------------- Configurable -----------------------
 
 #define CHAN_MAX_SLOTS      16
 
-/*
-FIFO lengths configured as follows:
-
-RXFIFO (Receive FIFO)
- - Recommended: (((LPS/4) + 2) * NUM_PACKETS)  + (NUM_CHAN * 2) + (NUM_BULK_CTRL * 1)
- - Actual: Assume (LPS = 64), (NUM_CHAN = 8), (NUM_BULK_CTRL = 8):
-NPTXFIFO (Non-periodic TX FIFO)
- - Recommended: (((LPS/4) + 2) * 2) Fit two largest packet sizes (and each packets overhead info)
- - Actual: Assume LPS is 64 (is the MPS for CTRL/BULK/INTR in FS)
-PTXFIFO (Periodic TX FIFO)
- - Recommended: ((LPS/4) + 2) * NUM_PACKETS
- - Actual: Assume a single LPS of 64 (quarter of ISO MPS), then 2 packets worth of overhead
-REGFIFO (Register storage)
- - Recommended: 4 * NUM_CHAN
- - Actual: Assume NUM_CHAN is 8
-*/
-#define HW_FIFO_LEN         256
-#define RX_FIFO_LEN         92
-#define NPTX_FIFO_LEN       36
-#define PTX_FIFO_LEN        72
-#define REG_FIFO_LEN        32
-_Static_assert((RX_FIFO_LEN + NPTX_FIFO_LEN + PTX_FIFO_LEN + REG_FIFO_LEN) <= HW_FIFO_LEN, "Sum of FIFO lengths not equal to HW_FIFO_LEN");
-
 /**
  * The following core interrupts will be enabled (listed LSB to MSB). Some of these
  * interrupts are enabled later than others.
@@ -111,11 +86,9 @@ _Static_assert((RX_FIFO_LEN + NPTX_FIFO_LEN + PTX_FIFO_LEN + REG_FIFO_LEN) <= HW
                                USBH_LL_INTR_CHAN_BNAINTR | \
                                USBH_LL_INTR_CHAN_XCS_XACT_ERR)
 
-/* -----------------------------------------------------------------------------
---------------------------------- Core (Global) --------------------------------
------------------------------------------------------------------------------ */
+// -------------------------------------------------- Core (Global) ----------------------------------------------------
 
-// ---------------------------- Private Functions ------------------------------
+// ------------------ Private Functions --------------------
 
 static void set_defaults(usbh_hal_context_t *hal)
 {
@@ -135,7 +108,7 @@ static void set_defaults(usbh_hal_context_t *hal)
     usb_ll_set_host_mode(hal->dev);
 }
 
-// ---------------------------- Public Functions -------------------------------
+// ------------------ Public Functions ---------------------
 
 void usbh_hal_init(usbh_hal_context_t *hal)
 {
@@ -172,15 +145,34 @@ void usbh_hal_core_soft_reset(usbh_hal_context_t *hal)
     //Set the default bits
     set_defaults(hal);
     //Clear all the flags and channels
+    hal->periodic_frame_list = NULL;
     hal->flags.val = 0;
     hal->channels.num_allocd = 0;
     hal->channels.chan_pend_intrs_msk = 0;
     memset(hal->channels.hdls, 0, sizeof(usbh_hal_chan_t *) * USBH_HAL_NUM_CHAN);
 }
 
-/* -----------------------------------------------------------------------------
----------------------------------- Host Port ----------------------------------
------------------------------------------------------------------------------ */
+void usbh_hal_set_fifo_size(usbh_hal_context_t *hal, const usbh_hal_fifo_config_t *fifo_config)
+{
+    assert((fifo_config->rx_fifo_lines + fifo_config->nptx_fifo_lines + fifo_config->ptx_fifo_lines) <= USBH_HAL_FIFO_TOTAL_USABLE_LINES);
+    //Check that none of the channels are active
+    for (int i = 0; i < USBH_HAL_NUM_CHAN; i++) {
+        if (hal->channels.hdls[i] != NULL) {
+            assert(!hal->channels.hdls[i]->flags.active);
+        }
+    }
+    //Set the new FIFO lengths
+    usb_ll_set_rx_fifo_size(hal->dev, fifo_config->rx_fifo_lines);
+    usb_ll_set_nptx_fifo_size(hal->dev, fifo_config->rx_fifo_lines, fifo_config->nptx_fifo_lines);
+    usbh_ll_set_ptx_fifo_size(hal->dev, fifo_config->rx_fifo_lines + fifo_config->nptx_fifo_lines, fifo_config->ptx_fifo_lines);
+    //Flush the FIFOs
+    usb_ll_flush_nptx_fifo(hal->dev);
+    usb_ll_flush_ptx_fifo(hal->dev);
+    usb_ll_flush_rx_fifo(hal->dev);
+    hal->flags.fifo_sizes_set = 1;
+}
+
+// ---------------------------------------------------- Host Port ------------------------------------------------------
 
 static inline void debounce_lock_enable(usbh_hal_context_t *hal)
 {
@@ -197,21 +189,15 @@ void usbh_hal_port_enable(usbh_hal_context_t *hal)
     //Todo: Set frame list entries and ena per sched
     //Configure HFIR
     usbh_ll_hfir_set_defaults(hal->dev, speed);
-    //Config FIFO sizes
-    usb_ll_set_rx_fifo_size(hal->dev, RX_FIFO_LEN);
-    usb_ll_set_nptx_fifo_size(hal->dev, RX_FIFO_LEN, NPTX_FIFO_LEN);
-    usbh_ll_set_ptx_fifo_size(hal->dev, RX_FIFO_LEN + NPTX_FIFO_LEN, PTX_FIFO_LEN);
 }
 
-/* -----------------------------------------------------------------------------
------------------------------------ Channel ------------------------------------
-------------------------------------------------------------------------------*/
+// ----------------------------------------------------- Channel -------------------------------------------------------
 
-// --------------------------- Channel Allocation ------------------------------
+// ----------------- Channel Allocation --------------------
 
-//Allocate a channel
 bool usbh_hal_chan_alloc(usbh_hal_context_t *hal, usbh_hal_chan_t *chan_obj, void *chan_ctx)
 {
+    assert(hal->flags.fifo_sizes_set);  //FIFO sizes should be set befor attempting to allocate a channel
     //Attempt to allocate channel
     if (hal->channels.num_allocd == USBH_HAL_NUM_CHAN) {
         return false;    //Out of free channels
@@ -241,22 +227,25 @@ bool usbh_hal_chan_alloc(usbh_hal_context_t *hal, usbh_hal_chan_t *chan_obj, voi
     return true;
 }
 
-//Returns object memory
 void usbh_hal_chan_free(usbh_hal_context_t *hal, usbh_hal_chan_t *chan_obj)
 {
+    if (chan_obj->flags.type == USB_HAL_XFER_TYPE_INTR || chan_obj->flags.type == USB_HAL_XFER_TYPE_ISOCHRONOUS) {
+        //Unschedule this channel
+        for (int i = 0; i < hal->flags.frame_list_len; i++) {
+            hal->periodic_frame_list[i] &= ~(1 << chan_obj->flags.chan_idx);
+        }
+    }
     //Can only free a channel when in the disabled state and descriptor list released
-    assert(!chan_obj->slot.flags.slot_acquired
-           && !chan_obj->flags.active
-           && !chan_obj->flags.error_pending);
+    assert(!chan_obj->flags.active && !chan_obj->flags.error_pending);
     //Deallocate channel
     hal->channels.hdls[chan_obj->flags.chan_idx] = NULL;
     hal->channels.num_allocd--;
     assert(hal->channels.num_allocd >= 0);
 }
 
-// ---------------------------- Channel Control --------------------------------
+// ------------------- Channel Control ---------------------
 
-void usbh_hal_chan_set_ep_char(usbh_hal_chan_t *chan_obj, usbh_hal_ep_char_t *ep_char)
+void usbh_hal_chan_set_ep_char(usbh_hal_context_t *hal, usbh_hal_chan_t *chan_obj, usbh_hal_ep_char_t *ep_char)
 {
     //Cannot change ep_char whilst channel is still active or in error
     assert(!chan_obj->flags.active && !chan_obj->flags.error_pending);
@@ -268,27 +257,21 @@ void usbh_hal_chan_set_ep_char(usbh_hal_chan_t *chan_obj, usbh_hal_ep_char_t *ep
                              ep_char->type,
                              ep_char->bEndpointAddress & USB_HAL_BENDPOINTADDRESS_DIR_MSK,
                              ep_char->ls_via_fs_hub);
+    //Save channel type
+    chan_obj->flags.type = ep_char->type;
+    //If this is a periodic endpoint/channel, set its schedule in the frame list
+    if (ep_char->type == USB_HAL_XFER_TYPE_ISOCHRONOUS || ep_char->type == USB_HAL_XFER_TYPE_INTR) {
+        assert((int)ep_char->periodic.interval <= (int)hal->flags.frame_list_len);    //Interval cannot exceed the length of the frame list
+        //Find the effective offset in the frame list (in case the phase_offset_frames > interval)
+        int offset = ep_char->periodic.phase_offset_frames % ep_char->periodic.interval;
+        //Schedule the channel in the framelist
+        for (int i = offset; i < hal->flags.frame_list_len; i+= ep_char->periodic.interval) {
+            hal->periodic_frame_list[i] |= 1 << chan_obj->flags.chan_idx;
+        }
+    }
 }
 
-/* -----------------------------------------------------------------------------
-------------------------------- Transfers Slots --------------------------------
-------------------------------------------------------------------------------*/
-
-void usbh_hal_chan_activate(usbh_hal_chan_t *chan_obj, int num_to_skip)
-{
-    //Cannot enable a channel that has already been enabled or is pending error handling
-    assert(!chan_obj->flags.active && !chan_obj->flags.error_pending);
-    assert(chan_obj->slot.flags.slot_acquired);
-    //Update the descriptor list index and check if it's within bounds
-    chan_obj->slot.flags.cur_qtd_idx += num_to_skip;
-    assert(chan_obj->slot.flags.cur_qtd_idx < chan_obj->slot.flags.qtd_list_len);
-    chan_obj->flags.active = 1;
-
-    //Set start address of the QTD list and starting QTD index
-    usbh_ll_chan_set_dma_addr_non_iso(chan_obj->regs, chan_obj->slot.xfer_desc_list, chan_obj->slot.flags.cur_qtd_idx);
-    //Start the channel
-    usbh_ll_chan_start(chan_obj->regs);
-}
+// ------------------------------------------------- Transfers Slots ---------------------------------------------------
 
 bool usbh_hal_chan_slot_request_halt(usbh_hal_chan_t *chan_obj)
 {
@@ -302,9 +285,7 @@ bool usbh_hal_chan_slot_request_halt(usbh_hal_chan_t *chan_obj)
     return true;
 }
 
-/* -----------------------------------------------------------------------------
--------------------------------- Event Handling --------------------------------
------------------------------------------------------------------------------ */
+// ------------------------------------------------- Event Handling ----------------------------------------------------
 
 //When a device on the port is no longer valid (e.g., disconnect, port error). All channels are no longer valid
 static void chan_all_halt(usbh_hal_context_t *hal)
@@ -381,12 +362,10 @@ usbh_hal_chan_event_t usbh_hal_chan_decode_intr(usbh_hal_chan_t *chan_obj)
 {
     uint32_t chan_intrs = usbh_ll_chan_intr_read_and_clear(chan_obj->regs);
     usbh_hal_chan_event_t chan_event;
-    //Currently, all cases where channel interrupts occur will also halt the channel, except for BNA
-    assert(chan_intrs & (USBH_LL_INTR_CHAN_CHHLTD | USBH_LL_INTR_CHAN_BNAINTR));
-    chan_obj->flags.active = 0;
-    //Note: Do not change the current checking order of checks. Certain interrupts (e.g., errors) have precedence over others
-    if (chan_intrs & CHAN_INTRS_ERROR_MSK) {  //One of the error interrupts has occurred.
+
+    if (chan_intrs & CHAN_INTRS_ERROR_MSK) {
         //Note: Errors are uncommon, so we check against the entire interrupt mask to reduce frequency of entering this call path
+        assert(chan_intrs & USBH_LL_INTR_CHAN_CHHLTD);  //An error should have halted the channel
         //Store the error in hal context
         usbh_hal_chan_error_t error;
         if (chan_intrs & USBH_LL_INTR_CHAN_STALL) {
@@ -400,25 +379,26 @@ usbh_hal_chan_event_t usbh_hal_chan_decode_intr(usbh_hal_chan_t *chan_obj)
         }
         //Update flags
         chan_obj->error = error;
+        chan_obj->flags.active = 0;
         chan_obj->flags.error_pending = 1;
         //Save the error to be handled later
         chan_event = USBH_HAL_CHAN_EVENT_ERROR;
-    } else if (chan_obj->flags.halt_requested) {    //A halt was previously requested and has not been fulfilled
-        chan_obj->flags.halt_requested = 0;
-        chan_event = USBH_HAL_CHAN_EVENT_HALT_REQ;
-    } else if (chan_intrs & USBH_LL_INTR_CHAN_XFERCOMPL) {
-        int cur_qtd_idx = usbh_ll_chan_get_ctd(chan_obj->regs);
-        //Store current qtd index
-        chan_obj->slot.flags.cur_qtd_idx = cur_qtd_idx;
-        if (cur_qtd_idx == 0) {
-            //If the transfer descriptor list has completed, the CTD index should be 0 (wrapped around)
-            chan_event = USBH_HAL_CHAN_EVENT_SLOT_DONE;
+    } else if (chan_intrs & USBH_LL_INTR_CHAN_CHHLTD) {
+        if (chan_obj->flags.halt_requested) {
+            chan_obj->flags.halt_requested = 0;
+            chan_event = USBH_HAL_CHAN_EVENT_HALT_REQ;
         } else {
-            chan_event = USBH_HAL_CHAN_EVENT_SLOT_HALT;
+            //Must have been halted due to QTD HOC
+            chan_event = USBH_HAL_CHAN_EVENT_SLOT_HOC;
         }
+        chan_obj->flags.active = 0;
+    } else if (chan_intrs & USBH_LL_INTR_CHAN_XFERCOMPL) {
+        //An transfer complete interrupt without the channel halting only occurs on receiving a short interrupt IN packet.
+        usbh_ll_chan_halt(chan_obj->regs);  //Halt the channel immediately to stop the transmission of the next packet
+        chan_event = USBH_HAL_CHAN_EVENT_NONE;
+        //After halting, we should cycle back and get a channel halted interrupt, which will be treated as HOC
     } else {
-        //Should never reach this point
-        abort();
+        abort();    //Should never reach this point
     }
     return chan_event;
 }
diff --git a/components/hal/include/hal/usb_types.h b/components/hal/include/hal/usb_types.h
index 3d5ffd5d0..e8c017938 100644
--- a/components/hal/include/hal/usb_types.h
+++ b/components/hal/include/hal/usb_types.h
@@ -55,6 +55,35 @@ typedef enum {
 #define USB_HAL_BENDPOINTADDRESS_NUM_MSK     0x0F
 #define USB_HAL_BENDPOINTADDRESS_DIR_MSK     0x80
 
+/**
+ * @brief Enumeration of different possible lengths of the periodic frame list
+ */
+typedef enum {
+    USB_HAL_FRAME_LIST_LEN_8 = 8,
+    USB_HAL_FRAME_LIST_LEN_16 = 16,
+    USB_HAL_FRAME_LIST_LEN_32 = 32,
+    USB_HAL_FRAME_LIST_LEN_64 = 64,
+} usb_hal_frame_list_len_t;
+
+/**
+ * @brief Transfer intervals for periodic channels/endpoints (Interrupt and Isochronous)
+ *
+ * The transfer interval of interrupt and isochronous channel/endpoint
+ *
+ * @note Interrupt endpoints can have bIntervals that are not powers of 2. However, for ease of implementation, the
+ *       effective interval will just get rounded down to the nearest power of 2. Therefore, an interrupt endpoint
+ *       may get polled more frequently than required.
+ */
+typedef enum {
+    USB_HAL_INTERVAL_1 = 1,
+    USB_HAL_INTERVAL_2 = 2,
+    USB_HAL_INTERVAL_4 = 4,
+    USB_HAL_INTERVAL_8 = 8,
+    USB_HAL_INTERVAL_16 = 16,
+    USB_HAL_INTERVAL_32 = 32,
+    USB_HAL_INTERVAL_64 = 64,
+} usb_hal_interval_t;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/components/usb/hcd.c b/components/usb/hcd.c
index 02055c094..54568b8d3 100644
--- a/components/usb/hcd.c
+++ b/components/usb/hcd.c
@@ -12,6 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+#include <stdint.h>
 #include <string.h>
 #include <sys/queue.h>
 #include "freertos/FreeRTOS.h"
@@ -22,40 +23,60 @@
 #include "esp_timer.h"
 #include "esp_err.h"
 #include "esp_rom_gpio.h"
+#include "hal/usb_types.h"
 #include "hal/usbh_hal.h"
 #include "soc/gpio_pins.h"
 #include "soc/gpio_sig_map.h"
 #include "driver/periph_ctrl.h"
 #include "usb.h"
-#include "hcd.h"
+#include "./private_include/hcd.h"
+#include "esp_rom_sys.h"
 
 // ----------------------------------------------------- Macros --------------------------------------------------------
 
 // --------------------- Constants -------------------------
 
+#define INIT_DELAY_MS                           30  //A delay of at least 25ms to enter Host mode. Make it 30ms to be safe
+#define DEBOUNCE_DELAY_MS                       250 //A debounce delay of 250ms
+#define RESET_HOLD_MS                           30  //Spec requires at least 10ms. Make it 30ms to be safe
+#define RESET_RECOVERY_MS                       30  //Reset recovery delay of 10ms (make it 30 ms to be safe) to allow for connected device to recover (and for port enabled interrupt to occur)
+#define RESUME_HOLD_MS                          30  //Spec requires at least 20ms, Make it 30ms to be safe
+#define RESUME_RECOVERY_MS                      20  //Resume recovery of at least 10ms. Make it 20 ms to be safe. This will include the 3 LS bit times of the EOP
+
+#define CTRL_EP_MAX_MPS_LS                      8   //Largest Maximum Packet Size for Low Speed control endpoints
+#define CTRL_EP_MAX_MPS_FS                      64  //Largest Maximum Packet Size for Full Speed control endpoints
+
+#define NUM_PORTS                               1   //The controller only has one port.
+
+// ----------------------- Configs -------------------------
+
 /**
- * @brief Number of transfer descriptors per transfer for various transfer types
+ * @brief Default FIFO sizes (see 2.1.2.4 for programming guide)
  *
- * Control: Requires 3 transfer descriptors for a single transfer
- *          corresponding to each stage of a control transfer
- * Bulk: Requires 1 transfer descriptor for each transfer
+ * RXFIFO
+ * - Recommended: ((LPS/4) * 2) + 2
+ * - Actual: Whatever leftover size: USBH_HAL_FIFO_TOTAL_USABLE_LINES - 48 - 48 = 104
+ * - Best case can accommodate two packets of 204 bytes
+ * NPTXFIFO
+ * - Recommended: (LPS/4) * 2
+ * - Actual: Assume LPS is 64, and 3 packets: (64/4) * 3 = 48
+ * PTXFIFO
+ * - Recommended: (LPS/4) * 2
+ * - Actual: Assume LPS is 64, and 3 packets: (64/4) * 3 = 48
  */
-#define NUM_DESC_PER_XFER_CTRL      3
-#define NUM_DESC_PER_XFER_BULK      1
-#define XFER_LIST_LEN_CTRL          1
-#define XFER_LIST_LEN_BULK          1
-
-#define INIT_DELAY_MS               30      //A delay of at least 25ms to enter Host mode. Make it 30ms to be safe
-#define DEBOUNCE_DELAY_MS           250     //A debounce delay of 250ms
-#define RESET_HOLD_MS               30      //Spec requires at least 10ms. Make it 30ms to be safe
-#define RESET_RECOVERY_MS           30      //Reset recovery delay of 10ms (make it 30 ms to be safe) to allow for connected device to recover (and for port enabled interrupt to occur)
-#define RESUME_HOLD_MS              30      //Spec requires at least 20ms, Make it 30ms to be safe
-#define RESUME_RECOVERY_MS          20      //Resume recovery of at least 10ms. Make it 20 ms to be safe. This will include the 3 LS bit times of the EOP
+const usbh_hal_fifo_config_t default_fifo_config = {
+    .rx_fifo_lines = 104,
+    .nptx_fifo_lines = 48,
+    .ptx_fifo_lines = 48,
+};
 
-#define CTRL_EP_MAX_MPS_LS          8       //Largest Maximum Packet Size for Low Speed control endpoints
-#define CTRL_EP_MAX_MPS_FS          64      //Largest Maximum Packet Size for Full Speed control endpoints
+#define FRAME_LIST_LEN                  USB_HAL_FRAME_LIST_LEN_32
+#define NUM_BUFFERS                     2
 
-#define NUM_PORTS                   1       //The controller only has one port.
+#define XFER_LIST_LEN_CTRL              3   //One descriptor for each stage
+#define XFER_LIST_LEN_BULK              2   //One descriptor for transfer, one to support an extra zero length packet
+#define XFER_LIST_LEN_INTR              32
+#define XFER_LIST_LEN_ISOC              FRAME_LIST_LEN  //Same length as the frame list makes it easier to schedule. Must be power of 2
 
 // ------------------------ Flags --------------------------
 
@@ -65,15 +86,14 @@
  * The IRP object has a reserved_flags member for host stack's internal use. The following flags will be set in
  * reserved_flags in order to keep track of state of an IRP within the HCD.
  */
-#define IRP_STATE_IDLE         0x0     //The IRP is not enqueued in an HCD pipe
-#define IRP_STATE_PENDING      0x1     //The IRP is enqueued and pending execution
-#define IRP_STATE_INFLIGHT     0x2     //The IRP is currently in flight
-#define IRP_STATE_DONE         0x3     //The IRP has completed execution or is retired, and is waiting to be dequeued
-#define IRP_STATE_MASK         0x3     //Bit mask of all the IRP state flagse
+#define IRP_STATE_IDLE                          0x0 //The IRP is not enqueued in an HCD pipe
+#define IRP_STATE_PENDING                       0x1 //The IRP is enqueued and pending execution
+#define IRP_STATE_INFLIGHT                      0x2 //The IRP is currently in flight
+#define IRP_STATE_DONE                          0x3 //The IRP has completed execution or is retired, and is waiting to be dequeued
+#define IRP_STATE_MASK                          0x3 //Bit mask of all the IRP state flagse
 #define IRP_STATE_SET(reserved_flags, state)    (reserved_flags = (reserved_flags & ~IRP_STATE_MASK) | state)
 #define IRP_STATE_GET(reserved_flags)           (reserved_flags & IRP_STATE_MASK)
 
-
 // -------------------- Convenience ------------------------
 
 #define HCD_ENTER_CRITICAL_ISR()    portENTER_CRITICAL_ISR(&hcd_lock)
@@ -93,11 +113,54 @@
             }                                                               \
 })
 
+#define MAX(a,b)            (((a) > (b)) ? (a) : (b))
+#define MIN(a,b)            (((a) < (b)) ? (a) : (b))
+
 // ------------------------------------------------------ Types --------------------------------------------------------
 
 typedef struct pipe_obj pipe_t;
 typedef struct port_obj port_t;
 
+typedef struct {
+    void *xfer_desc_list;
+    usb_irp_t *irp;
+    union {
+        struct {
+            uint32_t data_stg_in: 1;
+            uint32_t data_stg_skip: 1;
+            uint32_t cur_stg: 2;
+            uint32_t reserved28: 28;
+        } ctrl;
+        struct {
+            uint32_t zero_len_packet: 1;
+            uint32_t reserved31: 31;
+        } bulk;
+        struct {
+            uint32_t num_qtds: 8;
+            uint32_t reserved24: 24;
+        } intr;
+        struct {
+            uint32_t num_qtds: 8;
+            uint32_t interval: 8;
+            uint32_t irp_start_idx: 8;
+            uint32_t next_irp_start_idx: 8;
+        } isoc;
+        uint32_t val;
+    } flags;
+    union {
+        struct {
+            uint32_t stop_idx: 8;
+            uint32_t executing: 1;
+            uint32_t error_occurred: 1;
+            uint32_t cancelled: 1;
+            uint32_t reserved5: 5;
+            hcd_pipe_state_t pipe_state: 8;     //The pipe's state when the error occurred
+            hcd_pipe_event_t pipe_event: 8;     //The pipe event when the error occured
+        };
+        uint32_t val;
+    } status_flags;
+} dma_buffer_block_t;
+
 /**
  * @brief Object representing a pipe in the HCD layer
  */
@@ -107,15 +170,29 @@ struct pipe_obj {
     TAILQ_HEAD(tailhead_irp_done, usb_irp_obj) done_irp_tailq;
     int num_irp_pending;
     int num_irp_done;
-    usb_irp_t *inflight_irp;  //Pointer to the inflight IRP (i.e., the IRP currently being executed). NULL if none.
+    //Multi-buffer control
+    dma_buffer_block_t *buffers[NUM_BUFFERS];  //Double buffering scheme
+    union {
+        struct {
+            uint32_t buffer_num_to_fill: 2; //Number of buffers that can be filled
+            uint32_t buffer_num_to_exec: 2; //Number of buffers that are filled and need to be executed
+            uint32_t buffer_num_to_parse: 2;//Number of buffers completed execution and waiting to be parsed
+            uint32_t reserved2: 2;
+            uint32_t wr_idx: 1;             //Index of the next buffer to fill. Bit width must allow NUM_BUFFERS to wrap automatically
+            uint32_t rd_idx: 1;             //Index of the current buffer inflight. Bit width must allow NUM_BUFFERS to wrap automatically
+            uint32_t fr_idx: 1;             //Index of the next buffer to parse. Bit width must allow NUM_BUFFERS to wrap automatically
+            uint32_t buffer_is_executing: 1;//One of the buffers is in flight
+            uint32_t reserved20: 20;
+        };
+        uint32_t val;
+    } multi_buffer_flags;
+    //HAL related
+    usbh_hal_chan_t *chan_obj;
+    usbh_hal_ep_char_t ep_char;
     //Port related
     port_t *port;                       //The port to which this pipe is routed through
     TAILQ_ENTRY(pipe_obj) tailq_entry;  //TailQ entry for port's list of pipes
-    //HAl channel related
-    void *xfer_desc_list;
-    usbh_hal_chan_t *chan_obj;
-    usbh_hal_ep_char_t ep_char;
-    //Pipe status, state, and events
+    //Pipe status/state/events related
     hcd_pipe_state_t state;
     hcd_pipe_event_t last_event;
     TaskHandle_t task_waiting_pipe_notif;   //Task handle used for internal pipe events
@@ -124,15 +201,11 @@ struct pipe_obj {
             uint32_t waiting_xfer_done: 1;
             uint32_t paused: 1;
             uint32_t pipe_cmd_processing: 1;
-            //Flags only used by control transfers
-            uint32_t ctrl_data_stg_in: 1;
-            uint32_t ctrl_data_stg_skip: 1;
-            uint32_t reserved3: 3;
-            uint32_t xfer_desc_list_len: 8;
-            uint32_t reserved16: 16;
+            uint32_t is_active: 1;
+            uint32_t reserved28: 28;
         };
         uint32_t val;
-    } flags;
+    } cs_flags;
     //Pipe callback and context
     hcd_pipe_isr_callback_t callback;
     void *callback_arg;
@@ -144,6 +217,7 @@ struct pipe_obj {
  */
 struct port_obj {
     usbh_hal_context_t *hal;
+    void *frame_list;
     //Pipes routed through this port
     TAILQ_HEAD(tailhead_pipes_idle, pipe_obj) pipes_idle_tailq;
     TAILQ_HEAD(tailhead_pipes_queued, pipe_obj) pipes_active_tailq;
@@ -162,7 +236,8 @@ struct port_obj {
             uint32_t waiting_all_pipes_pause: 1;    //Waiting for all pipes routed through this port to be paused
             uint32_t disable_requested: 1;
             uint32_t conn_devc_ena: 1;      //Used to indicate the port is connected to a device that has been reset
-            uint32_t reserved10: 10;
+            uint32_t periodic_scheduling_enabled: 1;
+            uint32_t reserved9: 9;
             uint32_t num_pipes_waiting_pause: 16;
         };
         uint32_t val;
@@ -189,46 +264,179 @@ static hcd_obj_t *s_hcd_obj = NULL;     //Note: "s_" is for the static pointer
 
 // ------------------------------------------------- Forward Declare ---------------------------------------------------
 
-// ----------------------- Events --------------------------
+// ------------------- Buffer Control ----------------------
 
 /**
- * @brief Wait for an internal event from a port
+ * @brief Check if an inactive buffer can be filled with a pending IRP
  *
- * @note For each port, there can only be one thread/task waiting for an internal port event
- * @note This function is blocking (will exit and re-enter the critical section to do so)
+ * @param pipe Pipe object
+ * @return true There are one or more pending IRPs, and the inactive buffer is yet to be filled
+ * @return false Otherwise
+ */
+static inline bool _buffer_can_fill(pipe_t *pipe)
+{
+    //We can only fill if there are pending IRPs and at least one unfilled buffer
+    if (pipe->num_irp_pending > 0 && pipe->multi_buffer_flags.buffer_num_to_fill > 0) {
+        return true;
+    } else {
+        return false;
+    }
+}
+
+/**
+ * @brief Fill an empty buffer with
  *
- * @param port Port object
+ * This function will:
+ * - Remove an IRP from the pending tailq
+ * - Fill that IRP into the inactive buffer
+ *
+ * @note _buffer_can_fill() must return true before calling this function
+ *
+ * @param pipe Pipe object
  */
-static void _internal_port_event_wait(port_t *port);
+static void _buffer_fill(pipe_t *pipe);
 
 /**
- * @brief Notify (from an ISR context) the thread/task waiting for the internal port event
+ * @brief Check if there are more filled buffers than can be executed
  *
- * @param port Port object
- * @return true A yield is required
- * @return false Whether a yield is required or not
+ * @param pipe Pipe object
+ * @return true There are more filled buffers to be executed
+ * @return false No more buffers to execute
  */
-static bool _internal_port_event_notify_from_isr(port_t *port);
+static inline bool _buffer_can_exec(pipe_t *pipe)
+{
+    //We can only execute if there is not already a buffer executing and if there are filled buffers awaiting execution
+    if (!pipe->multi_buffer_flags.buffer_is_executing && pipe->multi_buffer_flags.buffer_num_to_exec > 0) {
+        return true;
+    } else {
+        return false;
+    }
+}
 
 /**
- * @brief Wait for an internal event from a particular pipe
+ * @brief Execute the next filled buffer
+ *
+ * - Must have called _buffer_can_exec() before calling this function
+ * - Will start the execution fo the buffer
+ *
+ * @param pipe Pipe object
+ */
+static void _buffer_exec(pipe_t *pipe);
+
+/**
+ * @brief Check if a buffer as completed execution
+ *
+ * This should only be called after receiving a USBH_HAL_CHAN_EVENT_SLOT_HOC event to check if a buffer is actually
+ * done. Buffers that aren't complete (such as Control transfers) will be continued automatically.
+ *
+ * @param pipe Pipe object
+ * @return true Buffer complete
+ * @return false Buffer not complete
+ */
+static bool _buffer_check_done(pipe_t *pipe);
+
+static inline void _buffer_done(pipe_t *pipe, int stop_idx)
+{
+    //Store the stop_idxd for later parsing
+    dma_buffer_block_t *buffer_done = pipe->buffers[pipe->multi_buffer_flags.rd_idx];
+    buffer_done->status_flags.executing = 0;
+    buffer_done->status_flags.error_occurred = 0;
+    buffer_done->status_flags.stop_idx = stop_idx;
+    pipe->multi_buffer_flags.rd_idx++;
+    pipe->multi_buffer_flags.buffer_num_to_exec--;
+    pipe->multi_buffer_flags.buffer_num_to_parse++;
+    pipe->multi_buffer_flags.buffer_is_executing = 0;
+}
+
+static inline void _buffer_done_error(pipe_t *pipe, int stop_idx, hcd_pipe_state_t pipe_state, hcd_pipe_event_t pipe_event, bool cancelled)
+{
+    //Mark the buffer as erroneous for later parsing
+    dma_buffer_block_t *buffer_done = pipe->buffers[pipe->multi_buffer_flags.rd_idx];
+    buffer_done->status_flags.executing = 0;
+    buffer_done->status_flags.error_occurred = 1;
+    buffer_done->status_flags.cancelled = cancelled;
+    buffer_done->status_flags.stop_idx = stop_idx;
+    buffer_done->status_flags.pipe_state = pipe_state;
+    buffer_done->status_flags.pipe_event = pipe_event;
+    pipe->multi_buffer_flags.rd_idx++;
+    pipe->multi_buffer_flags.buffer_num_to_exec--;
+    pipe->multi_buffer_flags.buffer_num_to_parse++;
+    pipe->multi_buffer_flags.buffer_is_executing = 0;
+}
+
+static inline bool _buffer_can_parse(pipe_t *pipe)
+{
+    if (pipe->multi_buffer_flags.buffer_num_to_parse > 0) {
+        return true;
+    } else {
+        return false;
+    }
+}
+
+/**
+ * @brief Parse a completed buffer
+ *
+ * This function will:
+ * - Parse the results of an IRP from a completed buffer
+ * - Put the IRP into the done tailq
+ *
+ * @note This function should only be called on the completion of a buffer
+ *
+ * @param pipe Pipe object
+ * @param stop_idx (For INTR pipes only) The index of the descriptor that follows the last descriptor of the IRP. Set to 0 otherwise
+ */
+static void _buffer_parse(pipe_t *pipe);
+
+static void _buffer_flush_all(pipe_t *pipe, bool cancelled);
+
+// ------------------------ Pipe ---------------------------
+
+/**
+ * @brief Wait until a pipe's inflight IRP is done
+ *
+ * If the pipe has an inflight IRP, this function will block until it is done (via a internal pipe event).
+ * If the pipe has no inflight IRP, this function do nothing and return immediately.
+ * If the pipe's state changes unexpectedely, this function will return false.
+ *
+ * Also parses all buffers on exit
  *
- * @note For each pipe, there can only be one thread/task waiting for an internal port event
  * @note This function is blocking (will exit and re-enter the critical section to do so)
  *
  * @param pipe Pipe object
+ * @return true Pipes inflight IRP is done
+ * @return false Pipes state unexpectedly changed
  */
-static void _internal_pipe_event_wait(pipe_t *pipe);
+static bool _pipe_wait_done(pipe_t *pipe);
 
 /**
- * @brief Notify (from an ISR context) the thread/task waiting for an internal pipe event
+ * @brief Retires all IRPs (those that were previously inflight or pending)
+ *
+ * Retiring all IRPs will result in any pending IRP being moved to the done tailq. This
+ * function will update the IPR status of each IRP.
+ *  - If the retiring is self-initiated (i.e., due to a pipe command), the IRP status will be set to USB_TRANSFER_STATUS_CANCELLED.
+ *  - If the retiring is NOT self-initiated (i.e., the pipe is no longer valid), the IRP status will be set to USB_TRANSFER_STATUS_NO_DEVICE
+ *
+ * Entry:
+ * - There can be no inflight IRP (must already be parsed and returned to done queue)
+ * - All buffers must be parsed
+ * Exit:
+ * - If there was an inflight IRP, it is parsed and returned to the done queue
+ * - If there are any pending IRPs:
+ *      - They are moved to the done tailq
  *
  * @param pipe Pipe object
- * @param from_isr Whether this is called from an ISR or not
- * @return true A yield is required
- * @return false Whether a yield is required or not. Always false when from_isr is also false
+ * @param cancelled Are we actively Pipe retire is initialized by the user due to a command, thus IRP are
+ *                  actively cancelled.
  */
-static bool _internal_pipe_event_notify(pipe_t *pipe, bool from_isr);
+static void _pipe_retire(pipe_t *pipe, bool self_initiated);
+
+/**
+ * @brief Decode a HAL channel error to the corresponding pipe event
+ *
+ * @param chan_error The HAL channel error
+ * @return hcd_pipe_event_t The corresponding pipe error event
+ */
+static inline hcd_pipe_event_t pipe_decode_error_event(usbh_hal_chan_error_t chan_error);
 
 // ------------------------ Port ---------------------------
 
@@ -363,119 +571,46 @@ static bool _port_disable(port_t *port);
  */
 static bool _port_debounce(port_t *port);
 
-// ------------------------ Pipe ---------------------------
-
-/**
- * @brief Get the next pending IRP from the pending tailq
- *
- * Entry:
- * - The inflight IRP must be set to NULL (indicating the pipe currently has no inflight IRP)
- * Exit:
- * - If (num_irp_pending > 0), the first IRP is removed from pending_irp_tailq and and
- *   inflight_irp is set to that IRP.
- * - If there are no more queued IRPs, inflight_irp is left as NULL
- *
- * @param pipe Pipe object
- * @return true A pending IRP is now set as the inflight IRP
- * @return false No more pending IRPs
- */
-static bool _pipe_get_next_irp(pipe_t *pipe);
-
-/**
- * @brief Return the pipe's current IRP (inflight_irp) to the done tailq
- *
- * Entry:
- *  - The inflight_irp must already have been parsed (i.e., results have been checked)
- * Exit:
- * - The IRP is returned to the done tailq and inflight_irp is set to NULL
- *
- * @param pipe Pipe object
- */
-static void _pipe_return_cur_irp(pipe_t *pipe);
+// ----------------------- Events --------------------------
 
 /**
- * @brief Wait until a pipe's inflight IRP is done
- *
- * If the pipe has an inflight IRP, this function will block until it is done (via a internal pipe event).
- * If the pipe has no inflight IRP, this function do nothing and return immediately.
- * If the pipe's state changes unexpectedely, this function will return false.
+ * @brief Wait for an internal event from a port
  *
+ * @note For each port, there can only be one thread/task waiting for an internal port event
  * @note This function is blocking (will exit and re-enter the critical section to do so)
  *
- * @param pipe Pipe object
- * @return true Pipes inflight IRP is done
- * @return false Pipes state unexpectedly changed
- */
-static bool _pipe_wait_done(pipe_t *pipe);
-
-/**
- * @brief Retires all IRPs (those that were previously inflight or pending)
- *
- * Retiring all IRPs will result in any pending IRP being moved to the done tailq. This
- * function will update the IPR status of each IRP.
- *  - If the retiring is self-initiated (i.e., due to a pipe command), the IRP status will be set to USB_TRANSFER_STATUS_CANCELLED.
- *  - If the retiring is NOT self-initiated (i.e., the pipe is no longer valid), the IRP status will be set to USB_TRANSFER_STATUS_NO_DEVICE
- *
- * Entry:
- * - There can be no inflight IRP (must already be parsed and returned to done queue)
- * Exit:
- * - If there was an inflight IRP, it is parsed and returned to the done queue
- * - If there are any pending IRPs:
- *      - They are moved to the done tailq
- *
- * @param pipe Pipe object
- * @param cancelled Are we actively Pipe retire is initialized by the user due to a command, thus IRP are
- *                  actively cancelled.
- */
-static void _pipe_retire(pipe_t *pipe, bool self_initiated);
-
-/**
- * @brief Decode a HAL channel error to the corresponding pipe event
- *
- * @param chan_error The HAL channel error
- * @return hcd_pipe_event_t The corresponding pipe error event
+ * @param port Port object
  */
-static inline hcd_pipe_event_t pipe_decode_error_event(usbh_hal_chan_error_t chan_error);
-
-// ----------------- Transfer Descriptors ------------------
+static void _internal_port_event_wait(port_t *port);
 
 /**
- * @brief Fill the inflight_irp into the pipe's transfer descriptor list
- *
- * Entry:
- *  - The pipe's inflight_irp must be set to the next IRP
- * Exit:
- *  - inflight_irp filled into the pipe's transfer descriptor list
- *  - Starting PIDs and directions set
- *  - Channel slot acquired. Will need to call usbh_hal_chan_activate() to actually start execution
+ * @brief Notify (from an ISR context) the thread/task waiting for the internal port event
  *
- * @param pipe Pipe where inflight_irp is already set to the next IRP
+ * @param port Port object
+ * @return true A yield is required
+ * @return false Whether a yield is required or not
  */
-static void _xfer_desc_list_fill(pipe_t *pipe);
+static bool _internal_port_event_notify_from_isr(port_t *port);
 
 /**
- * @brief Continue the execution of the transfer descriptor list
+ * @brief Wait for an internal event from a particular pipe
  *
- * @note This is currently only used for control transfers
+ * @note For each pipe, there can only be one thread/task waiting for an internal port event
+ * @note This function is blocking (will exit and re-enter the critical section to do so)
  *
  * @param pipe Pipe object
  */
-static void _xfer_desc_list_continue(pipe_t *pipe);
+static void _internal_pipe_event_wait(pipe_t *pipe);
 
 /**
- * @brief Parse the pipe's transfer descriptor list to fill the result of the transfers into the pipe's IRP
- *
- * Entry:
- *  - The pipe must have stop transferring either due a channel event or a port disconnection.
- *  - The pipe's state and last_event must be updated before parsing the IRP as they will used to determine the result
- *    of the IRP
- * Exit:
- *  - The pipe's inflight_irp is filled with result of the IRP (i.e., the underlying IRP has its status set)
+ * @brief Notify (from an ISR context) the thread/task waiting for an internal pipe event
  *
  * @param pipe Pipe object
- * @param error_occurred Are we parsing after the pipe had an error (or has become invalid)
+ * @param from_isr Whether this is called from an ISR or not
+ * @return true A yield is required
+ * @return false Whether a yield is required or not. Always false when from_isr is also false
  */
-static void _xfer_desc_list_parse(pipe_t *pipe, bool error_occurred);
+static bool _internal_pipe_event_notify(pipe_t *pipe, bool from_isr);
 
 // ----------------------------------------------- Interrupt Handling --------------------------------------------------
 
@@ -571,7 +706,7 @@ static hcd_port_event_t _intr_hdlr_hprt(port_t *port, usbh_hal_port_event_t hal_
         }
         case USBH_HAL_PORT_EVENT_ENABLED: {
             usbh_hal_port_enable(port->hal);  //Initialize remaining host port registers
-            port->speed = usbh_hal_port_get_conn_speed(port->hal);
+            port->speed = (usbh_hal_port_get_conn_speed(port->hal) == USB_HAL_SPEED_FULL) ? USB_SPEED_FULL : USB_SPEED_LOW;
             port->state = HCD_PORT_STATE_ENABLED;
             port->flags.conn_devc_ena = 1;
             //This was triggered by a command, so no event needs to be propagated.
@@ -631,42 +766,30 @@ static hcd_pipe_event_t _intr_hdlr_chan(pipe_t *pipe, usbh_hal_chan_t *chan_obj,
     if (!pipe->port->flags.conn_devc_ena) {
         return event;   //Treat as a no event.
     }
-
+    bool handle_waiting_xfer_done = false;
     switch (chan_event) {
-        case USBH_HAL_CHAN_EVENT_SLOT_DONE: {
-            //An entire transfer descriptor list has completed execution
+        case USBH_HAL_CHAN_EVENT_SLOT_HOC: {
+            if (!_buffer_check_done(pipe)) {
+                break;
+            }
             pipe->last_event = HCD_PIPE_EVENT_IRP_DONE;
-            event = HCD_PIPE_EVENT_IRP_DONE;
-            _xfer_desc_list_parse(pipe, false);    //Parse results of IRP
-            _pipe_return_cur_irp(pipe);    //Return the IRP to the pipe's done tailq
-            if (pipe->flags.waiting_xfer_done) {
-                //A port/pipe command is waiting for this pipe to complete its transfer. So don't load the next transfer
-                pipe->flags.waiting_xfer_done = 0;
-                if (pipe->port->flags.waiting_all_pipes_pause) {
-                    //Port command is waiting for all pipes to be paused
-                    pipe->flags.paused = 1;
-                    pipe->port->flags.num_pipes_waiting_pause--;
-                    if (pipe->port->flags.num_pipes_waiting_pause == 0) {
-                        //All pipes have finished pausing, Notify the blocked port command
-                        pipe->port->flags.waiting_all_pipes_pause = 0;
-                        *yield |= _internal_port_event_notify_from_isr(pipe->port);
-                    }
-                } else {
-                    //Pipe command is waiting for transfer to complete
-                    *yield |= _internal_pipe_event_notify(pipe, true);
-                }
-            } else if (_pipe_get_next_irp(pipe)) {
-                //Fill the descriptor list with the IRP and start the transfer
-                _xfer_desc_list_fill(pipe);
-                usbh_hal_chan_activate(chan_obj, 0);  //Start with the first descriptor
+            event = pipe->last_event;
+            //Mark the buffer as done
+            int stop_idx = usbh_hal_chan_slot_get_cur_idx(chan_obj);
+            _buffer_done(pipe, stop_idx);
+            //First check if there is another buffer we can execute
+            if (_buffer_can_exec(pipe) && !pipe->cs_flags.waiting_xfer_done) {
+                //If the next buffer is filled and ready to execute, execute it
+                _buffer_exec(pipe);
+            }
+            //Handle the previously done buffer
+            _buffer_parse(pipe);
+            if (pipe->cs_flags.waiting_xfer_done) {
+                handle_waiting_xfer_done = true;
+            } else if (_buffer_can_fill(pipe)) {
+                //Now that we've parsed a buffer, see if another IRP can be filled in its place
+                _buffer_fill(pipe);
             }
-            break;
-        }
-        case USBH_HAL_CHAN_EVENT_SLOT_HALT: {
-            //A transfer descriptor list has partially completed. This currently only happens on control pipes
-            assert(pipe->ep_char.type == USB_HAL_XFER_TYPE_CTRL);
-            _xfer_desc_list_continue(pipe);    //Continue the IRP.
-            //We are continuing a transfer, so no event has occurred
             break;
         }
         case USBH_HAL_CHAN_EVENT_ERROR: {
@@ -676,17 +799,41 @@ static hcd_pipe_event_t _intr_hdlr_chan(pipe_t *pipe, usbh_hal_chan_t *chan_obj,
             pipe->last_event = pipe_decode_error_event(chan_error);
             event = pipe->last_event;
             pipe->state = HCD_PIPE_STATE_HALTED;
-            //Parse the failed IRP and update it's IRP status
-            _xfer_desc_list_parse(pipe, true);
-            _pipe_return_cur_irp(pipe);    //Return the IRP to the pipe's done tailq
+            //Mark the buffer as done with an error
+            int stop_idx = usbh_hal_chan_slot_get_cur_idx(chan_obj);
+            _buffer_done_error(pipe, stop_idx, pipe->state, pipe->last_event, false);
+            //Parse the buffer
+            _buffer_parse(pipe);
+            if (pipe->cs_flags.waiting_xfer_done) {
+                handle_waiting_xfer_done = true;
+            }
             break;
         }
+        case USBH_HAL_CHAN_EVENT_NONE: {
+            break;  //Nothing to do
+        }
         case USBH_HAL_CHAN_EVENT_HALT_REQ:  //We currently don't halt request so this event should never occur
         default:
             abort();
             break;
     }
-
+    if (handle_waiting_xfer_done) {
+        //A port/pipe command is waiting for this pipe to complete its transfer. So don't load the next transfer
+        pipe->cs_flags.waiting_xfer_done = 0;
+        if (pipe->port->flags.waiting_all_pipes_pause) {
+            //Port command is waiting for all pipes to be paused
+            pipe->cs_flags.paused = 1;
+            pipe->port->flags.num_pipes_waiting_pause--;
+            if (pipe->port->flags.num_pipes_waiting_pause == 0) {
+                //All pipes have finished pausing, Notify the blocked port command
+                pipe->port->flags.waiting_all_pipes_pause = 0;
+                *yield |= _internal_port_event_notify_from_isr(pipe->port);
+            }
+        } else {
+            //Pipe command is waiting for transfer to complete
+            *yield |= _internal_pipe_event_notify(pipe, true);
+        }
+    }
     return event;
 }
 
@@ -747,16 +894,19 @@ static port_t *port_obj_alloc(void)
 {
     port_t *port = calloc(1, sizeof(port_t));
     usbh_hal_context_t *hal = malloc(sizeof(usbh_hal_context_t));
+    void *frame_list = heap_caps_aligned_calloc(USBH_HAL_FRAME_LIST_MEM_ALIGN, FRAME_LIST_LEN,sizeof(uint32_t), MALLOC_CAP_DMA);
     SemaphoreHandle_t port_mux = xSemaphoreCreateMutex();
-    if (port == NULL || hal == NULL || port_mux == NULL) {
+    if (port == NULL || hal == NULL || frame_list == NULL || port_mux == NULL) {
         free(port);
         free(hal);
+        free(frame_list);
         if (port_mux != NULL) {
             vSemaphoreDelete(port_mux);
         }
         return NULL;
     }
     port->hal = hal;
+    port->frame_list = frame_list;
     port->port_mux = port_mux;
     return port;
 }
@@ -767,6 +917,7 @@ static void port_obj_free(port_t *port)
         return;
     }
     vSemaphoreDelete(port->port_mux);
+    free(port->frame_list);
     free(port->hal);
     free(port);
 }
@@ -824,6 +975,7 @@ esp_err_t hcd_install(const hcd_config_t *config)
     esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ONE_INPUT, USB_OTG_AVALID_IN_IDX, false);
     HCD_EXIT_CRITICAL();
     return ESP_OK;
+
 err:
     if (intr_alloc_ret == ESP_OK) {
         esp_intr_free(p_hcd_obj_dmy->isr_hdl);
@@ -867,12 +1019,9 @@ static void _port_invalidate_all_pipes(port_t *port)
         //Mark the pipe as invalid and set an invalid event
         pipe->state = HCD_PIPE_STATE_INVALID;
         pipe->last_event = HCD_PIPE_EVENT_INVALID;
-        //If the pipe had an inflight transfer, parse and return it
-        if (pipe->inflight_irp != NULL) {
-            _xfer_desc_list_parse(pipe, true);
-            _pipe_return_cur_irp(pipe);
-        }
-        //Retire any remaining IRPs
+        //Flush all buffers that are still awaiting exec
+        _buffer_flush_all(pipe, false);
+        //Retire any remaining IRPs in the pending tailq
         _pipe_retire(pipe, false);
         if (pipe->task_waiting_pipe_notif != NULL) {
             //Unblock the thread/task waiting for a notification from the pipe as the pipe is no longer valid.
@@ -904,18 +1053,19 @@ static bool _port_pause_all_pipes(port_t *port)
     int num_pipes_waiting_done = 0;
     //Process all pipes that have queued IRPs
     TAILQ_FOREACH(pipe, &port->pipes_active_tailq, tailq_entry) {
-        if (pipe->inflight_irp != NULL) {
-            //Pipe has an inflight transfer. Indicate to the pipe we are waiting the transfer to complete
-            pipe->flags.waiting_xfer_done = 1;
+        //Check if pipe is currently executing
+        if (pipe->multi_buffer_flags.buffer_is_executing) {
+            //Pipe is executing a buffer. Indicate to the pipe we are waiting the buffer's transfer to complete
+            pipe->cs_flags.waiting_xfer_done = 1;
             num_pipes_waiting_done++;
         } else {
-            //No inflight transfer so no need to wait
-            pipe->flags.paused = 1;
+            //No buffer is being executed so need to wait
+            pipe->cs_flags.paused = 1;
         }
     }
     //Process all idle pipes. They don't have queue transfer so just mark them as paused
     TAILQ_FOREACH(pipe, &port->pipes_idle_tailq, tailq_entry) {
-        pipe->flags.paused = 1;
+        pipe->cs_flags.paused = 1;
     }
     if (num_pipes_waiting_done > 0) {
         //Indicate we need to wait for one or more pipes to complete their transfers
@@ -932,15 +1082,16 @@ static void _port_unpause_all_pipes(port_t *port)
     pipe_t *pipe;
     //Process all idle pipes. They don't have queue transfer so just mark them as un-paused
     TAILQ_FOREACH(pipe, &port->pipes_idle_tailq, tailq_entry) {
-        pipe->flags.paused = 0;
+        pipe->cs_flags.paused = 0;
     }
     //Process all pipes that have queued IRPs
     TAILQ_FOREACH(pipe, &port->pipes_active_tailq, tailq_entry) {
-        pipe->flags.paused = 0;
-        //If the pipe has more pending IRP, start them.
-        if (_pipe_get_next_irp(pipe)) {
-            _xfer_desc_list_fill(pipe);
-            usbh_hal_chan_activate(pipe->chan_obj, 0);
+        pipe->cs_flags.paused = 0;
+        if (_buffer_can_fill(pipe)) {
+            _buffer_fill(pipe);
+        }
+        if (_buffer_can_exec(pipe)) {
+            _buffer_exec(pipe);
         }
     }
 }
@@ -1149,7 +1300,17 @@ esp_err_t hcd_port_command(hcd_port_handle_t port_hdl, hcd_port_cmd_t command)
             case HCD_PORT_CMD_RESET: {
                 //Port can only a reset when it is in the enabled or disabled states (in case of new connection)
                 if (port->state == HCD_PORT_STATE_ENABLED || port->state == HCD_PORT_STATE_DISABLED) {
-                    ret = (_port_bus_reset(port)) ? ESP_OK : ESP_ERR_INVALID_RESPONSE;
+                    if (_port_bus_reset(port)) {
+                        //Set FIFO sizes to default
+                        usbh_hal_set_fifo_size(port->hal, &default_fifo_config);
+                        //Reset frame list and enable periodic scheduling
+                        memset(port->frame_list, FRAME_LIST_LEN, sizeof(uint32_t));
+                        usbh_hal_port_set_frame_list(port->hal, port->frame_list, FRAME_LIST_LEN);
+                        usbh_hal_port_periodic_enable(port->hal);
+                        ret = ESP_OK;
+                    } else {
+                        ret = ESP_ERR_INVALID_RESPONSE;
+                    }
                 }
                 break;
             }
@@ -1285,50 +1446,21 @@ void *hcd_port_get_ctx(hcd_port_handle_t port_hdl)
     return ret;
 }
 
+
 // --------------------------------------------------- HCD Pipes -------------------------------------------------------
 
 // ----------------------- Private -------------------------
 
-static bool _pipe_get_next_irp(pipe_t *pipe)
-{
-    assert(pipe->inflight_irp == NULL);
-    bool ret;
-    //This function assigns the next pending IRP to the inflight_irp
-    if (pipe->num_irp_pending > 0) {
-        //Set inflight_irp to the next pending IRP
-        pipe->inflight_irp = TAILQ_FIRST(&pipe->pending_irp_tailq);
-        TAILQ_REMOVE(&pipe->pending_irp_tailq, pipe->inflight_irp, tailq_entry);
-        pipe->num_irp_pending--;
-        //Update the IRP's current state
-        IRP_STATE_SET(pipe->inflight_irp->reserved_flags, IRP_STATE_INFLIGHT);
-        ret =  true;
-    } else {
-        ret = false;
-    }
-    return ret;
-}
-
-static void _pipe_return_cur_irp(pipe_t *pipe)
-{
-    assert(pipe->inflight_irp != NULL);
-    //Add the IRP to the pipe's done tailq
-    TAILQ_INSERT_TAIL(&pipe->done_irp_tailq, pipe->inflight_irp, tailq_entry);
-    //Update the IRP's current state
-    IRP_STATE_SET(pipe->inflight_irp->reserved_flags, IRP_STATE_DONE);
-    pipe->inflight_irp = NULL;
-    pipe->num_irp_done++;
-}
-
 static bool _pipe_wait_done(pipe_t *pipe)
 {
-    //Check if there is a currently inflight IRP
-    if (pipe->inflight_irp != NULL) {
+    //Check if the pipe has a currently executing buffer
+    if (pipe->multi_buffer_flags.buffer_is_executing) {
         //Wait for pipe to complete its transfer
-        pipe->flags.waiting_xfer_done = 1;
+        pipe->cs_flags.waiting_xfer_done = 1;
         _internal_pipe_event_wait(pipe);
         if (pipe->state == HCD_PIPE_STATE_INVALID) {
             //The pipe become invalid whilst waiting for its internal event
-            pipe->flags.waiting_xfer_done = 0;  //Need to manually reset this bit in this case
+            pipe->cs_flags.waiting_xfer_done = 0;  //Need to manually reset this bit in this case
             return false;
         }
         bool chan_halted = usbh_hal_chan_slot_request_halt(pipe->chan_obj);
@@ -1340,8 +1472,8 @@ static bool _pipe_wait_done(pipe_t *pipe)
 
 static void _pipe_retire(pipe_t *pipe, bool self_initiated)
 {
-    //Cannot have any inflight IRP
-    assert(pipe->inflight_irp == NULL);
+    //Cannot have a currently executing buffer
+    assert(!pipe->multi_buffer_flags.buffer_is_executing);
     if (pipe->num_irp_pending > 0) {
         //Process all remaining pending IRPs
         usb_irp_t *irp;
@@ -1378,6 +1510,43 @@ static inline hcd_pipe_event_t pipe_decode_error_event(usbh_hal_chan_error_t cha
     return event;
 }
 
+static dma_buffer_block_t *buffer_block_alloc(usb_transfer_type_t type)
+{
+    int desc_list_len;
+    switch (type) {
+    case USB_TRANSFER_TYPE_CTRL:
+        desc_list_len = XFER_LIST_LEN_CTRL;
+        break;
+    case USB_TRANSFER_TYPE_ISOCHRONOUS:
+        desc_list_len = XFER_LIST_LEN_ISOC;
+        break;
+    case USB_TRANSFER_TYPE_BULK:
+        desc_list_len = XFER_LIST_LEN_BULK;
+        break;
+    default:    //USB_TRANSFER_TYPE_INTR:
+        desc_list_len = XFER_LIST_LEN_INTR;
+        break;
+    }
+    dma_buffer_block_t *buffer = calloc(1, sizeof(dma_buffer_block_t));
+    void *xfer_desc_list = heap_caps_aligned_calloc(USBH_HAL_FRAME_LIST_MEM_ALIGN, desc_list_len, sizeof(usbh_ll_dma_qtd_t), MALLOC_CAP_DMA);
+    if (buffer == NULL || xfer_desc_list == NULL) {
+        free(buffer);
+        heap_caps_free(xfer_desc_list);
+        return NULL;
+    }
+    buffer->xfer_desc_list = xfer_desc_list;
+    return buffer;
+}
+
+static void buffer_block_free(dma_buffer_block_t *buffer)
+{
+    if (buffer == NULL) {
+        return;
+    }
+    heap_caps_free(buffer->xfer_desc_list);
+    free(buffer);
+}
+
 // ----------------------- Public --------------------------
 
 esp_err_t hcd_pipe_alloc(hcd_port_handle_t port_hdl, const hcd_pipe_config_t *pipe_config, hcd_pipe_handle_t *pipe_hdl)
@@ -1397,46 +1566,40 @@ esp_err_t hcd_pipe_alloc(hcd_port_handle_t port_hdl, const hcd_pipe_config_t *pi
     usb_transfer_type_t type;
     bool is_default_pipe;
     if (pipe_config->ep_desc == NULL) {  //A NULL ep_desc indicates we are allocating a default pipe
-        type = USB_XFER_TYPE_CTRL;
+        type = USB_TRANSFER_TYPE_CTRL;
         is_default_pipe = true;
     } else {
         type = USB_DESC_EP_GET_XFERTYPE(pipe_config->ep_desc);
         is_default_pipe = false;
     }
-    size_t num_xfer_desc = 0;
-    switch (type) {
-        case USB_XFER_TYPE_CTRL: {
-            num_xfer_desc = XFER_LIST_LEN_CTRL * NUM_DESC_PER_XFER_CTRL;
-            break;
-        }
-        case USB_XFER_TYPE_BULK: {
-            if (pipe_config->dev_speed == USB_SPEED_LOW) {
-                return ESP_ERR_NOT_SUPPORTED;   //Low speed devices do not support bulk transfers
-            }
-            num_xfer_desc = XFER_LIST_LEN_BULK * NUM_DESC_PER_XFER_BULK;
-            break;
-        }
-        default: {
-            //Isochronous and Interrupt pipes currently not supported
-            return ESP_ERR_NOT_SUPPORTED;
-        }
+
+    if (pipe_config->dev_speed == USB_SPEED_LOW && (type == USB_TRANSFER_TYPE_BULK || type == USB_TRANSFER_TYPE_ISOCHRONOUS)) {
+        return ESP_ERR_NOT_SUPPORTED;   //Low speed devices do not support isochronous or bulk transfers
     }
 
     //Allocate the pipe resources
     pipe_t *pipe = calloc(1, sizeof(pipe_t));
-    usbh_hal_chan_t *chan_obj = malloc(sizeof(usbh_hal_chan_t));
-    void *xfer_desc_list = heap_caps_aligned_calloc(USBH_HAL_DMA_MEM_ALIGN, num_xfer_desc, USBH_HAL_XFER_DESC_SIZE, MALLOC_CAP_DMA);
-    if (pipe == NULL|| chan_obj == NULL || xfer_desc_list == NULL) {
+    usbh_hal_chan_t *chan_obj = calloc(1, sizeof(usbh_hal_chan_t));
+    dma_buffer_block_t *buffers[NUM_BUFFERS] = {0};
+    if (pipe == NULL|| chan_obj == NULL) {
         ret = ESP_ERR_NO_MEM;
         goto err;
     }
+    for (int i = 0; i < NUM_BUFFERS; i++) {
+        buffers[i] = buffer_block_alloc(type);
+        if (buffers[i] == NULL) {
+            goto err;
+        }
+    }
 
     //Initialize pipe object
     TAILQ_INIT(&pipe->pending_irp_tailq);
     TAILQ_INIT(&pipe->done_irp_tailq);
+    for (int i = 0; i < NUM_BUFFERS; i++) {
+        pipe->buffers[i] = buffers[i];
+    }
+    pipe->multi_buffer_flags.buffer_num_to_fill = NUM_BUFFERS;
     pipe->port = port;
-    pipe->xfer_desc_list = xfer_desc_list;
-    pipe->flags.xfer_desc_list_len = num_xfer_desc;
     pipe->chan_obj = chan_obj;
     //The HAL transfer type is the same as the USB transfer type so we just cast it
     pipe->ep_char.type = (usb_hal_xfer_type_t)type;
@@ -1450,6 +1613,35 @@ esp_err_t hcd_pipe_alloc(hcd_port_handle_t port_hdl, const hcd_pipe_config_t *pi
     }
     pipe->ep_char.dev_addr = pipe_config->dev_addr;
     pipe->ep_char.ls_via_fs_hub = (port_speed == USB_SPEED_FULL && pipe_config->dev_speed == USB_SPEED_LOW);
+    if (type == USB_TRANSFER_TYPE_INTR || type == USB_TRANSFER_TYPE_ISOCHRONOUS) {
+        //Round the interval down
+        int interval;
+        if (type == USB_TRANSFER_TYPE_ISOCHRONOUS) {
+            assert(pipe_config->ep_desc->bInterval > 0 && pipe_config->ep_desc->bInterval <= 16);
+            interval = (1 << (pipe_config->ep_desc->bInterval - 1));
+        } else {
+            assert(pipe_config->ep_desc->bInterval > 0 && pipe_config->ep_desc->bInterval <= 255);
+            interval = pipe_config->ep_desc->bInterval;
+        }
+        if (interval >= 32) {
+            pipe->ep_char.periodic.interval = 32;
+        } else if (interval >= 16) {
+            pipe->ep_char.periodic.interval = 16;
+        } else if (interval >= 8) {
+            pipe->ep_char.periodic.interval = 8;
+        } else if (interval >= 4) {
+            pipe->ep_char.periodic.interval = 4;
+        } else if (interval >= 2) {
+            pipe->ep_char.periodic.interval = 2;
+        } else if (interval >= 1) {
+            pipe->ep_char.periodic.interval = 1;
+        } else {
+            abort();
+        }
+        //For now, we just phase offset everything by their channel number
+        //Todo: Use a smarter load balancing scheduling algorithm
+        pipe->ep_char.periodic.phase_offset_frames = port->num_pipes_idle + port->num_pipes_queued; //We are the Nth pipe allocate, use that as an idex
+    }
     pipe->state = HCD_PIPE_STATE_ACTIVE;
     pipe->callback = pipe_config->callback;
     pipe->callback_arg = pipe_config->callback_arg;
@@ -1468,7 +1660,7 @@ esp_err_t hcd_pipe_alloc(hcd_port_handle_t port_hdl, const hcd_pipe_config_t *pi
         ret = ESP_ERR_NOT_SUPPORTED;
         goto err;
     }
-    usbh_hal_chan_set_ep_char(pipe->chan_obj, &pipe->ep_char);
+    usbh_hal_chan_set_ep_char(port->hal, pipe->chan_obj, &pipe->ep_char);
 
     //Add the pipe to the list of idle pipes in the port object
     TAILQ_INSERT_TAIL(&port->pipes_idle_tailq, pipe, tailq_entry);
@@ -1478,7 +1670,9 @@ esp_err_t hcd_pipe_alloc(hcd_port_handle_t port_hdl, const hcd_pipe_config_t *pi
     return ret;
 
 err:
-    free(xfer_desc_list);
+    for (int i = 0; i < NUM_BUFFERS; i++) {
+        buffer_block_free(buffers[i]);
+    }
     free(chan_obj);
     free(pipe);
     return ret;
@@ -1489,7 +1683,9 @@ esp_err_t hcd_pipe_free(hcd_pipe_handle_t pipe_hdl)
     pipe_t *pipe = (pipe_t *)pipe_hdl;
     HCD_ENTER_CRITICAL();
     //Check that all IRPs have been removed and pipe has no pending events
-    HCD_CHECK_FROM_CRIT(pipe->inflight_irp == NULL
+    HCD_CHECK_FROM_CRIT(!pipe->multi_buffer_flags.buffer_is_executing
+                        && pipe->multi_buffer_flags.buffer_num_to_parse == 0
+                        && pipe->multi_buffer_flags.buffer_num_to_exec == 0
                         && pipe->num_irp_pending == 0
                         && pipe->num_irp_done == 0,
                         ESP_ERR_INVALID_STATE);
@@ -1500,7 +1696,9 @@ esp_err_t hcd_pipe_free(hcd_pipe_handle_t pipe_hdl)
     HCD_EXIT_CRITICAL();
 
     //Free pipe resources
-    free(pipe->xfer_desc_list);
+    for (int i = 0; i < NUM_BUFFERS; i++) {
+        buffer_block_free(pipe->buffers[i]);
+    }
     free(pipe->chan_obj);
     free(pipe);
     return ESP_OK;
@@ -1512,14 +1710,14 @@ esp_err_t hcd_pipe_update(hcd_pipe_handle_t pipe_hdl, uint8_t dev_addr, int mps)
     HCD_ENTER_CRITICAL();
     //Check if pipe is in the correct state to be updated
     HCD_CHECK_FROM_CRIT(pipe->state != HCD_PIPE_STATE_INVALID
-                        && !pipe->flags.pipe_cmd_processing
+                        && !pipe->cs_flags.pipe_cmd_processing
                         && pipe->num_irp_pending == 0
                         && pipe->num_irp_done == 0,
                         ESP_ERR_INVALID_STATE);
     //Check that all IRPs have been removed and pipe has no pending events
     pipe->ep_char.dev_addr = dev_addr;
     pipe->ep_char.mps = mps;
-    usbh_hal_chan_set_ep_char(pipe->chan_obj, &pipe->ep_char);
+    usbh_hal_chan_set_ep_char(pipe->port->hal, pipe->chan_obj, &pipe->ep_char);
     HCD_EXIT_CRITICAL();
     return ESP_OK;
 }
@@ -1558,17 +1756,17 @@ esp_err_t hcd_pipe_command(hcd_pipe_handle_t pipe_hdl, hcd_pipe_cmd_t command)
 
     HCD_ENTER_CRITICAL();
     //Cannot execute pipe commands the pipe is already executing a command, or if the pipe or its port are no longer valid
-    if (pipe->flags.pipe_cmd_processing || !pipe->port->flags.conn_devc_ena || pipe->state == HCD_PIPE_STATE_INVALID) {
+    if (pipe->cs_flags.pipe_cmd_processing || !pipe->port->flags.conn_devc_ena || pipe->state == HCD_PIPE_STATE_INVALID) {
         ret = ESP_ERR_INVALID_STATE;
     } else {
-        pipe->flags.pipe_cmd_processing = 1;
+        pipe->cs_flags.pipe_cmd_processing = 1;
         switch (command) {
             case HCD_PIPE_CMD_ABORT: {
                 //Retire all scheduled IRPs. Pipe's state remains unchanged
                 if (!_pipe_wait_done(pipe)) {   //Stop any on going transfers
                     ret = ESP_ERR_INVALID_RESPONSE;
-                    break;
                 }
+                _buffer_flush_all(pipe, true);  //Some buffers might still be filled. Flush them
                 _pipe_retire(pipe, true);  //Retire any pending transfers
                 break;
             }
@@ -1578,6 +1776,7 @@ esp_err_t hcd_pipe_command(hcd_pipe_handle_t pipe_hdl, hcd_pipe_cmd_t command)
                     ret = ESP_ERR_INVALID_RESPONSE;
                     break;
                 }
+                _buffer_flush_all(pipe, true);  //Some buffers might still be filled. Flush them
                 _pipe_retire(pipe, true);  //Retire any pending transfers
                 pipe->state = HCD_PIPE_STATE_ACTIVE;
                 break;
@@ -1587,10 +1786,11 @@ esp_err_t hcd_pipe_command(hcd_pipe_handle_t pipe_hdl, hcd_pipe_cmd_t command)
                 if (pipe->state == HCD_PIPE_STATE_HALTED) {
                     pipe->state = HCD_PIPE_STATE_ACTIVE;
                     //Start the next pending transfer if it exists
-                    if (_pipe_get_next_irp(pipe)) {
-                        //Fill the descriptor list with the IRP and start the transfer
-                        _xfer_desc_list_fill(pipe);
-                        usbh_hal_chan_activate(pipe->chan_obj, 0);  //Start with the first descriptor
+                    if (_buffer_can_fill(pipe)) {
+                        _buffer_fill(pipe);
+                    }
+                    if (_buffer_can_exec(pipe)) {
+                        _buffer_exec(pipe);
                     }
                 }
                 break;
@@ -1605,7 +1805,7 @@ esp_err_t hcd_pipe_command(hcd_pipe_handle_t pipe_hdl, hcd_pipe_cmd_t command)
                 break;
             }
         }
-        pipe->flags.pipe_cmd_processing = 0;
+        pipe->cs_flags.pipe_cmd_processing = 0;
     }
     HCD_EXIT_CRITICAL();
     return ret;
@@ -1622,160 +1822,460 @@ hcd_pipe_event_t hcd_pipe_get_event(hcd_pipe_handle_t pipe_hdl)
     return ret;
 }
 
-// ---------------------------------------------- HCD Transfer Descriptors ---------------------------------------------
+// ------------------------------------------------- Buffer Control ----------------------------------------------------
 
-// ----------------------- Private -------------------------
+#define DESC_PER_XFER_CTRL_WITH_DATA    3
+#define DESC_PER_XFER_CTRL_NO_DATA      2
+
+static inline void _buffer_fill_ctrl(dma_buffer_block_t *buffer, usb_irp_t *irp)
+{
+    //Get information about the control transfer by analyzing the setup packet (the first 8 bytes of the IRP's data)
+    usb_ctrl_req_t *ctrl_req = (usb_ctrl_req_t *)irp->data_buffer;
+    bool data_stg_in = (ctrl_req->bRequestType & USB_B_REQUEST_TYPE_DIR_IN);
+    bool data_stg_skip = (irp->num_bytes == 0);
+    //Fill setup stage
+    usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, 0, irp->data_buffer, sizeof(usb_ctrl_req_t),
+                            USBH_HAL_XFER_DESC_FLAG_SETUP | USBH_HAL_XFER_DESC_FLAG_HOC);
+    //Fill data stage
+    if (data_stg_skip) {
+        //Not data stage. Fill with an empty descriptor
+        usbh_hal_xfer_desc_clear(buffer->xfer_desc_list, 1);
+    } else {
+        //Fill data stage
+        usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, 1, irp->data_buffer + sizeof(usb_ctrl_req_t), irp->num_bytes,
+                                ((data_stg_in) ? USBH_HAL_XFER_DESC_FLAG_IN : 0) | USBH_HAL_XFER_DESC_FLAG_HOC);
+    }
+    //Fill status stage (i.e., a zero length packet). If data stage is skipped, the status stage is always IN.
+    usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, 2, NULL, 0,
+                            ((data_stg_in && !data_stg_skip) ? 0 : USBH_HAL_XFER_DESC_FLAG_IN) | USBH_HAL_XFER_DESC_FLAG_HOC);
+    //Update buffer flags
+    buffer->flags.ctrl.data_stg_in = data_stg_in;
+    buffer->flags.ctrl.data_stg_skip = data_stg_skip;
+    buffer->flags.ctrl.cur_stg = 0;
+}
+
+static inline void _buffer_fill_bulk(dma_buffer_block_t *buffer, usb_irp_t *irp, bool is_in)
+{
+    if (is_in) {
+        usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, 0, irp->data_buffer, irp->num_bytes,
+                                USBH_HAL_XFER_DESC_FLAG_IN | USBH_HAL_XFER_DESC_FLAG_HOC);
+    } else if (irp->flags & USB_IRP_FLAG_ZERO_PACK) {
+        //We need to add an extra zero length packet, so two descriptors are used
+        usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, 0, irp->data_buffer, irp->num_bytes, 0);
+        usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, 1, NULL, 0, USBH_HAL_XFER_DESC_FLAG_HOC);
+    } else {
+        usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, 0, irp->data_buffer, irp->num_bytes, USBH_HAL_XFER_DESC_FLAG_HOC);
+    }
+    //Update buffer flags
+    buffer->flags.bulk.zero_len_packet = (is_in && (irp->flags & USB_IRP_FLAG_ZERO_PACK)) ? 1 : 0;
+}
+
+static inline void _buffer_fill_intr(dma_buffer_block_t *buffer, usb_irp_t *irp, bool is_in, int mps)
+{
+    int num_qtds;
+    if (is_in) {
+        assert(irp->num_bytes % mps == 0);  //IN transfers MUST be integer multiple of MPS
+        num_qtds = irp->num_bytes / mps;
+    } else {
+        num_qtds = irp->num_bytes / mps;    //Floor division for number of MPS packets
+        if (irp->num_bytes % irp->num_bytes > 0) {
+            num_qtds++; //For the last shot packet
+        }
+    }
+    assert(num_qtds <= XFER_LIST_LEN_INTR);
+    //Fill all but last descriptor
+    int bytes_filled = 0;
+    for (int i = 0; i < num_qtds - 1; i++) {
+        usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, i, &irp->data_buffer[bytes_filled], mps, (is_in) ? USBH_HAL_XFER_DESC_FLAG_IN : 0);
+        bytes_filled += mps;
+    }
+    //Fill in the last descriptor with HOC flag
+    usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, num_qtds - 1, &irp->data_buffer[bytes_filled], irp->num_bytes - bytes_filled,
+                            ((is_in) ? USBH_HAL_XFER_DESC_FLAG_IN : 0) | USBH_HAL_XFER_DESC_FLAG_HOC);
+    //Update buffer members and flags
+    buffer->flags.intr.num_qtds = num_qtds;
+}
 
-static void _xfer_desc_list_fill(pipe_t *pipe)
+static inline void _buffer_fill_isoc(dma_buffer_block_t *buffer, usb_irp_t *irp, bool is_in, int mps, int interval, int start_idx)
 {
-    //inflight_irp of the pipe must already set to the target IRP
-    assert(pipe->inflight_irp != NULL);
-    //Fill transfer descriptor list with a single IRP
-    usb_irp_t *usb_irp = pipe->inflight_irp;
+    assert(interval > 0);
+    int total_num_desc = irp->num_iso_packets * interval;
+    assert(total_num_desc <= XFER_LIST_LEN_ISOC);
+    int desc_idx = start_idx;
+    int bytes_filled = 0;
+    //For each packet, fill in a descriptor and a interval-1 blank descriptor after it
+    for (int pkt_idx = 0; pkt_idx < irp->num_iso_packets; pkt_idx++) {
+        int xfer_len = irp->iso_packet_desc[pkt_idx].length;
+        uint32_t flags = (is_in) ? USBH_HAL_XFER_DESC_FLAG_IN : 0;
+        if (pkt_idx == irp->num_iso_packets - 1) {
+            //Last packet, set the the HOC flag
+            flags |= USBH_HAL_XFER_DESC_FLAG_HOC;
+        }
+        usbh_hal_xfer_desc_fill(buffer->xfer_desc_list, desc_idx, &irp->data_buffer[bytes_filled], xfer_len, flags);
+        bytes_filled += xfer_len;
+        if (++desc_idx >= XFER_LIST_LEN_INTR) {
+            desc_idx = 0;
+        }
+        //Clear descriptors for unscheduled frames
+        for (int i = 0; i < interval - 1; i++) {
+            usbh_hal_xfer_desc_clear(buffer->xfer_desc_list, desc_idx);
+            if (++desc_idx >= XFER_LIST_LEN_INTR) {
+                desc_idx = 0;
+            }
+        }
+    }
+    //Update buffer members and flags
+    buffer->flags.isoc.num_qtds = total_num_desc;
+    buffer->flags.isoc.interval = interval;
+    buffer->flags.isoc.irp_start_idx = start_idx;
+    buffer->flags.isoc.next_irp_start_idx = desc_idx;
+}
+
+static void _buffer_fill(pipe_t *pipe)
+{
+    //Get an IRP from the pending tailq
+    usb_irp_t *irp = TAILQ_FIRST(&pipe->pending_irp_tailq);
+    assert(pipe->num_irp_pending > 0 && irp != NULL);
+    TAILQ_REMOVE(&pipe->pending_irp_tailq, irp, tailq_entry);
+    pipe->num_irp_pending--;
+
+    //Select the inactive buffer
+    assert(pipe->multi_buffer_flags.buffer_num_to_exec <= NUM_BUFFERS);
+    dma_buffer_block_t *buffer_to_fill = pipe->buffers[pipe->multi_buffer_flags.wr_idx];
+    assert(buffer_to_fill->irp == NULL);
+    bool is_in = pipe->ep_char.bEndpointAddress & USB_B_ENDPOINT_ADDRESS_EP_DIR_MASK;
+    int mps = pipe->ep_char.mps;
     switch (pipe->ep_char.type) {
-        case USB_XFER_TYPE_CTRL: {
-            //Get information about the contorl transfer by analyzing the setup packet (the first 8 bytes)
-            usb_ctrl_req_t *ctrl_req = (usb_ctrl_req_t *)usb_irp->data_buffer;
-            pipe->flags.ctrl_data_stg_in = ((ctrl_req->bRequestType & USB_B_REQUEST_TYPE_DIR_IN) != 0);
-            pipe->flags.ctrl_data_stg_skip = (usb_irp->num_bytes == 0);
-
-            //Fill setup stage
-            usbh_hal_xfer_desc_fill(pipe->xfer_desc_list, 0, usb_irp->data_buffer, sizeof(usb_ctrl_req_t),
-                                    USBH_HAL_XFER_DESC_FLAG_SETUP | USBH_HAL_XFER_DESC_FLAG_HALT);
-            if (pipe->flags.ctrl_data_stg_skip) {
-                //Fill a NULL packet if there is no data stage
-                usbh_hal_xfer_desc_fill(pipe->xfer_desc_list, 1, NULL, 0, USBH_HAL_XFER_DESC_FLAG_NULL);
+        case USB_HAL_XFER_TYPE_CTRL: {
+            _buffer_fill_ctrl(buffer_to_fill, irp);
+            break;
+        }
+        case USB_HAL_XFER_TYPE_ISOCHRONOUS: {
+            int start_idx;
+            if (pipe->multi_buffer_flags.wr_idx == pipe->multi_buffer_flags.rd_idx) {
+                //There are no more previously filled buffers to execute. We need to calculate a new start index based on HFNUM and the pipe's schedule
+                uint32_t cur_frame_num = usbh_hal_port_get_cur_frame_num(pipe->port->hal);
+                //Isoc list length is always a power of 2. Mask it with the length to get the current desc index
+                uint32_t cur_idx = cur_frame_num & XFER_LIST_LEN_ISOC;
+                uint32_t last_multiple = (cur_frame_num - pipe->ep_char.periodic.phase_offset_frames) / pipe->ep_char.periodic.interval;
+                uint32_t next_sched_idx = (last_multiple * pipe->ep_char.periodic.interval) + pipe->ep_char.periodic.phase_offset_frames;
+                //We want at least a half interval or 2 frames of buffer space
+                if (cur_idx + 2 >= next_sched_idx
+                    || cur_idx + (pipe->ep_char.periodic.interval / 2) >= next_sched_idx) {
+                        //Postpone the start by another interval just to be safe
+                        next_sched_idx += pipe->ep_char.periodic.interval;
+                }
+                start_idx = next_sched_idx & XFER_LIST_LEN_ISOC;    //Mask it with the List length to wrap the index
             } else {
-                //Fill data stage
-                usbh_hal_xfer_desc_fill(pipe->xfer_desc_list, 1, usb_irp->data_buffer + sizeof(usb_ctrl_req_t), usb_irp->num_bytes,
-                                        ((pipe->flags.ctrl_data_stg_in) ? USBH_HAL_XFER_DESC_FLAG_IN : 0) | USBH_HAL_XFER_DESC_FLAG_HALT);
+                //Start index is based on previously filled buffer
+                dma_buffer_block_t *prev_filled_buffer = pipe->buffers[pipe->multi_buffer_flags.wr_idx - 1];
+                start_idx = prev_filled_buffer->flags.isoc.next_irp_start_idx;
             }
-            //Fill status stage (i.e., a zero length packet). If data stage is skipped, the status stage is always IN.
-            usbh_hal_xfer_desc_fill(pipe->xfer_desc_list, 2, NULL, 0,
-                                    ((pipe->flags.ctrl_data_stg_in && !pipe->flags.ctrl_data_stg_skip) ? 0 : USBH_HAL_XFER_DESC_FLAG_IN) | USBH_HAL_XFER_DESC_FLAG_HALT);
+            _buffer_fill_isoc(buffer_to_fill, irp, is_in, mps, (int)pipe->ep_char.periodic.interval, start_idx);
+            break;
+        }
+        case USB_HAL_XFER_TYPE_BULK: {
+            _buffer_fill_bulk(buffer_to_fill, irp, is_in);
+            break;
+        }
+        case USB_HAL_XFER_TYPE_INTR: {
+            _buffer_fill_intr(buffer_to_fill, irp, is_in, mps);
+            break;
+        }
+        default: {
+            abort();
+            break;
+        }
+    }
+    buffer_to_fill->irp = irp;
+    IRP_STATE_SET(irp->reserved_flags, IRP_STATE_INFLIGHT);
+    //Update multi buffer flags
+    pipe->multi_buffer_flags.wr_idx++;
+    pipe->multi_buffer_flags.buffer_num_to_fill--;
+    pipe->multi_buffer_flags.buffer_num_to_exec++;
+}
+
+static void _buffer_exec(pipe_t *pipe)
+{
+    assert(pipe->multi_buffer_flags.rd_idx != pipe->multi_buffer_flags.wr_idx || pipe->multi_buffer_flags.buffer_num_to_exec > 0);
+    dma_buffer_block_t *buffer_to_exec = pipe->buffers[pipe->multi_buffer_flags.rd_idx];
+    assert(buffer_to_exec->irp != NULL);
+
+    uint32_t start_idx;
+    int desc_list_len;
+    switch (pipe->ep_char.type) {
+        case USB_HAL_XFER_TYPE_CTRL: {
+            start_idx = 0;
+            desc_list_len = XFER_LIST_LEN_CTRL;
             //Set the channel's direction to OUT and PID to 0 respectively for the the setup stage
             usbh_hal_chan_set_dir(pipe->chan_obj, false);   //Setup stage is always OUT
             usbh_hal_chan_set_pid(pipe->chan_obj, 0);   //Setup stage always has a PID of DATA0
             break;
         }
-        case USB_XFER_TYPE_BULK: {
-            bool is_in = pipe->ep_char.bEndpointAddress & USB_B_ENDPOINT_ADDRESS_EP_DIR_MASK;
-            usbh_hal_xfer_desc_fill(pipe->xfer_desc_list, 0, usb_irp->data_buffer, usb_irp->num_bytes,
-                                    ((is_in) ? USBH_HAL_XFER_DESC_FLAG_IN : 0) | USBH_HAL_XFER_DESC_FLAG_HALT);
+        case USB_HAL_XFER_TYPE_ISOCHRONOUS: {
+            start_idx = buffer_to_exec->flags.isoc.irp_start_idx;
+            desc_list_len = XFER_LIST_LEN_ISOC;
+            break;
+        }
+        case USB_HAL_XFER_TYPE_BULK: {
+            start_idx = 0;
+            desc_list_len = (buffer_to_exec->flags.bulk.zero_len_packet) ? XFER_LIST_LEN_BULK : 1;
+            break;
+        }
+        case USB_HAL_XFER_TYPE_INTR: {
+            start_idx = 0;
+            desc_list_len = buffer_to_exec->flags.intr.num_qtds;
             break;
         }
         default: {
-            break;  //Isoc and Interrupt transfers not supported yet
+            start_idx = 0;
+            desc_list_len = 0;
+            abort();
+            break;
         }
     }
-    //Claim slot
-    usbh_hal_chan_slot_acquire(pipe->chan_obj, pipe->xfer_desc_list, pipe->flags.xfer_desc_list_len, (void *)pipe);
+    //Update buffer and multi buffer flags
+    buffer_to_exec->status_flags.executing = 1;
+    pipe->multi_buffer_flags.buffer_is_executing = 1;
+    usbh_hal_chan_activate(pipe->chan_obj, buffer_to_exec->xfer_desc_list, desc_list_len, start_idx);
 }
 
-static void _xfer_desc_list_continue(pipe_t *pipe)
+static bool _buffer_check_done(pipe_t *pipe)
 {
-    int next_idx = usbh_hal_chan_get_next_desc_index(pipe->chan_obj);
-    bool next_dir_is_in;    //Next descriptor direction is IN
-    int next_pid;           //Next PID (DATA0 or DATA 1)
-    int num_to_skip;        //Number of descriptors to skip
-    if (next_idx == 1) {
-        //Just finished setup stage
-        if (pipe->flags.ctrl_data_stg_skip) {
+    if (pipe->ep_char.type != USB_HAL_XFER_TYPE_CTRL) {
+        return true;
+    }
+    //Only control transfers need to be continued
+    dma_buffer_block_t *buffer_inflight = pipe->buffers[pipe->multi_buffer_flags.rd_idx];
+    bool next_dir_is_in;
+    int next_pid;
+    if (buffer_inflight->flags.ctrl.cur_stg == 0) { //Just finished control stage
+        if (buffer_inflight->flags.ctrl.data_stg_skip) {
             //Skipping data stage. Go straight to status stage
             next_dir_is_in = true;     //With no data stage, status stage must be IN
             next_pid = 1;       //Status stage always has a PID of DATA1
-            num_to_skip = 1;    //Skip over the null descriptor representing the skipped data stage
+            buffer_inflight->flags.ctrl.cur_stg = 2;    //Skip over the null descriptor representing the skipped data stage
         } else {
             //Go to data stage
-            next_dir_is_in = pipe->flags.ctrl_data_stg_in;
+            next_dir_is_in = buffer_inflight->flags.ctrl.data_stg_in;
             next_pid = 1;   //Data stage always starts with a PID of DATA1
-            num_to_skip = 0;
+            buffer_inflight->flags.ctrl.cur_stg = 1;
         }
-    } else {    //next_idx == 2
-        //Going to status stage from data stage
-        next_dir_is_in = !pipe->flags.ctrl_data_stg_in;     //Status stage is opposite direction of data stage
+    } else if (buffer_inflight->flags.ctrl.cur_stg == 1) {  //Just finished data stage. Go to status stage
+        next_dir_is_in = !buffer_inflight->flags.ctrl.data_stg_in;  //Status stage is always the opposite direction of data stage
         next_pid = 1;   //Status stage always has a PID of DATA1
-        num_to_skip = 0;
+        buffer_inflight->flags.ctrl.cur_stg = 2;
+    } else {    //Just finished status stage. Transfer is complete
+        return true;
     }
-
+    //Continue the control transfer
     usbh_hal_chan_set_dir(pipe->chan_obj, next_dir_is_in);
     usbh_hal_chan_set_pid(pipe->chan_obj, next_pid);
-    usbh_hal_chan_activate(pipe->chan_obj, num_to_skip);    //Start the next stage
+    usbh_hal_chan_activate(pipe->chan_obj, buffer_inflight->xfer_desc_list, XFER_LIST_LEN_CTRL, buffer_inflight->flags.ctrl.cur_stg);
+    return false;
 }
 
-static void _xfer_desc_list_parse(pipe_t *pipe, bool error_occurred)
+static inline void _buffer_parse_ctrl(dma_buffer_block_t *buffer)
 {
-    assert(pipe->inflight_irp != NULL);
-    //Release the slot
-    void *xfer_desc_list;
-    int xfer_desc_len;
-    usbh_hal_chan_slot_release(pipe->chan_obj, &xfer_desc_list, &xfer_desc_len);
-    assert(xfer_desc_list == pipe->xfer_desc_list);
-    (void) xfer_desc_len;
-
-    //Parse the transfer descriptor list for the result of the transfer
-    usb_irp_t *irp = pipe->inflight_irp;
-    usb_transfer_status_t xfer_status;
-    int xfer_rem_len;
-    if (error_occurred) {
-        //Either a pipe error has occurred or the pipe is no longer valid
-        if (pipe->state == HCD_PIPE_STATE_INVALID) {
-            xfer_status = USB_TRANSFER_STATUS_NO_DEVICE;
+    usb_irp_t *irp = buffer->irp;
+    //Update IRP's actual number of bytes
+    if (buffer->flags.ctrl.data_stg_skip)     {
+        //There was no data stage. Just set the actual length to zero
+        irp->actual_num_bytes = 0;
+    } else {
+        //Parse the data stage for the remaining length
+        int rem_len;
+        int desc_status;
+        usbh_hal_xfer_desc_parse(buffer->xfer_desc_list, 1, &rem_len, &desc_status);
+        assert(desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS);
+        assert(rem_len <= irp->num_bytes);
+        irp->actual_num_bytes = irp->num_bytes - rem_len;
+    }
+    //Update IRP status
+    irp->status = USB_TRANSFER_STATUS_COMPLETED;
+    //Clear the descriptor list
+    memset(buffer->xfer_desc_list, XFER_LIST_LEN_CTRL, sizeof(usbh_ll_dma_qtd_t));
+}
+
+static inline void _buffer_parse_bulk(dma_buffer_block_t *buffer)
+{
+    usb_irp_t *irp = buffer->irp;
+    //Update IRP's actual nubmer of bytes
+    int rem_len;
+    int desc_status;
+    usbh_hal_xfer_desc_parse(buffer->xfer_desc_list, 0, &rem_len, &desc_status);
+    assert(desc_status == USBH_HAL_XFER_DESC_STS_NOT_EXECUTED);
+    assert(rem_len <= irp->num_bytes);
+    irp->actual_num_bytes = irp->num_bytes - rem_len;
+    //Update IRP's status
+    irp->status = USB_TRANSFER_STATUS_COMPLETED;
+    //Clear the descriptor list
+    memset(buffer->xfer_desc_list, XFER_LIST_LEN_BULK, sizeof(usbh_ll_dma_qtd_t));
+}
+
+static inline void _buffer_parse_intr(dma_buffer_block_t *buffer, bool is_in, int mps)
+{
+    usb_irp_t *irp = buffer->irp;
+    int intr_stop_idx = buffer->status_flags.stop_idx;
+    if (is_in) {
+        if (intr_stop_idx > 0) { //This is an early stop (short packet)
+            assert(intr_stop_idx <= buffer->flags.intr.num_qtds);
+            int rem_len;
+            int desc_status;
+            for (int i = 0; i < intr_stop_idx - 1; i++) {    //Check all packets before the short
+                usbh_hal_xfer_desc_parse(buffer->xfer_desc_list, i, &rem_len, &desc_status);
+                assert(rem_len == 0 && desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS);
+            }
+            //Check the short packet
+            usbh_hal_xfer_desc_parse(buffer->xfer_desc_list, intr_stop_idx - 1, &rem_len, &desc_status);
+            assert(rem_len > 0 && desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS);
+            //Update actual bytes
+            irp->actual_num_bytes = (mps * intr_stop_idx - 2) + (mps - rem_len);
         } else {
-            //Must have been a pipe error event
-            switch (pipe->last_event) {
-                case HCD_PIPE_EVENT_ERROR_XFER: //Excessive transaction error
-                    xfer_status = USB_TRANSFER_STATUS_ERROR;
-                    break;
-                case HCD_PIPE_EVENT_ERROR_OVERFLOW:
-                    xfer_status = USB_TRANSFER_STATUS_OVERFLOW;
-                    break;
-                case HCD_PIPE_EVENT_ERROR_STALL:
-                    xfer_status = USB_TRANSFER_STATUS_STALL;
-                    break;
-                default:
-                    //HCD_PIPE_EVENT_ERROR_IRP_NOT_AVAIL should never occur
-                    abort();
-                    break;
+            //Check that all the packets transmitted MPS
+            for (int i = 0; i < buffer->flags.intr.num_qtds; i++) {
+                int rem_len;
+                int desc_status;
+                usbh_hal_xfer_desc_parse(buffer->xfer_desc_list, i, &rem_len, &desc_status);
+                assert(rem_len == 0 && desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS);
             }
+            //Update actual bytes
+            irp->actual_num_bytes = irp->num_bytes;
         }
-        //We assume no bytes transmitted because of an error.
-        xfer_rem_len = irp->num_bytes;
     } else {
+        //OUT INTR transfers can only complete successfully if all MPS packets have been transmitted. Double check
+        for (int i = 0 ; i < buffer->flags.intr.num_qtds; i++) {
+            int rem_len;
+            int desc_status;
+            usbh_hal_xfer_desc_parse(buffer->xfer_desc_list, i, &rem_len, &desc_status);
+            assert(rem_len == 0 && desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS);
+        }
+        irp->actual_num_bytes = irp->num_bytes;
+    }
+    //Update IRP's status
+    irp->status = USB_TRANSFER_STATUS_COMPLETED;
+    //Clear the descriptor list
+    memset(buffer->xfer_desc_list, XFER_LIST_LEN_INTR, sizeof(usbh_ll_dma_qtd_t));
+}
+
+static inline void _buffer_parse_isoc(dma_buffer_block_t *buffer, bool is_in)
+{
+    usb_irp_t *irp = buffer->irp;
+    int desc_idx = buffer->flags.isoc.irp_start_idx;
+    for (int i = 0; i < irp->num_iso_packets; i++) {
+        int rem_len;
         int desc_status;
+        usbh_hal_xfer_desc_parse(buffer->xfer_desc_list, desc_idx, &rem_len, &desc_status);
+        usbh_hal_xfer_desc_clear(buffer->xfer_desc_list, desc_idx);
+        assert(rem_len == 0 || is_in);
+        assert(desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS || USBH_HAL_XFER_DESC_STS_NOT_EXECUTED);
+        //Update ISO packet actual length and status
+        irp->iso_packet_desc[i].actual_length = irp->iso_packet_desc[i].length - rem_len;
+        irp->iso_packet_desc[i].status = (desc_status == USBH_HAL_XFER_DESC_STS_NOT_EXECUTED) ? USB_TRANSFER_STATUS_SKIPPED : USB_TRANSFER_STATUS_COMPLETED;
+    }
+}
+
+static inline void _buffer_parse_error(dma_buffer_block_t *buffer)
+{
+    //The IRP errored out, so we consider that NO bytes were transferred
+    usb_irp_t *irp = buffer->irp;
+    irp->actual_num_bytes = 0;
+    for (int i = 0; i < irp->num_iso_packets; i++) {
+        irp->iso_packet_desc[i].actual_length = 0;
+    }
+    //Update status of IRP
+    if (buffer->status_flags.cancelled) {
+        irp->status = USB_TRANSFER_STATUS_CANCELLED;
+    } else if (buffer->status_flags.pipe_state == HCD_PIPE_STATE_INVALID) {
+        irp->status = USB_TRANSFER_STATUS_NO_DEVICE;
+    } else {
+        switch (buffer->status_flags.pipe_event) {
+            case HCD_PIPE_EVENT_ERROR_XFER: //Excessive transaction error
+                irp->status = USB_TRANSFER_STATUS_ERROR;
+                break;
+            case HCD_PIPE_EVENT_ERROR_OVERFLOW:
+                irp->status = USB_TRANSFER_STATUS_OVERFLOW;
+                break;
+            case HCD_PIPE_EVENT_ERROR_STALL:
+                irp->status = USB_TRANSFER_STATUS_STALL;
+                break;
+            case HCD_PIPE_EVENT_IRP_DONE:   //Special case where we are cancelling an IRP due to pipe_retire
+                irp->status = USB_TRANSFER_STATUS_CANCELLED;
+                break;
+            default:
+                //HCD_PIPE_EVENT_ERROR_IRP_NOT_AVAIL should never occur
+                abort();
+                break;
+        }
+    }
+    //Clear error flags
+    buffer->status_flags.val = 0;
+}
+
+static void _buffer_parse(pipe_t *pipe)
+{
+    assert(pipe->multi_buffer_flags.buffer_num_to_parse > 0);
+    dma_buffer_block_t *buffer_to_parse = pipe->buffers[pipe->multi_buffer_flags.fr_idx];
+    assert(buffer_to_parse->irp != NULL);
+    bool is_in = pipe->ep_char.bEndpointAddress & USB_B_ENDPOINT_ADDRESS_EP_DIR_MASK;
+    int mps = pipe->ep_char.mps;
+
+    //Parsing the buffer will update the buffer's corresponding IRP
+    if (buffer_to_parse->status_flags.error_occurred) {
+        _buffer_parse_error(buffer_to_parse);
+    } else {
         switch (pipe->ep_char.type) {
-            case USB_XFER_TYPE_CTRL: {
-                if (pipe->flags.ctrl_data_stg_skip) {
-                    //There was no data stage. Just set it as successful
-                    desc_status = USBH_HAL_XFER_DESC_STS_SUCCESS;
-                    xfer_rem_len = 0;
-                } else {
-                    //Check the data stage (index 1)
-                    usbh_hal_xfer_desc_parse(pipe->xfer_desc_list, 1, &xfer_rem_len, &desc_status);
-                }
+            case USB_HAL_XFER_TYPE_CTRL: {
+                _buffer_parse_ctrl(buffer_to_parse);
                 break;
             }
-            case USB_XFER_TYPE_BULK: {
-                usbh_hal_xfer_desc_parse(pipe->xfer_desc_list, 0, &xfer_rem_len, &desc_status);
+            case USB_HAL_XFER_TYPE_ISOCHRONOUS: {
+                _buffer_parse_isoc(buffer_to_parse, is_in);
+                break;
+            }
+            case USB_HAL_XFER_TYPE_BULK: {
+                _buffer_parse_bulk(buffer_to_parse);
+                break;
+            }
+            case USB_HAL_XFER_TYPE_INTR: {
+                _buffer_parse_intr(buffer_to_parse, is_in, mps);
                 break;
             }
             default: {
-                //We don't supportISOC and INTR pipes yet
-                desc_status = USBH_HAL_XFER_DESC_STS_NOT_EXECUTED;
-                xfer_rem_len = 0;
-                xfer_status = USB_TRANSFER_STATUS_ERROR;
                 abort();
                 break;
             }
         }
-        xfer_status = USB_TRANSFER_STATUS_COMPLETED;
-        assert(desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS);
     }
-    //Write back results to IRP
-    irp->actual_num_bytes = irp->num_bytes - xfer_rem_len;
-    irp->status = xfer_status;
+    usb_irp_t *irp = buffer_to_parse->irp;
+    IRP_STATE_SET(irp->reserved_flags, IRP_STATE_DONE);
+    buffer_to_parse->irp = NULL;
+    buffer_to_parse->flags.val = 0; //Clear flags
+    //Move the IRP to the done tailq
+    TAILQ_INSERT_TAIL(&pipe->done_irp_tailq, irp, tailq_entry);
+    pipe->num_irp_done++;
+    //Update multi buffer flags
+    pipe->multi_buffer_flags.fr_idx++;
+    pipe->multi_buffer_flags.buffer_num_to_parse--;
+    pipe->multi_buffer_flags.buffer_num_to_fill++;
 }
 
+static void _buffer_flush_all(pipe_t *pipe, bool cancelled)
+{
+    int cur_num_to_mark_done =  pipe->multi_buffer_flags.buffer_num_to_exec;
+    for (int i = 0; i < cur_num_to_mark_done; i++) {
+        //Mark any filled buffers as done
+        _buffer_done_error(pipe, 0, pipe->state, pipe->last_event, cancelled);
+    }
+    int cur_num_to_parse = pipe->multi_buffer_flags.buffer_num_to_parse;
+    for (int i = 0; i < cur_num_to_parse; i++) {
+        _buffer_parse(pipe);
+    }
+    //At this point, there should be no more filled buffers. Only IRPs in the pending or done tailq
+}
+
+// ---------------------------------------------- HCD Transfer Descriptors ---------------------------------------------
+
 // ----------------------- Public --------------------------
 
 esp_err_t hcd_irp_enqueue(hcd_pipe_handle_t pipe_hdl, usb_irp_t *irp)
@@ -1790,32 +2290,28 @@ esp_err_t hcd_irp_enqueue(hcd_pipe_handle_t pipe_hdl, usb_irp_t *irp)
     //Check that pipe and port are in the corrrect state to receive IRPs
     HCD_CHECK_FROM_CRIT(pipe->port->state == HCD_PORT_STATE_ENABLED     //The pipe's port must be in the correct state
                         && pipe->state == HCD_PIPE_STATE_ACTIVE         //The pipe must be in the correct state
-                        && !pipe->flags.pipe_cmd_processing,            //Pipe cannot currently be processing a pipe command
+                        && !pipe->cs_flags.pipe_cmd_processing,            //Pipe cannot currently be processing a pipe command
                         ESP_ERR_INVALID_STATE);
     //Use the IRP's reserved_ptr to store the pipe's
     irp->reserved_ptr = (void *)pipe;
-
-    //Check if we can start execution on the pipe immediately
-    if (!pipe->flags.paused && pipe->num_irp_pending == 0 && pipe->inflight_irp == NULL) {
-        //Pipe isn't executing any transfers. Start immediately
-        pipe->inflight_irp = irp;
-        _xfer_desc_list_fill(pipe);
-        usbh_hal_chan_activate(pipe->chan_obj, 0);  //Start with the first descriptor
-        //use the IRP's reserved_flags to store the IRP's current state
-        IRP_STATE_SET(irp->reserved_flags, IRP_STATE_INFLIGHT);
-        if (pipe->num_irp_done == 0) {
-            //This is the first IRP to be enqueued into the pipe. Move the pipe to the list of active pipes
-            TAILQ_REMOVE(&pipe->port->pipes_idle_tailq, pipe, tailq_entry);
-            TAILQ_INSERT_TAIL(&pipe->port->pipes_active_tailq, pipe, tailq_entry);
-            pipe->port->num_pipes_idle--;
-            pipe->port->num_pipes_queued++;
-        }
-    } else {
-        //Add the IRP to the pipe's pending tailq
-        TAILQ_INSERT_TAIL(&pipe->pending_irp_tailq, irp, tailq_entry);
-        pipe->num_irp_pending++;
-        //use the IRP's reserved_flags to store the IRP's current state
-        IRP_STATE_SET(irp->reserved_flags, IRP_STATE_PENDING);
+    //Add the IRP to the pipe's pending tailq
+    IRP_STATE_SET(irp->reserved_flags, IRP_STATE_PENDING);
+    TAILQ_INSERT_TAIL(&pipe->pending_irp_tailq, irp, tailq_entry);
+    pipe->num_irp_pending++;
+    //use the IRP's reserved_flags to store the IRP's current state
+    if (_buffer_can_fill(pipe)) {
+        _buffer_fill(pipe);
+    }
+    if (_buffer_can_exec(pipe)) {
+        _buffer_exec(pipe);
+    }
+    if (!pipe->cs_flags.is_active) {
+        //This is the first IRP to be enqueued into the pipe. Move the pipe to the list of active pipes
+        TAILQ_REMOVE(&pipe->port->pipes_idle_tailq, pipe, tailq_entry);
+        TAILQ_INSERT_TAIL(&pipe->port->pipes_active_tailq, pipe, tailq_entry);
+        pipe->port->num_pipes_idle--;
+        pipe->port->num_pipes_queued++;
+        pipe->cs_flags.is_active = 1;
     }
     HCD_EXIT_CRITICAL();
     return ESP_OK;
@@ -1835,12 +2331,15 @@ usb_irp_t *hcd_irp_dequeue(hcd_pipe_handle_t pipe_hdl)
         assert(irp->reserved_ptr == (void *)pipe && IRP_STATE_GET(irp->reserved_flags) == IRP_STATE_DONE);  //The IRP's reserved field should have been set to this pipe
         irp->reserved_ptr = NULL;
         IRP_STATE_SET(irp->reserved_flags, IRP_STATE_IDLE);
-        if (pipe->num_irp_done == 0 && pipe->num_irp_pending == 0) {
+        if (pipe->cs_flags.is_active
+            && pipe->num_irp_pending == 0 && pipe->num_irp_done == 0
+            && pipe->multi_buffer_flags.buffer_num_to_exec == 0 && pipe->multi_buffer_flags.buffer_num_to_parse == 0) {
             //This pipe has no more enqueued IRPs. Move the pipe to the list of idle pipes
             TAILQ_REMOVE(&pipe->port->pipes_active_tailq, pipe, tailq_entry);
             TAILQ_INSERT_TAIL(&pipe->port->pipes_idle_tailq, pipe, tailq_entry);
             pipe->port->num_pipes_idle++;
             pipe->port->num_pipes_queued--;
+            pipe->cs_flags.is_active = 0;
         }
     } else {
         //No more IRPs to dequeue from this pipe
diff --git a/components/usb/private_include/hcd.h b/components/usb/private_include/hcd.h
index 48d4547cb..335776138 100644
--- a/components/usb/private_include/hcd.h
+++ b/components/usb/private_include/hcd.h
@@ -178,8 +178,8 @@ typedef struct {
     void *callback_arg;                     /**< User argument for HCD pipe callback */
     void *context;                          /**< Context variable used to associate the pipe with upper layer object */
     usb_desc_ep_t *ep_desc;                 /**< Pointer to endpoint descriptor of the pipe */
-    uint8_t dev_addr;                       /**< Device address of the pipe */
     usb_speed_t dev_speed;                  /**< Speed of the device */
+    uint8_t dev_addr;                       /**< Device address of the pipe */
 } hcd_pipe_config_t;
 
 // --------------------------------------------- Host Controller Driver ------------------------------------------------
diff --git a/components/usb/private_include/usb.h b/components/usb/private_include/usb.h
index cfed578de..1f3ed5f11 100644
--- a/components/usb/private_include/usb.h
+++ b/components/usb/private_include/usb.h
@@ -52,10 +52,10 @@ typedef enum {
  * @note The enum values need to match the bmAttributes field of an EP descriptor
  */
 typedef enum {
-    USB_XFER_TYPE_CTRL = 0,
-    USB_XFER_TYPE_ISOCHRONOUS,
-    USB_XFER_TYPE_BULK,
-    USB_XFER_TYPE_INTR,
+    USB_TRANSFER_TYPE_CTRL = 0,
+    USB_TRANSFER_TYPE_ISOCHRONOUS,
+    USB_TRANSFER_TYPE_BULK,
+    USB_TRANSFER_TYPE_INTR,
 } usb_transfer_type_t;
 
 /**
@@ -69,6 +69,7 @@ typedef enum {
     USB_TRANSFER_STATUS_STALL,          /**< The transfer was stalled */
     USB_TRANSFER_STATUS_NO_DEVICE,      /**< The transfer failed because the device is no longer valid (e.g., disconencted */
     USB_TRANSFER_STATUS_OVERFLOW,       /**< The transfer as more data was sent than was requested */
+    USB_TRANSFER_STATUS_SKIPPED,        /**< ISOC only. The packet was skipped due to system latency */
 } usb_transfer_status_t;
 
 /**
@@ -85,6 +86,8 @@ typedef struct {
     usb_transfer_status_t status;       /**< Status of the packet */
 } usb_iso_packet_desc_t;
 
+#define USB_IRP_FLAG_ZERO_PACK  0x01    /**< (For bulk OUT only). Indicates that a bulk OUT transfers should always terminate with a short packet, even if it means adding an extra zero length packet */
+
 /**
  * @brief USB IRP (I/O Request Packet). See USB2.0 Spec
  *
@@ -112,6 +115,7 @@ struct usb_irp_obj {
     uint8_t *data_buffer;                   /**< Pointer to data buffer. Must be DMA capable memory */
     int num_bytes;                          /**< Number of bytes in IRP. Control should exclude size of setup. IN should be integer multiple of MPS */
     int actual_num_bytes;                   /**< Actual number of bytes transmitted/receives in the IRP */
+    uint32_t flags;                         /**< IRP flags */
     usb_transfer_status_t status;           /**< Status of the transfer */
     uint32_t timeout;                       /**< Timeout (in milliseconds) of the packet */
     void *context;                          /**< Context variable used to associate the IRP object with another object */
diff --git a/components/usb/test/test_hcd.c b/components/usb/test/test_hcd.c
index 33aa64019..456282e3c 100644
--- a/components/usb/test/test_hcd.c
+++ b/components/usb/test/test_hcd.c
@@ -694,6 +694,7 @@ TEST_CASE("Test HCD pipe STALL", "[hcd][ignore]")
     TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_command(default_pipe, HCD_PIPE_CMD_CLEAR));
     TEST_ASSERT_EQUAL(HCD_PIPE_STATE_ACTIVE, hcd_pipe_get_state(default_pipe));
 
+    printf("Retrying\n");
     //Correct first transfer then requeue
     USB_CTRL_REQ_INIT_GET_CFG_DESC((usb_ctrl_req_t *) irp_list[0]->data_buffer, 0, TRANSFER_DATA_MAX_BYTES);
     for (int i = 0; i < NUM_IRPS; i++) {
@@ -730,7 +731,7 @@ Procedure:
     - Enqueue IRPs but execute a HCD_PIPE_CMD_HALT command immediately after. Halt command should let on
       the current going IRP finish before actually halting the pipe.
     - Clear the pipe halt using a HCD_PIPE_CMD_HALT command. Enqueued IRPs will be resumed
-    - Check that all IRPs have completed successfully.
+    - Check that all IRPs have completed successfully, or can be cancelled if there was an inflight IRP whilst halting
     - Teardown
 */
 TEST_CASE("Test HCD pipe runtime halt and clear", "[hcd][ignore]")
-- 
2.25.1


From 2d95a7fe0eabf995eec4f3782a10cc2c54505fad Mon Sep 17 00:00:00 2001
From: Darian Leung <darian@espressif.com>
Date: Fri, 19 Mar 2021 14:54:01 +0800
Subject: [PATCH 4/9] Add working inter transfer test

Signed-off-by: Li Bo <libo@espressif.com>
---
 components/usb/test/test_hcd_intr.c | 399 ++++++++++++++++++++++++++++
 1 file changed, 399 insertions(+)
 create mode 100644 components/usb/test/test_hcd_intr.c

diff --git a/components/usb/test/test_hcd_intr.c b/components/usb/test/test_hcd_intr.c
new file mode 100644
index 000000000..a4df74042
--- /dev/null
+++ b/components/usb/test/test_hcd_intr.c
@@ -0,0 +1,399 @@
+// Copyright 2015-2020 Espressif Systems (Shanghai) PTE LTD
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <stdio.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "unity.h"
+#include "test_utils.h"
+#include "soc/gpio_pins.h"
+#include "soc/gpio_sig_map.h"
+#include "esp_intr_alloc.h"
+#include "esp_err.h"
+#include "esp_attr.h"
+#include "esp_heap_caps.h"
+#include "esp_rom_gpio.h"
+#include "hal/usbh_ll.h"
+#include "usb.h"
+#include "../private_include/hcd.h"
+
+// -------------------------------------------------- PHY Control ------------------------------------------------------
+
+static void phy_force_conn_state(bool connected, TickType_t delay_ticks)
+{
+    vTaskDelay(delay_ticks);
+    usb_wrap_dev_t *wrap = &USB_WRAP;
+    if (connected) {
+        //Swap back to internal PHY that is connected to a devicee
+        wrap->otg_conf.phy_sel = 0;
+    } else {
+        //Set externa PHY input signals to fixed voltage levels mimicing a disconnected state
+        esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ZERO_INPUT, USB_EXTPHY_VP_IDX, false);
+        esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ZERO_INPUT, USB_EXTPHY_VM_IDX, false);
+        esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ONE_INPUT, USB_EXTPHY_RCV_IDX, false);
+        //Swap to the external PHY
+        wrap->otg_conf.phy_sel = 1;
+    }
+}
+
+// ------------------------------------------------ Helper Functions ---------------------------------------------------
+
+#define EVENT_QUEUE_LEN             5
+#define TRANSFER_DATA_MAX_BYTES     256     //Just assume that will only IN/OUT 256 bytes for now
+#define PORT_NUM                    1
+#define DEV_ADDR                    1
+
+
+static bool port_callback(hcd_port_handle_t port_hdl, hcd_port_event_t port_event, void *user_arg, bool in_isr)
+{
+    QueueHandle_t port_evt_queue = (QueueHandle_t)user_arg;
+    TEST_ASSERT(in_isr);    //Current HCD implementation should never call a port callback in a task context
+    BaseType_t xTaskWoken = pdFALSE;
+    xQueueSendFromISR(port_evt_queue, &port_event, &xTaskWoken);
+    return (xTaskWoken == pdTRUE);
+}
+
+static bool pipe_callback(hcd_pipe_handle_t pipe_hdl, hcd_pipe_event_t pipe_event, void *user_arg, bool in_isr)
+{
+    QueueHandle_t pipe_evt_queue = (QueueHandle_t)user_arg;
+    if (in_isr) {
+        BaseType_t xTaskWoken = pdFALSE;
+        xQueueSendFromISR(pipe_evt_queue, &pipe_event, &xTaskWoken);
+        return (xTaskWoken == pdTRUE);
+    } else {
+        xQueueSend(pipe_evt_queue, &pipe_event, portMAX_DELAY);
+        return false;
+    }
+}
+
+// ------------------------------------------------ Host Port Tests ----------------------------------------------------
+
+static hcd_port_handle_t shared_port_hdl;
+static usb_speed_t port_speed;
+static TaskHandle_t port_task_hdl;
+static TaskHandle_t dflt_pipe_task_hdl;
+static TaskHandle_t periodic_pipe_task_hdl;
+
+static void port_task(void *arg)
+{
+    ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
+    //Initialize a port
+    QueueHandle_t port_evt_queue = xQueueCreate(EVENT_QUEUE_LEN, sizeof(hcd_port_event_t));
+    hcd_port_config_t port_config = {
+        .callback = port_callback,
+        .callback_arg = (void *)port_evt_queue,
+        .context = NULL,
+    };
+    hcd_port_handle_t port_hdl;
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_init(PORT_NUM, &port_config, &port_hdl));
+    shared_port_hdl = port_hdl;
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_POWER_ON));
+
+    hcd_port_event_t port_evt;
+    while (xQueueReceive(port_evt_queue, &port_evt, portMAX_DELAY) == pdTRUE) {
+        hcd_port_event_t actual_evt = hcd_port_handle_event(port_hdl);
+        switch (actual_evt) {
+            case HCD_PORT_EVENT_CONNECTION: {
+                //Reset newly connected device
+                printf("Resetting\n");
+                TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_RESET));
+                TEST_ASSERT_EQUAL(ESP_OK, hcd_port_get_speed(port_hdl, &port_speed));
+                printf("Port speed is %d\n", port_speed);
+                //Start the default pipe task
+                xTaskNotifyGive(dflt_pipe_task_hdl);
+                break;
+            }
+            case HCD_PORT_EVENT_NONE: {
+                break;
+            }
+            case HCD_PORT_EVENT_DISCONNECTION:
+            case HCD_PORT_EVENT_ERROR:
+            case HCD_PORT_EVENT_OVERCURRENT:
+            case HCD_PORT_EVENT_SUDDEN_DISCONN:
+            default:
+                abort();
+        }
+    }
+}
+
+static void dflt_pipe_task(void *arg)
+{
+    typedef enum {
+        ENUM_STAGE_SET_ADDR,
+        ENUM_STAGE_SET_CONFIG,
+    } enum_stage_t;
+    ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
+    //Initialize default pipe
+    QueueHandle_t dflt_pipe_evt_queue = xQueueCreate(EVENT_QUEUE_LEN, sizeof(hcd_pipe_event_t));
+    hcd_pipe_config_t config = {
+        .callback = pipe_callback,
+        .callback_arg = (void *)dflt_pipe_evt_queue,
+        .context = NULL,
+        .ep_desc = NULL,    //NULL EP descriptor to create a default pipe
+        .dev_addr = 0,
+        .dev_speed = port_speed,
+    };
+    hcd_pipe_handle_t dflt_pipe_hdl;
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_alloc(shared_port_hdl, &config, &dflt_pipe_hdl));
+    hcd_pipe_update(dflt_pipe_hdl, 0, 8);
+    printf("default pipe created\n");
+
+    uint8_t *data_buffer = heap_caps_malloc(sizeof(usb_ctrl_req_t) + TRANSFER_DATA_MAX_BYTES, MALLOC_CAP_DMA);
+    usb_irp_t *irp = heap_caps_calloc(1, sizeof(usb_irp_t), MALLOC_CAP_DEFAULT);
+    irp->data_buffer = data_buffer;
+    //Init IRP for set addr
+    enum_stage_t stage = ENUM_STAGE_SET_ADDR;
+    USB_CTRL_REQ_INIT_SET_ADDR((usb_ctrl_req_t *)data_buffer, DEV_ADDR);
+    irp->num_bytes = 0; //No data stage
+    //Enqueue it
+    printf("Sending set_addr\n");
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(dflt_pipe_hdl, irp));
+
+    hcd_pipe_event_t pipe_evt;
+    while (xQueueReceive(dflt_pipe_evt_queue, &pipe_evt, portMAX_DELAY) == pdTRUE) {
+        switch (pipe_evt) {
+            case HCD_PIPE_EVENT_NONE: {
+                break;
+            }
+            case HCD_PIPE_EVENT_IRP_DONE: {
+                //Dequeue the IRP
+                TEST_ASSERT_EQUAL(irp, hcd_irp_dequeue(dflt_pipe_hdl));
+                if (stage == ENUM_STAGE_SET_ADDR) {
+                    printf("Address is set\n");
+                    hcd_pipe_update(dflt_pipe_hdl, DEV_ADDR, 8);
+                    //Goto set config stage
+                    stage = ENUM_STAGE_SET_CONFIG;
+                    USB_CTRL_REQ_INIT_SET_CONFIG((usb_ctrl_req_t *)data_buffer, 1);
+                    printf("Sending set_config\n");
+                    TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(dflt_pipe_hdl, irp));
+                } else if (stage == ENUM_STAGE_SET_CONFIG) {
+                    printf("Config is set\n");
+                    //Start the periodic pipe task
+                    xTaskNotifyGive(periodic_pipe_task_hdl);
+                }
+                break;
+            }
+            case HCD_PIPE_EVENT_INVALID:
+            case HCD_PIPE_EVENT_ERROR_XFER:
+            case HCD_PIPE_EVENT_ERROR_IRP_NOT_AVAIL:
+            case HCD_PIPE_EVENT_ERROR_OVERFLOW:
+            case HCD_PIPE_EVENT_ERROR_STALL:
+            default:
+                abort();
+                break;
+        }
+    }
+}
+
+
+#define NUM_PACKETS_PER_IRP     5
+#define EP_MPS                  0x04
+#define NUM_IRPS                2
+
+
+/*
+Endpoint Descriptor:
+bLength                 7
+bDescriptorType         5
+bEndpointAddress     0x81  EP 1 IN
+bmAttributes            3
+    Transfer Type            Interrupt
+    Synch Type               None
+    Usage Type               Data
+wMaxPacketSize     0x0004  1x 4 bytes
+bInterval              10
+*/
+
+static usb_desc_ep_t intr_ep_desc = {
+    .bLength = USB_DESC_EP_SIZE,
+    .bDescriptorType = 5,
+    .bEndpointAddress = (0x01 | 0x80),
+    .bmAttributes = USB_BM_ATTRIBUTES_XFER_INT,
+    .wMaxPacketSize = EP_MPS,
+    .bInterval = 10,
+};
+
+static void periodic_pipe_task(void *arg)
+{
+    ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
+    vTaskDelay(pdMS_TO_TICKS(100));
+    printf("Starting periodic task\n");
+    QueueHandle_t pipe_evt_queue = xQueueCreate(EVENT_QUEUE_LEN, sizeof(hcd_pipe_event_t));
+    //Create interrupt pipe
+    hcd_pipe_config_t pipe_config = {
+        .callback = pipe_callback,
+        .callback_arg = (void *)pipe_evt_queue,
+        .context = NULL,
+        .ep_desc = &intr_ep_desc,
+        .dev_speed = USB_SPEED_LOW,
+        .dev_addr = DEV_ADDR,
+    };
+    hcd_pipe_handle_t pipe_hdl;
+    hcd_pipe_alloc(shared_port_hdl, &pipe_config, &pipe_hdl);
+    TEST_ASSERT_NOT_EQUAL(NULL, pipe_hdl);
+
+    //Double buffer two IRPs
+    uint8_t *data_buffers[NUM_IRPS];
+    usb_irp_t *irps[NUM_IRPS];
+    for (int i = 0; i < NUM_IRPS; i++) {
+        data_buffers[i] = heap_caps_calloc(NUM_PACKETS_PER_IRP, EP_MPS, MALLOC_CAP_DMA);
+        TEST_ASSERT_NOT_EQUAL(NULL, data_buffers[i]);
+        irps[i] = heap_caps_calloc(1, sizeof(usb_irp_t), MALLOC_CAP_DEFAULT);
+        TEST_ASSERT_NOT_EQUAL(NULL, irps[i]);
+        //Initialize IRP
+        irps[i]->data_buffer = data_buffers[i];
+        irps[i]->num_bytes = NUM_PACKETS_PER_IRP * EP_MPS;
+        irps[i]->num_iso_packets = 0;
+    }
+
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(pipe_hdl, irps[i]));
+    }
+
+    int x_pos = 0;
+    int y_pos = 0;
+
+    esp_rom_printf("\n\n");
+    while (1) {
+        hcd_pipe_event_t pipe_event;
+        xQueueReceive(pipe_evt_queue, &pipe_event, portMAX_DELAY);
+        if (pipe_event == HCD_PIPE_EVENT_IRP_DONE) {
+            //Dequeue
+            usb_irp_t *done_irp = hcd_irp_dequeue(pipe_hdl);
+            TEST_ASSERT_NOT_EQUAL(NULL, done_irp);
+            TEST_ASSERT_EQUAL(USB_TRANSFER_STATUS_COMPLETED, done_irp->status);
+            //Check the values of the IRP and calculate position
+            for (int i = 0; i < (NUM_PACKETS_PER_IRP * EP_MPS); i += EP_MPS) {
+                int x_delta = (int) ((int8_t)done_irp->data_buffer[i+1]);
+                int y_delta = (int) ((int8_t)done_irp->data_buffer[i+2]);
+                x_pos += x_delta;
+                y_pos += y_delta;
+            }
+            //Just requeue
+            TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(pipe_hdl, done_irp));
+            esp_rom_printf("\r%d\t%d\n", x_pos, y_pos);
+        }
+    }
+
+
+
+
+
+
+
+
+
+
+
+#if 0
+
+
+    usbh_dev_t *dev = &USBH;
+    usb_host_chan_regs_t *chan = &dev->host_chans[TEST_CHAN_IDX];
+
+    //Allocate memory for frame list. Needs to be 512 aligned for some reason?
+    //uint32_t *frame_list = heap_caps_calloc(FRAME_LIST_LEN, sizeof(uint32_t), MALLOC_CAP_DMA);
+    uint32_t *frame_list = heap_caps_aligned_calloc(512, FRAME_LIST_LEN, sizeof(uint32_t), MALLOC_CAP_DMA);
+    //Allocate memory for descriptor list
+    usbh_ll_dma_qtd_t *desc_list = heap_caps_aligned_calloc(512, DESC_LIST_LEN, sizeof(usbh_ll_dma_qtd_t), MALLOC_CAP_DMA);
+    shared_list = desc_list;
+
+    //Setup frame list to: Transmit an INTR IN every frame
+    for (int i = 0; i < FRAME_LIST_LEN; i++) {
+        frame_list[i] = 1 << TEST_CHAN_IDX;
+        /*if (i % 8 == 0) {
+            frame_list[i] = 1 << TEST_CHAN_IDX;
+        }*/
+    }
+    //Setup the desc list with two leading desc. EOL at the last filled desc. NULL the remaining (don't by calloc already)
+    uint8_t *data_buffers[NUM_DESC_FILLED];
+    for (int i = 0; i < NUM_DESC_FILLED; i++) {
+        data_buffers[i] = heap_caps_malloc(sizeof(uint8_t) * EP_MPS, MALLOC_CAP_DMA);
+    }
+    for (int i = 0; i < NUM_DESC_FILLED; i++) {
+        //Just allocate enough data buffer for a 1 MPS IN INTR transfer
+        //Unlike ISOC, INTR always starts from the first QTD in the list. So just override the last QTD to EOL
+        usbh_ll_set_qtd_in(&desc_list[i], data_buffers[i], EP_MPS, (i == NUM_DESC_FILLED - 1) ? true : false);
+        //desc_list[i].in_non_iso.intr_cplt = 1;
+    }
+
+    print_desc_list(desc_list, DESC_LIST_LEN);
+
+    portENTER_CRITICAL(external_lock);
+    //Alloc channel
+    usbh_ll_chan_intr_read_and_clear(chan);
+    usbh_ll_haintmsk_en_chan_intr(dev, 1 << TEST_CHAN_IDX);
+    usbh_ll_chan_set_intr_mask(chan, CHAN_INTRS);
+    usbh_ll_chan_set_pid(chan, 0);
+    usbh_ll_chan_hctsiz_init(chan);
+
+    //Enable periodic scheduling
+    usbh_ll_set_frame_list_base_addr(dev, (uint32_t)frame_list);    //Set HFLB addr
+    usbh_ll_frame_list_len_t num_entries;
+#if (FRAME_LIST_LEN == 8)
+    num_entries = USBH_LL_FRAME_LIST_LEN_8;
+#elif (FRAME_LIST_LEN == 16)
+    num_entries = USBH_LL_FRAME_LIST_LEN_16;
+#elif (FRAME_LIST_LEN == 32)
+    num_entries = USBH_LL_FRAME_LIST_LEN_32;
+#else
+    num_entries = USBH_LL_FRAME_LIST_LEN_64;
+#endif
+    usbh_ll_hcfg_set_num_frame_list_entries(dev, num_entries);
+    usbh_ll_hcfg_en_perio_sched(dev);   //Enable periodic scheduling
+
+    //Initialize the channels EP characteristics
+    usbh_ll_chan_hcchar_init(chan, DEV_ADDR, EP_NUM, EP_MPS, USB_HAL_XFER_TYPE_INTR, true, false);
+    //Setup DMA list
+    usbh_ll_chan_set_dma_addr_non_iso(chan, (void *)desc_list, 0);  //Start with 0
+    usbh_ll_chan_set_qtd_list_len_non_iso(chan, DESC_LIST_LEN);
+    portEXIT_CRITICAL(external_lock);
+
+    for (int i = 3; i > 0; i--) {
+        printf("Starting in %d\n", i);
+        vTaskDelay(pdMS_TO_TICKS(1000));
+    }
+
+    portENTER_CRITICAL(external_lock);
+    usbh_ll_chan_start(chan);
+    portEXIT_CRITICAL(external_lock);
+
+    vTaskDelay(pdMS_TO_TICKS(2000));
+    print_desc_list(desc_list, DESC_LIST_LEN);
+    for (int i = 0; i < NUM_DESC_FILLED; i++) {
+        printf("Data 0x%x 0x%x 0x%x 0x%x\n", data_buffers[i][0], data_buffers[i][1], data_buffers[i][2], data_buffers[i][3]);
+    }
+#endif
+    vTaskDelay(portMAX_DELAY);
+}
+
+
+TEST_CASE("Test Interrupt Pipe", "[hcd][ignore]")
+{
+    hcd_config_t hcd_config = {
+        .intr_flags = ESP_INTR_FLAG_LEVEL1,
+    };
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_install(&hcd_config));
+
+    xTaskCreatePinnedToCore(port_task, "port", 4096, NULL, 5, &port_task_hdl, 0);
+    xTaskCreatePinnedToCore(dflt_pipe_task, "dflt", 4096, NULL, 4, &dflt_pipe_task_hdl, 0);
+    xTaskCreatePinnedToCore(periodic_pipe_task, "perio", 4096, NULL, 3, &periodic_pipe_task_hdl, 0);
+
+    //Start the port task
+    xTaskNotifyGive(port_task_hdl);
+    vTaskDelay(portMAX_DELAY);
+
+
+
+}
-- 
2.25.1


From 627a6640b904362d66b72ac1d241279ccc63c9e4 Mon Sep 17 00:00:00 2001
From: Darian Leung <darian@espressif.com>
Date: Fri, 19 Mar 2021 17:44:31 +0800
Subject: [PATCH 5/9] Fix index scheduling calculation for isoc

Signed-off-by: Li Bo <libo@espressif.com>
---
 components/usb/hcd.c                 |  28 ++-
 components/usb/private_include/usb.h |  11 +
 components/usb/test/test_hcd_intr.c  | 106 +-------
 components/usb/test/test_hcd_isoc.c  | 351 +++++++++++++++++++++++++++
 4 files changed, 384 insertions(+), 112 deletions(-)
 create mode 100644 components/usb/test/test_hcd_isoc.c

diff --git a/components/usb/hcd.c b/components/usb/hcd.c
index 54568b8d3..33e665a90 100644
--- a/components/usb/hcd.c
+++ b/components/usb/hcd.c
@@ -1640,7 +1640,7 @@ esp_err_t hcd_pipe_alloc(hcd_port_handle_t port_hdl, const hcd_pipe_config_t *pi
         }
         //For now, we just phase offset everything by their channel number
         //Todo: Use a smarter load balancing scheduling algorithm
-        pipe->ep_char.periodic.phase_offset_frames = port->num_pipes_idle + port->num_pipes_queued; //We are the Nth pipe allocate, use that as an idex
+        pipe->ep_char.periodic.phase_offset_frames = (port->num_pipes_idle + port->num_pipes_queued) & (XFER_LIST_LEN_ISOC - 1); //We are the Nth pipe allocate, use that as an idex % frame list length
     }
     pipe->state = HCD_PIPE_STATE_ACTIVE;
     pipe->callback = pipe_config->callback;
@@ -1951,24 +1951,26 @@ static void _buffer_fill(pipe_t *pipe)
             break;
         }
         case USB_HAL_XFER_TYPE_ISOCHRONOUS: {
-            int start_idx;
-            if (pipe->multi_buffer_flags.wr_idx == pipe->multi_buffer_flags.rd_idx) {
+            uint32_t start_idx;
+            if (pipe->multi_buffer_flags.buffer_num_to_exec == 0) {
                 //There are no more previously filled buffers to execute. We need to calculate a new start index based on HFNUM and the pipe's schedule
                 uint32_t cur_frame_num = usbh_hal_port_get_cur_frame_num(pipe->port->hal);
-                //Isoc list length is always a power of 2. Mask it with the length to get the current desc index
-                uint32_t cur_idx = cur_frame_num & XFER_LIST_LEN_ISOC;
-                uint32_t last_multiple = (cur_frame_num - pipe->ep_char.periodic.phase_offset_frames) / pipe->ep_char.periodic.interval;
-                uint32_t next_sched_idx = (last_multiple * pipe->ep_char.periodic.interval) + pipe->ep_char.periodic.phase_offset_frames;
+                uint32_t cur_mod_idx_no_offset = (cur_frame_num - pipe->ep_char.periodic.phase_offset_frames) & (XFER_LIST_LEN_ISOC - 1);    //Get the modulated index (i.e., the Nth desc in the descriptor list)
+                //This is the non-offset modulated QTD index of the last scheduled interval
+                uint32_t last_interval_mod_idx_no_offset = (cur_mod_idx_no_offset / pipe->ep_char.periodic.interval) * pipe->ep_char.periodic.interval; //Floor divide and the multiply again
+                uint32_t next_interval_idx_no_offset = (last_interval_mod_idx_no_offset + pipe->ep_char.periodic.interval);
                 //We want at least a half interval or 2 frames of buffer space
-                if (cur_idx + 2 >= next_sched_idx
-                    || cur_idx + (pipe->ep_char.periodic.interval / 2) >= next_sched_idx) {
-                        //Postpone the start by another interval just to be safe
-                        next_sched_idx += pipe->ep_char.periodic.interval;
+                if (next_interval_idx_no_offset - cur_mod_idx_no_offset > (pipe->ep_char.periodic.interval / 2)
+                    && next_interval_idx_no_offset - cur_mod_idx_no_offset >= 2) {
+                        start_idx = (next_interval_idx_no_offset + pipe->ep_char.periodic.phase_offset_frames) & (XFER_LIST_LEN_ISOC - 1);
+                } else {
+                    //Not enough time until the next schedule, add another interval to it.
+                        start_idx =  (next_interval_idx_no_offset + pipe->ep_char.periodic.interval + pipe->ep_char.periodic.phase_offset_frames) & (XFER_LIST_LEN_ISOC - 1);
                 }
-                start_idx = next_sched_idx & XFER_LIST_LEN_ISOC;    //Mask it with the List length to wrap the index
             } else {
                 //Start index is based on previously filled buffer
-                dma_buffer_block_t *prev_filled_buffer = pipe->buffers[pipe->multi_buffer_flags.wr_idx - 1];
+                uint32_t prev_buffer_idx = (pipe->multi_buffer_flags.wr_idx - 1) & (NUM_BUFFERS - 1);
+                dma_buffer_block_t *prev_filled_buffer = pipe->buffers[prev_buffer_idx];
                 start_idx = prev_filled_buffer->flags.isoc.next_irp_start_idx;
             }
             _buffer_fill_isoc(buffer_to_fill, irp, is_in, mps, (int)pipe->ep_char.periodic.interval, start_idx);
diff --git a/components/usb/private_include/usb.h b/components/usb/private_include/usb.h
index 1f3ed5f11..3b0570ed9 100644
--- a/components/usb/private_include/usb.h
+++ b/components/usb/private_include/usb.h
@@ -252,6 +252,17 @@ _Static_assert(sizeof(usb_ctrl_req_t) == USB_CTRL_REQ_SIZE, "Size of usb_ctrl_re
     (ctrl_req_ptr)->wLength = 0;   \
 })
 
+/**
+ * @brief Initializer for a request to set an interface's alternate setting
+ */
+#define USB_CTRL_REQ_INIT_SET_INTERFACE(ctrl_req_ptr, intf_num, alt_setting_num) ({    \
+    (ctrl_req_ptr)->bRequestType = USB_B_REQUEST_TYPE_DIR_OUT | USB_B_REQUEST_TYPE_TYPE_STANDARD | USB_B_REQUEST_TYPE_RECIP_INTERFACE;  \
+    (ctrl_req_ptr)->bRequest = USB_B_REQUEST_SET_INTERFACE; \
+    (ctrl_req_ptr)->wValue = (alt_setting_num); \
+    (ctrl_req_ptr)->wIndex = (intf_num);  \
+    (ctrl_req_ptr)->wLength = 0;   \
+})
+
 // ------------------ Device Descriptor --------------------
 
 /**
diff --git a/components/usb/test/test_hcd_intr.c b/components/usb/test/test_hcd_intr.c
index a4df74042..4f044e2fa 100644
--- a/components/usb/test/test_hcd_intr.c
+++ b/components/usb/test/test_hcd_intr.c
@@ -83,7 +83,7 @@ static hcd_port_handle_t shared_port_hdl;
 static usb_speed_t port_speed;
 static TaskHandle_t port_task_hdl;
 static TaskHandle_t dflt_pipe_task_hdl;
-static TaskHandle_t periodic_pipe_task_hdl;
+static TaskHandle_t intr_pipe_task_hdl;
 
 static void port_task(void *arg)
 {
@@ -180,7 +180,7 @@ static void dflt_pipe_task(void *arg)
                 } else if (stage == ENUM_STAGE_SET_CONFIG) {
                     printf("Config is set\n");
                     //Start the periodic pipe task
-                    xTaskNotifyGive(periodic_pipe_task_hdl);
+                    xTaskNotifyGive(intr_pipe_task_hdl);
                 }
                 break;
             }
@@ -224,7 +224,7 @@ static usb_desc_ep_t intr_ep_desc = {
     .bInterval = 10,
 };
 
-static void periodic_pipe_task(void *arg)
+static void intr_pipe_task(void *arg)
 {
     ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
     vTaskDelay(pdMS_TO_TICKS(100));
@@ -236,7 +236,7 @@ static void periodic_pipe_task(void *arg)
         .callback_arg = (void *)pipe_evt_queue,
         .context = NULL,
         .ep_desc = &intr_ep_desc,
-        .dev_speed = USB_SPEED_LOW,
+        .dev_speed = port_speed,
         .dev_addr = DEV_ADDR,
     };
     hcd_pipe_handle_t pipe_hdl;
@@ -280,101 +280,12 @@ static void periodic_pipe_task(void *arg)
                 x_pos += x_delta;
                 y_pos += y_delta;
             }
-            //Just requeue
+            //Just requeue the done_irp
             TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(pipe_hdl, done_irp));
-            esp_rom_printf("\r%d\t%d\n", x_pos, y_pos);
+            esp_rom_printf("\rX:%d\tY:%d\n", x_pos, y_pos);
         }
     }
 
-
-
-
-
-
-
-
-
-
-
-#if 0
-
-
-    usbh_dev_t *dev = &USBH;
-    usb_host_chan_regs_t *chan = &dev->host_chans[TEST_CHAN_IDX];
-
-    //Allocate memory for frame list. Needs to be 512 aligned for some reason?
-    //uint32_t *frame_list = heap_caps_calloc(FRAME_LIST_LEN, sizeof(uint32_t), MALLOC_CAP_DMA);
-    uint32_t *frame_list = heap_caps_aligned_calloc(512, FRAME_LIST_LEN, sizeof(uint32_t), MALLOC_CAP_DMA);
-    //Allocate memory for descriptor list
-    usbh_ll_dma_qtd_t *desc_list = heap_caps_aligned_calloc(512, DESC_LIST_LEN, sizeof(usbh_ll_dma_qtd_t), MALLOC_CAP_DMA);
-    shared_list = desc_list;
-
-    //Setup frame list to: Transmit an INTR IN every frame
-    for (int i = 0; i < FRAME_LIST_LEN; i++) {
-        frame_list[i] = 1 << TEST_CHAN_IDX;
-        /*if (i % 8 == 0) {
-            frame_list[i] = 1 << TEST_CHAN_IDX;
-        }*/
-    }
-    //Setup the desc list with two leading desc. EOL at the last filled desc. NULL the remaining (don't by calloc already)
-    uint8_t *data_buffers[NUM_DESC_FILLED];
-    for (int i = 0; i < NUM_DESC_FILLED; i++) {
-        data_buffers[i] = heap_caps_malloc(sizeof(uint8_t) * EP_MPS, MALLOC_CAP_DMA);
-    }
-    for (int i = 0; i < NUM_DESC_FILLED; i++) {
-        //Just allocate enough data buffer for a 1 MPS IN INTR transfer
-        //Unlike ISOC, INTR always starts from the first QTD in the list. So just override the last QTD to EOL
-        usbh_ll_set_qtd_in(&desc_list[i], data_buffers[i], EP_MPS, (i == NUM_DESC_FILLED - 1) ? true : false);
-        //desc_list[i].in_non_iso.intr_cplt = 1;
-    }
-
-    print_desc_list(desc_list, DESC_LIST_LEN);
-
-    portENTER_CRITICAL(external_lock);
-    //Alloc channel
-    usbh_ll_chan_intr_read_and_clear(chan);
-    usbh_ll_haintmsk_en_chan_intr(dev, 1 << TEST_CHAN_IDX);
-    usbh_ll_chan_set_intr_mask(chan, CHAN_INTRS);
-    usbh_ll_chan_set_pid(chan, 0);
-    usbh_ll_chan_hctsiz_init(chan);
-
-    //Enable periodic scheduling
-    usbh_ll_set_frame_list_base_addr(dev, (uint32_t)frame_list);    //Set HFLB addr
-    usbh_ll_frame_list_len_t num_entries;
-#if (FRAME_LIST_LEN == 8)
-    num_entries = USBH_LL_FRAME_LIST_LEN_8;
-#elif (FRAME_LIST_LEN == 16)
-    num_entries = USBH_LL_FRAME_LIST_LEN_16;
-#elif (FRAME_LIST_LEN == 32)
-    num_entries = USBH_LL_FRAME_LIST_LEN_32;
-#else
-    num_entries = USBH_LL_FRAME_LIST_LEN_64;
-#endif
-    usbh_ll_hcfg_set_num_frame_list_entries(dev, num_entries);
-    usbh_ll_hcfg_en_perio_sched(dev);   //Enable periodic scheduling
-
-    //Initialize the channels EP characteristics
-    usbh_ll_chan_hcchar_init(chan, DEV_ADDR, EP_NUM, EP_MPS, USB_HAL_XFER_TYPE_INTR, true, false);
-    //Setup DMA list
-    usbh_ll_chan_set_dma_addr_non_iso(chan, (void *)desc_list, 0);  //Start with 0
-    usbh_ll_chan_set_qtd_list_len_non_iso(chan, DESC_LIST_LEN);
-    portEXIT_CRITICAL(external_lock);
-
-    for (int i = 3; i > 0; i--) {
-        printf("Starting in %d\n", i);
-        vTaskDelay(pdMS_TO_TICKS(1000));
-    }
-
-    portENTER_CRITICAL(external_lock);
-    usbh_ll_chan_start(chan);
-    portEXIT_CRITICAL(external_lock);
-
-    vTaskDelay(pdMS_TO_TICKS(2000));
-    print_desc_list(desc_list, DESC_LIST_LEN);
-    for (int i = 0; i < NUM_DESC_FILLED; i++) {
-        printf("Data 0x%x 0x%x 0x%x 0x%x\n", data_buffers[i][0], data_buffers[i][1], data_buffers[i][2], data_buffers[i][3]);
-    }
-#endif
     vTaskDelay(portMAX_DELAY);
 }
 
@@ -388,12 +299,9 @@ TEST_CASE("Test Interrupt Pipe", "[hcd][ignore]")
 
     xTaskCreatePinnedToCore(port_task, "port", 4096, NULL, 5, &port_task_hdl, 0);
     xTaskCreatePinnedToCore(dflt_pipe_task, "dflt", 4096, NULL, 4, &dflt_pipe_task_hdl, 0);
-    xTaskCreatePinnedToCore(periodic_pipe_task, "perio", 4096, NULL, 3, &periodic_pipe_task_hdl, 0);
+    xTaskCreatePinnedToCore(intr_pipe_task, "isoc", 4096, NULL, 3, &intr_pipe_task_hdl, 0);
 
     //Start the port task
     xTaskNotifyGive(port_task_hdl);
     vTaskDelay(portMAX_DELAY);
-
-
-
 }
diff --git a/components/usb/test/test_hcd_isoc.c b/components/usb/test/test_hcd_isoc.c
new file mode 100644
index 000000000..d41574ee5
--- /dev/null
+++ b/components/usb/test/test_hcd_isoc.c
@@ -0,0 +1,351 @@
+// Copyright 2015-2020 Espressif Systems (Shanghai) PTE LTD
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <stdio.h>
+#include <string.h>
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "unity.h"
+#include "test_utils.h"
+#include "soc/gpio_pins.h"
+#include "soc/gpio_sig_map.h"
+#include "esp_intr_alloc.h"
+#include "esp_err.h"
+#include "esp_attr.h"
+#include "esp_rom_gpio.h"
+#include "hal/usbh_ll.h"
+#include "usb.h"
+#include "../private_include/hcd.h"
+
+// -------------------------------------------------- PHY Control ------------------------------------------------------
+
+static void phy_force_conn_state(bool connected, TickType_t delay_ticks)
+{
+    vTaskDelay(delay_ticks);
+    usb_wrap_dev_t *wrap = &USB_WRAP;
+    if (connected) {
+        //Swap back to internal PHY that is connected to a devicee
+        wrap->otg_conf.phy_sel = 0;
+    } else {
+        //Set externa PHY input signals to fixed voltage levels mimicing a disconnected state
+        esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ZERO_INPUT, USB_EXTPHY_VP_IDX, false);
+        esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ZERO_INPUT, USB_EXTPHY_VM_IDX, false);
+        esp_rom_gpio_connect_in_signal(GPIO_MATRIX_CONST_ONE_INPUT, USB_EXTPHY_RCV_IDX, false);
+        //Swap to the external PHY
+        wrap->otg_conf.phy_sel = 1;
+    }
+}
+
+// ------------------------------------------------ Helper Functions ---------------------------------------------------
+
+#define EVENT_QUEUE_LEN             5
+#define TRANSFER_DATA_MAX_BYTES     256     //Just assume that will only IN/OUT 256 bytes for now
+#define PORT_NUM                    1
+#define DEV_ADDR                    1
+#define DFLT_MPS                    64
+#define INTF_NUM                    1
+#define ALT_SET_NUM                 0
+
+static bool port_callback(hcd_port_handle_t port_hdl, hcd_port_event_t port_event, void *user_arg, bool in_isr)
+{
+    QueueHandle_t port_evt_queue = (QueueHandle_t)user_arg;
+    TEST_ASSERT(in_isr);    //Current HCD implementation should never call a port callback in a task context
+    BaseType_t xTaskWoken = pdFALSE;
+    xQueueSendFromISR(port_evt_queue, &port_event, &xTaskWoken);
+    return (xTaskWoken == pdTRUE);
+}
+
+static bool pipe_callback(hcd_pipe_handle_t pipe_hdl, hcd_pipe_event_t pipe_event, void *user_arg, bool in_isr)
+{
+    QueueHandle_t pipe_evt_queue = (QueueHandle_t)user_arg;
+    if (in_isr) {
+        BaseType_t xTaskWoken = pdFALSE;
+        xQueueSendFromISR(pipe_evt_queue, &pipe_event, &xTaskWoken);
+        return (xTaskWoken == pdTRUE);
+    } else {
+        xQueueSend(pipe_evt_queue, &pipe_event, portMAX_DELAY);
+        return false;
+    }
+}
+
+// ------------------------------------------------ Host Port Tests ----------------------------------------------------
+
+static hcd_port_handle_t shared_port_hdl;
+static usb_speed_t port_speed;
+static TaskHandle_t port_task_hdl;
+static TaskHandle_t dflt_pipe_task_hdl;
+static TaskHandle_t isoc_pipe_task_hdl;
+
+static void port_task(void *arg)
+{
+    ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
+    //Initialize a port
+    QueueHandle_t port_evt_queue = xQueueCreate(EVENT_QUEUE_LEN, sizeof(hcd_port_event_t));
+    hcd_port_config_t port_config = {
+        .callback = port_callback,
+        .callback_arg = (void *)port_evt_queue,
+        .context = NULL,
+    };
+    hcd_port_handle_t port_hdl;
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_init(PORT_NUM, &port_config, &port_hdl));
+    shared_port_hdl = port_hdl;
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_POWER_ON));
+
+    hcd_port_event_t port_evt;
+    while (xQueueReceive(port_evt_queue, &port_evt, portMAX_DELAY) == pdTRUE) {
+        hcd_port_event_t actual_evt = hcd_port_handle_event(port_hdl);
+        switch (actual_evt) {
+            case HCD_PORT_EVENT_CONNECTION: {
+                //Reset newly connected device
+                printf("Resetting\n");
+                TEST_ASSERT_EQUAL(ESP_OK, hcd_port_command(port_hdl, HCD_PORT_CMD_RESET));
+                TEST_ASSERT_EQUAL(ESP_OK, hcd_port_get_speed(port_hdl, &port_speed));
+                printf("Port speed is %d\n", port_speed);
+                //Start the default pipe task
+                xTaskNotifyGive(dflt_pipe_task_hdl);
+                break;
+            }
+            case HCD_PORT_EVENT_NONE: {
+                break;
+            }
+            case HCD_PORT_EVENT_DISCONNECTION:
+            case HCD_PORT_EVENT_ERROR:
+            case HCD_PORT_EVENT_OVERCURRENT:
+            case HCD_PORT_EVENT_SUDDEN_DISCONN:
+            default:
+                abort();
+        }
+    }
+}
+
+static void dflt_pipe_task(void *arg)
+{
+    typedef enum {
+        ENUM_STAGE_SET_ADDR,
+        ENUM_STAGE_SET_CONFIG,
+        ENUM_STAGE_SET_ALT_SETTING,     //Set the alt setting that gives us an MPS of 512
+        ENUM_STAGE_SET_CLASS_REQ_1,     //Req 1 data 1
+        ENUM_STAGE_SET_CLASS_REQ_2,     //Req 1 data 2
+        ENUM_STAGE_SET_CLASS_REQ_3,     //Req 2 data 2
+    } enum_stage_t;
+    ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
+    //Initialize default pipe
+    QueueHandle_t dflt_pipe_evt_queue = xQueueCreate(EVENT_QUEUE_LEN, sizeof(hcd_pipe_event_t));
+    hcd_pipe_config_t config = {
+        .callback = pipe_callback,
+        .callback_arg = (void *)dflt_pipe_evt_queue,
+        .context = NULL,
+        .ep_desc = NULL,    //NULL EP descriptor to create a default pipe
+        .dev_addr = 0,
+        .dev_speed = port_speed,
+    };
+    hcd_pipe_handle_t dflt_pipe_hdl;
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_pipe_alloc(shared_port_hdl, &config, &dflt_pipe_hdl));
+    hcd_pipe_update(dflt_pipe_hdl, 0, DFLT_MPS);
+    printf("default pipe created\n");
+
+    uint8_t *data_buffer = heap_caps_malloc(sizeof(usb_ctrl_req_t) + TRANSFER_DATA_MAX_BYTES, MALLOC_CAP_DMA);
+    usb_irp_t *irp = heap_caps_calloc(1, sizeof(usb_irp_t), MALLOC_CAP_DEFAULT);
+    irp->data_buffer = data_buffer;
+    //Init IRP for set addr
+    enum_stage_t stage = ENUM_STAGE_SET_ADDR;
+    USB_CTRL_REQ_INIT_SET_ADDR((usb_ctrl_req_t *)data_buffer, DEV_ADDR);
+    irp->num_bytes = 0; //No data stage
+    //Enqueue it
+    printf("Sending set_addr\n");
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(dflt_pipe_hdl, irp));
+
+    hcd_pipe_event_t pipe_evt;
+    while (xQueueReceive(dflt_pipe_evt_queue, &pipe_evt, portMAX_DELAY) == pdTRUE) {
+        switch (pipe_evt) {
+            case HCD_PIPE_EVENT_NONE: {
+                break;
+            }
+            case HCD_PIPE_EVENT_IRP_DONE: {
+                //Dequeue the IRP
+                TEST_ASSERT_EQUAL(irp, hcd_irp_dequeue(dflt_pipe_hdl));
+                if (stage == ENUM_STAGE_SET_ADDR) {
+                    printf("Address is set\n");
+                    hcd_pipe_update(dflt_pipe_hdl, DEV_ADDR, 8);
+                    //Goto set config stage
+                    stage = ENUM_STAGE_SET_CONFIG;
+                    USB_CTRL_REQ_INIT_SET_CONFIG((usb_ctrl_req_t *)data_buffer, 1);
+                    printf("Sending set_config\n");
+                    TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(dflt_pipe_hdl, irp));
+                } else if (stage == ENUM_STAGE_SET_CONFIG) {
+                    printf("Config is set\n");
+                    //Goto set alt interface setting
+                    stage = ENUM_STAGE_SET_ALT_SETTING;
+                    USB_CTRL_REQ_INIT_SET_INTERFACE((usb_ctrl_req_t *)data_buffer, INTF_NUM, ALT_SET_NUM);
+                    printf("Sending alt setting\n");
+                    TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(dflt_pipe_hdl, irp));
+                } else {
+                    //Enum done,start the periodic pipe task
+                    xTaskNotifyGive(isoc_pipe_task_hdl);
+                    printf("All done\n");
+                }
+                break;
+            }
+            case HCD_PIPE_EVENT_INVALID:
+            case HCD_PIPE_EVENT_ERROR_XFER:
+            case HCD_PIPE_EVENT_ERROR_IRP_NOT_AVAIL:
+            case HCD_PIPE_EVENT_ERROR_OVERFLOW:
+            case HCD_PIPE_EVENT_ERROR_STALL:
+            default:
+                printf("Unknown case %d\n", pipe_evt);
+                abort();
+                break;
+        }
+    }
+}
+
+#define NUM_PACKETS_PER_IRP     4
+//#define EP_MPS                  512
+#define EP_MPS                  64
+#define EP_NUM                  0x2
+#define NUM_IRPS                3   //Triple buffer just to be safe
+
+/*
+ISOC IN doesn't return any data right now from the camera. The camera just doesn't respond. There must be some UVC
+specific configs that need to be sent in order to put the ISOC IN endpoint into a particular state.
+- For now, we just set an alternate interface, and then open an ISOC OUT to a non-existant endpoint.
+- Since OUT ISO has no ack, the endpoint doesn't need to exist.
+
+Endpoint Descriptor:
+    bLength                 7
+    bDescriptorType         5
+    bEndpointAddress     0x82  EP 2 IN
+    bmAttributes            5
+        Transfer Type            Isochronous
+        Synch Type               Asynchronous
+        Usage Type               Data
+    wMaxPacketSize     0x0200  1x 512 bytes
+    bInterval               1
+*/
+
+static usb_desc_ep_t isoc_ep_desc = {
+    .bLength = USB_DESC_EP_SIZE,
+    .bDescriptorType = 5,
+    .bEndpointAddress = EP_NUM, //OUT
+    .bmAttributes = USB_BM_ATTRIBUTES_XFER_ISOC,
+    .wMaxPacketSize = EP_MPS,
+    .bInterval = 1,
+};
+
+static void isoc_pipe_task(void *arg)
+{
+    ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
+    vTaskDelay(pdMS_TO_TICKS(100));
+    printf("Starting periodic task\n");
+    QueueHandle_t pipe_evt_queue = xQueueCreate(EVENT_QUEUE_LEN, sizeof(hcd_pipe_event_t));
+    //Create isoc pipe
+    hcd_pipe_config_t pipe_config = {
+        .callback = pipe_callback,
+        .callback_arg = (void *)pipe_evt_queue,
+        .context = NULL,
+        .ep_desc = &isoc_ep_desc,
+        .dev_speed = port_speed,
+        .dev_addr = DEV_ADDR,
+    };
+    hcd_pipe_handle_t pipe_hdl;
+    hcd_pipe_alloc(shared_port_hdl, &pipe_config, &pipe_hdl);
+    TEST_ASSERT_NOT_EQUAL(NULL, pipe_hdl);
+
+    //Double buffer two IRPs
+    uint8_t *data_buffers[NUM_IRPS];
+    usb_irp_t *irps[NUM_IRPS];
+    for (int i = 0; i < NUM_IRPS; i++) {
+        data_buffers[i] = heap_caps_calloc(NUM_PACKETS_PER_IRP, EP_MPS, MALLOC_CAP_DMA);
+        TEST_ASSERT_NOT_EQUAL(NULL, data_buffers[i]);
+        //For ISOC IRPs, we need to leave space for the iso packet descriptor list in the IRP
+        irps[i] = heap_caps_calloc(1, sizeof(usb_irp_t) + (sizeof(usb_iso_packet_desc_t) * NUM_PACKETS_PER_IRP), MALLOC_CAP_DEFAULT);
+        TEST_ASSERT_NOT_EQUAL(NULL, irps[i]);
+        //Initialize IRP and data buffer
+        irps[i]->data_buffer = data_buffers[i];
+        irps[i]->num_iso_packets = NUM_PACKETS_PER_IRP;
+        for (int j = 0; j < NUM_PACKETS_PER_IRP; j++) {
+            //For each packet in an IRP, set then to the same value
+            memset(data_buffers[i] + (j * EP_MPS), j , EP_MPS);
+            //We need to initialize each individual isoc packet descriptor of the IRP
+            irps[i]->iso_packet_desc[j].length = EP_MPS;
+        }
+    }
+    printf("Pipe and IRPs created. Enqueing\n");
+
+    for (int i = 0; i < NUM_IRPS; i++) {
+        TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(pipe_hdl, irps[i]));
+    }
+
+
+     while (1) {
+        hcd_pipe_event_t pipe_event;
+        xQueueReceive(pipe_evt_queue, &pipe_event, portMAX_DELAY);
+        if (pipe_event == HCD_PIPE_EVENT_IRP_DONE) {
+            //Dequeue
+            usb_irp_t *done_irp = hcd_irp_dequeue(pipe_hdl);
+            //Just requeue
+            TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(pipe_hdl, done_irp));
+        }
+     }
+
+#if 0
+
+    int x_pos = 0;
+    int y_pos = 0;
+
+    esp_rom_printf("\n\n");
+    while (1) {
+        hcd_pipe_event_t pipe_event;
+        xQueueReceive(pipe_evt_queue, &pipe_event, portMAX_DELAY);
+        if (pipe_event == HCD_PIPE_EVENT_IRP_DONE) {
+            //Dequeue
+            usb_irp_t *done_irp = hcd_irp_dequeue(pipe_hdl);
+            TEST_ASSERT_NOT_EQUAL(NULL, done_irp);
+            TEST_ASSERT_EQUAL(USB_TRANSFER_STATUS_COMPLETED, done_irp->status);
+            //Check the values of the IRP and calculate position
+            for (int i = 0; i < (NUM_PACKETS_PER_IRP * EP_MPS); i += EP_MPS) {
+                int x_delta = (int) ((int8_t)done_irp->data_buffer[i+1]);
+                int y_delta = (int) ((int8_t)done_irp->data_buffer[i+2]);
+                x_pos += x_delta;
+                y_pos += y_delta;
+            }
+            //Just requeue
+            TEST_ASSERT_EQUAL(ESP_OK, hcd_irp_enqueue(pipe_hdl, done_irp));
+            esp_rom_printf("\rX:%d\tY:%d\n", x_pos, y_pos);
+        }
+    }
+#endif
+
+    vTaskDelay(portMAX_DELAY);
+}
+
+
+TEST_CASE("Test Isochronous Pipe", "[hcd][ignore]")
+{
+    hcd_config_t hcd_config = {
+        .intr_flags = ESP_INTR_FLAG_LEVEL1,
+    };
+    TEST_ASSERT_EQUAL(ESP_OK, hcd_install(&hcd_config));
+
+    xTaskCreatePinnedToCore(port_task, "port", 4096, NULL, 5, &port_task_hdl, 0);
+    xTaskCreatePinnedToCore(dflt_pipe_task, "dflt", 4096, NULL, 4, &dflt_pipe_task_hdl, 0);
+    xTaskCreatePinnedToCore(isoc_pipe_task, "isoc", 4096, NULL, 3, &isoc_pipe_task_hdl, 0);
+
+    //Start the port task
+    xTaskNotifyGive(port_task_hdl);
+    vTaskDelay(portMAX_DELAY);
+
+
+
+}
-- 
2.25.1


From d5dd0c33931659dc943e663369df7e6b42dfa3ca Mon Sep 17 00:00:00 2001
From: Darian Leung <darian@espressif.com>
Date: Fri, 19 Mar 2021 18:13:33 +0800
Subject: [PATCH 6/9] Add FIFO size configuration function

Signed-off-by: Li Bo <libo@espressif.com>
---
 components/usb/hcd.c                 | 77 ++++++++++++++++++++++++++--
 components/usb/private_include/hcd.h | 16 ++++++
 components/usb/test/test_hcd_isoc.c  | 11 +++-
 3 files changed, 99 insertions(+), 5 deletions(-)

diff --git a/components/usb/hcd.c b/components/usb/hcd.c
index 33e665a90..fa36ce3bb 100644
--- a/components/usb/hcd.c
+++ b/components/usb/hcd.c
@@ -55,7 +55,7 @@
  *
  * RXFIFO
  * - Recommended: ((LPS/4) * 2) + 2
- * - Actual: Whatever leftover size: USBH_HAL_FIFO_TOTAL_USABLE_LINES - 48 - 48 = 104
+ * - Actual: Whatever leftover size: USBH_HAL_FIFO_TOTAL_USABLE_LINES(200) - 48 - 48 = 104
  * - Best case can accommodate two packets of 204 bytes
  * NPTXFIFO
  * - Recommended: (LPS/4) * 2
@@ -64,12 +64,53 @@
  * - Recommended: (LPS/4) * 2
  * - Actual: Assume LPS is 64, and 3 packets: (64/4) * 3 = 48
  */
-const usbh_hal_fifo_config_t default_fifo_config = {
+const usbh_hal_fifo_config_t fifo_config_default = {
     .rx_fifo_lines = 104,
     .nptx_fifo_lines = 48,
     .ptx_fifo_lines = 48,
 };
 
+/**
+ * @brief FIFO sizes that bias to giving RX FIFO more capacity
+ *
+ * RXFIFO
+ * - Recommended: ((LPS/4) * 2) + 2
+ * - Actual: Whatever leftover size: USBH_HAL_FIFO_TOTAL_USABLE_LINES(200) - 32 - 16 = 152
+ * - Best case can accommodate two packets of 300 bytes or one packet of 600 bytes
+ * NPTXFIFO
+ * - Recommended: (LPS/4) * 2
+ * - Actual: Assume LPS is 64, and 1 packets: (64/4) * 1 = 16
+ * PTXFIFO
+ * - Recommended: (LPS/4) * 2
+ * - Actual: Assume LPS is 64, and 3 packets: (64/4) * 2 = 32
+ */
+const usbh_hal_fifo_config_t fifo_config_bias_rx = {
+    .rx_fifo_lines = 152,
+    .nptx_fifo_lines = 16,
+    .ptx_fifo_lines = 32,
+};
+
+/**
+ * @brief FIFO sizes that bias to giving Periodic TX FIFO more capacity (i.e., ISOC OUT)
+ *
+ * RXFIFO
+ * - Recommended: ((LPS/4) * 2) + 2
+ * - Actual: Assume LPS is 64, and 2 packets: ((64/4) * 2) + 2 = 34
+ * - Best case can accommodate two packets of 64 bytes
+ * NPTXFIFO
+ * - Recommended: (LPS/4) * 2
+ * - Actual: Assume LPS is 64, and 1 packets: (64/4) * 1 = 16
+ * PTXFIFO
+ * - Recommended: (LPS/4) * 2
+ * - Actual: Whatever leftover size: USBH_HAL_FIFO_TOTAL_USABLE_LINES(200) - 34 - 16 = 150
+ * - Base case can accommodate two packets of 300 bytes of one packet of 600 bytes
+ */
+const usbh_hal_fifo_config_t fifo_config_bias_ptx = {
+    .rx_fifo_lines = 34,
+    .nptx_fifo_lines = 16,
+    .ptx_fifo_lines = 150,
+};
+
 #define FRAME_LIST_LEN                  USB_HAL_FRAME_LIST_LEN_32
 #define NUM_BUFFERS                     2
 
@@ -1302,7 +1343,7 @@ esp_err_t hcd_port_command(hcd_port_handle_t port_hdl, hcd_port_cmd_t command)
                 if (port->state == HCD_PORT_STATE_ENABLED || port->state == HCD_PORT_STATE_DISABLED) {
                     if (_port_bus_reset(port)) {
                         //Set FIFO sizes to default
-                        usbh_hal_set_fifo_size(port->hal, &default_fifo_config);
+                        usbh_hal_set_fifo_size(port->hal, &fifo_config_default);
                         //Reset frame list and enable periodic scheduling
                         memset(port->frame_list, FRAME_LIST_LEN, sizeof(uint32_t));
                         usbh_hal_port_set_frame_list(port->hal, port->frame_list, FRAME_LIST_LEN);
@@ -1446,6 +1487,36 @@ void *hcd_port_get_ctx(hcd_port_handle_t port_hdl)
     return ret;
 }
 
+esp_err_t hcd_port_set_fifo_bias(hcd_port_handle_t port_hdl, hcd_port_fifo_bias_t bias)
+{
+    /*
+    Todo: Add sefte checks restricting when this function can be called. Technically, it's only safe to change fifo
+          sizes under the following conditions
+          - All pipes are no longer actively transmitting
+          - Need to mutex to protect from concurrent acess to port
+          - Need to check if pipes can still be accommodated under new fifo sizes
+    */
+
+    port_t *port = (port_t *)port_hdl;
+    const usbh_hal_fifo_config_t *fifo_config;
+    switch (bias) {
+        case HCD_PORT_FIFO_BIAS_BALANCED:
+            fifo_config = &fifo_config_default;
+            break;
+        case HCD_PORT_FIFO_BIAS_RX:
+            fifo_config = &fifo_config_default;
+            break;
+        case HCD_PORT_FIFO_BIAS_PTX:
+            fifo_config = &fifo_config_bias_ptx;
+            break;
+        default:
+            fifo_config = NULL;
+            abort();
+    }
+    usbh_hal_set_fifo_size(port->hal, fifo_config);
+    return ESP_OK;
+}
+
 
 // --------------------------------------------------- HCD Pipes -------------------------------------------------------
 
diff --git a/components/usb/private_include/hcd.h b/components/usb/private_include/hcd.h
index 335776138..54ad66e1c 100644
--- a/components/usb/private_include/hcd.h
+++ b/components/usb/private_include/hcd.h
@@ -327,6 +327,22 @@ esp_err_t hcd_port_recover(hcd_port_handle_t port_hdl);
  */
 void *hcd_port_get_ctx(hcd_port_handle_t port_hdl);
 
+
+typedef enum {
+    HCD_PORT_FIFO_BIAS_BALANCED,    //Balance out the FIFO distribution for RX, Non-periodic TX, and periodic TX.
+    HCD_PORT_FIFO_BIAS_RX,          //Bias the FIFO to RX.
+    HCD_PORT_FIFO_BIAS_PTX,
+} hcd_port_fifo_bias_t;
+
+/**
+ * @brief
+ *
+ * @param port_hdl
+ * @param bias
+ * @return esp_err_t
+ */
+esp_err_t hcd_port_set_fifo_bias(hcd_port_handle_t port_hdl, hcd_port_fifo_bias_t bias);
+
 // --------------------------------------------------- HCD Pipes -------------------------------------------------------
 
 /**
diff --git a/components/usb/test/test_hcd_isoc.c b/components/usb/test/test_hcd_isoc.c
index d41574ee5..226409e25 100644
--- a/components/usb/test/test_hcd_isoc.c
+++ b/components/usb/test/test_hcd_isoc.c
@@ -211,8 +211,11 @@ static void dflt_pipe_task(void *arg)
 }
 
 #define NUM_PACKETS_PER_IRP     4
-//#define EP_MPS                  512
-#define EP_MPS                  64
+
+//#define EP_MPS                  600     //This is the max packet size if the FIFO is biased to periodic TX
+//#define EP_MPS                  512     //UVC size
+//#define EP_MPS                  192     //This is the max packet size if FIFO is under default sizing
+#define EP_MPS                  64      //Small packet size that should be supported on all FIFO size configs
 #define EP_NUM                  0x2
 #define NUM_IRPS                3   //Triple buffer just to be safe
 
@@ -248,6 +251,10 @@ static void isoc_pipe_task(void *arg)
     ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
     vTaskDelay(pdMS_TO_TICKS(100));
     printf("Starting periodic task\n");
+
+    //Adjust FIFO sizes if necessary
+    //hcd_port_set_fifo_bias(shared_port_hdl, HCD_PORT_FIFO_BIAS_PTX);
+
     QueueHandle_t pipe_evt_queue = xQueueCreate(EVENT_QUEUE_LEN, sizeof(hcd_pipe_event_t));
     //Create isoc pipe
     hcd_pipe_config_t pipe_config = {
-- 
2.25.1


From ea0a4dfe9dffc193133303baca54c4ed946d3966 Mon Sep 17 00:00:00 2001
From: Darian Leung <darian@espressif.com>
Date: Thu, 25 Mar 2021 18:50:40 +0800
Subject: [PATCH 7/9] fix isoc parse bug

Signed-off-by: Li Bo <libo@espressif.com>
---
 components/usb/CMakeLists.txt |  2 +-
 components/usb/hcd.c          | 19 ++++++++++++++-----
 2 files changed, 15 insertions(+), 6 deletions(-)

diff --git a/components/usb/CMakeLists.txt b/components/usb/CMakeLists.txt
index cfaf84d4e..7069f3c6e 100644
--- a/components/usb/CMakeLists.txt
+++ b/components/usb/CMakeLists.txt
@@ -6,7 +6,7 @@ if(NOT "${target}" STREQUAL "esp32s2")
 endif()
 
 idf_component_register(SRCS "hcd.c"
-                    INCLUDE_DIRS ""
+                    INCLUDE_DIRS "private_include"
                     PRIV_INCLUDE_DIRS "private_include"
                     PRIV_REQUIRES "hal"
                     REQUIRES "")
diff --git a/components/usb/hcd.c b/components/usb/hcd.c
index fa36ce3bb..3ccb22fe2 100644
--- a/components/usb/hcd.c
+++ b/components/usb/hcd.c
@@ -1504,7 +1504,7 @@ esp_err_t hcd_port_set_fifo_bias(hcd_port_handle_t port_hdl, hcd_port_fifo_bias_
             fifo_config = &fifo_config_default;
             break;
         case HCD_PORT_FIFO_BIAS_RX:
-            fifo_config = &fifo_config_default;
+            fifo_config = &fifo_config_bias_rx;
             break;
         case HCD_PORT_FIFO_BIAS_PTX:
             fifo_config = &fifo_config_bias_ptx;
@@ -2234,8 +2234,9 @@ static inline void _buffer_parse_intr(dma_buffer_block_t *buffer, bool is_in, in
 static inline void _buffer_parse_isoc(dma_buffer_block_t *buffer, bool is_in)
 {
     usb_irp_t *irp = buffer->irp;
-    int desc_idx = buffer->flags.isoc.irp_start_idx;
-    for (int i = 0; i < irp->num_iso_packets; i++) {
+    int desc_idx = buffer->flags.isoc.irp_start_idx;    //Descriptor index tracks which descriptor in the QTD list
+    for (int pkt_idx = 0; pkt_idx < irp->num_iso_packets; pkt_idx++) {
+        //Clear the filled descriptor
         int rem_len;
         int desc_status;
         usbh_hal_xfer_desc_parse(buffer->xfer_desc_list, desc_idx, &rem_len, &desc_status);
@@ -2243,8 +2244,16 @@ static inline void _buffer_parse_isoc(dma_buffer_block_t *buffer, bool is_in)
         assert(rem_len == 0 || is_in);
         assert(desc_status == USBH_HAL_XFER_DESC_STS_SUCCESS || USBH_HAL_XFER_DESC_STS_NOT_EXECUTED);
         //Update ISO packet actual length and status
-        irp->iso_packet_desc[i].actual_length = irp->iso_packet_desc[i].length - rem_len;
-        irp->iso_packet_desc[i].status = (desc_status == USBH_HAL_XFER_DESC_STS_NOT_EXECUTED) ? USB_TRANSFER_STATUS_SKIPPED : USB_TRANSFER_STATUS_COMPLETED;
+        irp->iso_packet_desc[pkt_idx].actual_length = irp->iso_packet_desc[pkt_idx].length - rem_len;
+        irp->iso_packet_desc[pkt_idx].status = (desc_status == USBH_HAL_XFER_DESC_STS_NOT_EXECUTED) ? USB_TRANSFER_STATUS_SKIPPED : USB_TRANSFER_STATUS_COMPLETED;
+        if (++desc_idx >= XFER_LIST_LEN_INTR) {
+            desc_idx = 0;
+        }
+        //A descriptor is also allocated for unscheduled frames. We need to skip over them
+        desc_idx += buffer->flags.isoc.interval;
+        if (desc_idx >= XFER_LIST_LEN_INTR) {
+            desc_idx -= XFER_LIST_LEN_INTR;
+        }
     }
 }
 
-- 
2.25.1


From 3d545c716ceb4d3be8779e35cac320ad67b723c7 Mon Sep 17 00:00:00 2001
From: Li Bo <libo@espressif.com>
Date: Mon, 29 Mar 2021 15:04:11 +0800
Subject: [PATCH 8/9] fix actual_length and dma bug

Signed-off-by: Li Bo <libo@espressif.com>
---
 components/hal/esp32s2/include/hal/usbh_ll.h | 1 +
 components/hal/esp32s2/usbh_hal.c            | 3 ++-
 components/usb/hcd.c                         | 8 ++++----
 3 files changed, 7 insertions(+), 5 deletions(-)

diff --git a/components/hal/esp32s2/include/hal/usbh_ll.h b/components/hal/esp32s2/include/hal/usbh_ll.h
index 0eec08955..4e2b19010 100644
--- a/components/hal/esp32s2/include/hal/usbh_ll.h
+++ b/components/hal/esp32s2/include/hal/usbh_ll.h
@@ -946,6 +946,7 @@ static inline void usbh_ll_get_qtd_status(usbh_ll_dma_qtd_t *qtd, int *rem_len,
     } else {
         *status = qtd->in_non_iso.rx_status;
     }
+    //*rem_len = (int)((qtd->in_non_iso.xfer_size) & 0x03FF);
     *rem_len = qtd->in_non_iso.xfer_size;
     //Clear the QTD just for safety
     qtd->buffer_status_val = 0;
diff --git a/components/hal/esp32s2/usbh_hal.c b/components/hal/esp32s2/usbh_hal.c
index e90865d68..3d0a58518 100644
--- a/components/hal/esp32s2/usbh_hal.c
+++ b/components/hal/esp32s2/usbh_hal.c
@@ -95,7 +95,8 @@ static void set_defaults(usbh_hal_context_t *hal)
     usbh_ll_internal_phy_conf(hal->wrap_dev);   //Enable and configure internal PHY
     //GAHBCFG register
     usb_ll_en_dma_mode(hal->dev);
-    usb_ll_set_hbstlen(hal->dev, 0);    //INCR16 AHB burst length
+    //usb_ll_set_hbstlen(hal->dev, 0);    //INCR16 AHB burst length
+    usb_ll_set_hbstlen(hal->dev, 7);    //INCR16 AHB burst length
     //GUSBCFG register
     usb_ll_dis_hnp_cap(hal->dev);       //Disable HNP
     usb_ll_dis_srp_cap(hal->dev);       //Disable SRP
diff --git a/components/usb/hcd.c b/components/usb/hcd.c
index 3ccb22fe2..4034c94a2 100644
--- a/components/usb/hcd.c
+++ b/components/usb/hcd.c
@@ -2246,13 +2246,13 @@ static inline void _buffer_parse_isoc(dma_buffer_block_t *buffer, bool is_in)
         //Update ISO packet actual length and status
         irp->iso_packet_desc[pkt_idx].actual_length = irp->iso_packet_desc[pkt_idx].length - rem_len;
         irp->iso_packet_desc[pkt_idx].status = (desc_status == USBH_HAL_XFER_DESC_STS_NOT_EXECUTED) ? USB_TRANSFER_STATUS_SKIPPED : USB_TRANSFER_STATUS_COMPLETED;
-        if (++desc_idx >= XFER_LIST_LEN_INTR) {
+        /*if (++desc_idx >= XFER_LIST_LEN_INTR) {
             desc_idx = 0;
-        }
+        }*/
         //A descriptor is also allocated for unscheduled frames. We need to skip over them
         desc_idx += buffer->flags.isoc.interval;
-        if (desc_idx >= XFER_LIST_LEN_INTR) {
-            desc_idx -= XFER_LIST_LEN_INTR;
+        if (desc_idx >= XFER_LIST_LEN_ISOC) {
+            desc_idx -= XFER_LIST_LEN_ISOC;
         }
     }
 }
-- 
2.25.1


From 5939e8ea9469f40f35cfbbdd5c7c613a121d3057 Mon Sep 17 00:00:00 2001
From: Li Bo <libo@espressif.com>
Date: Fri, 16 Apr 2021 14:30:09 +0800
Subject: [PATCH 9/9] usb workaround

---
 components/driver/spi_master.c                     | 9 +++++++++
 components/hal/esp32s2/include/hal/crypto_dma_ll.h | 1 +
 components/hal/esp32s2/include/hal/spi_ll.h        | 5 +++++
 components/hal/esp32s2/include/hal/usbh_ll.h       | 1 +
 components/hal/esp32s2/usbh_hal.c                  | 4 +++-
 components/hal/spi_hal.c                           | 3 +++
 6 files changed, 22 insertions(+), 1 deletion(-)

diff --git a/components/driver/spi_master.c b/components/driver/spi_master.c
index 7eb160cb9..5b66323c5 100644
--- a/components/driver/spi_master.c
+++ b/components/driver/spi_master.c
@@ -568,6 +568,15 @@ static void SPI_MASTER_ISR_ATTR spi_new_trans(spi_device_t *dev, spi_trans_priv_
 
     //Call pre-transmission callback, if any
     if (dev->cfg.pre_cb) dev->cfg.pre_cb(trans);
+#if 1
+    //USB Bug workaround
+    //while (!((spi_ll_tx_get_fifo_cnt(SPI_LL_GET_HW(host->id)) == 12) || (spi_ll_tx_get_fifo_cnt(SPI_LL_GET_HW(host->id)) == trans->length / 8))) {
+    while (trans->length && spi_ll_tx_get_fifo_cnt(SPI_LL_GET_HW(host->id)) == 0) {
+        __asm__ __volatile__("nop");
+        __asm__ __volatile__("nop");
+        __asm__ __volatile__("nop");
+    }
+#endif
     //Kick off transfer
     spi_hal_user_start(hal);
 }
diff --git a/components/hal/esp32s2/include/hal/crypto_dma_ll.h b/components/hal/esp32s2/include/hal/crypto_dma_ll.h
index 5c65c9249..c189ca93a 100644
--- a/components/hal/esp32s2/include/hal/crypto_dma_ll.h
+++ b/components/hal/esp32s2/include/hal/crypto_dma_ll.h
@@ -25,6 +25,7 @@ extern "C" {
 
 #include "soc/hwcrypto_reg.h"
 #include "soc/dport_reg.h"
+#include "soc/crypto_dma_reg.h"
 
 typedef enum {
     CRYPTO_DMA_AES= 0,
diff --git a/components/hal/esp32s2/include/hal/spi_ll.h b/components/hal/esp32s2/include/hal/spi_ll.h
index d11fbcd98..70635e20c 100644
--- a/components/hal/esp32s2/include/hal/spi_ll.h
+++ b/components/hal/esp32s2/include/hal/spi_ll.h
@@ -1256,6 +1256,11 @@ static inline bool spi_ll_tx_get_empty_err(spi_dev_t *hw)
     return hw->dma_int_raw.outfifo_empty_err;
 }
 
+static inline int spi_ll_tx_get_fifo_cnt(spi_dev_t *hw)
+{
+    return hw->dma_out_status.out_fifo_cnt;
+}
+
 #undef SPI_LL_RST_MASK
 #undef SPI_LL_UNUSED_INT_MASK
 
diff --git a/components/hal/esp32s2/include/hal/usbh_ll.h b/components/hal/esp32s2/include/hal/usbh_ll.h
index 4e2b19010..2ee565e9a 100644
--- a/components/hal/esp32s2/include/hal/usbh_ll.h
+++ b/components/hal/esp32s2/include/hal/usbh_ll.h
@@ -197,6 +197,7 @@ static inline void usb_ll_en_slave_mode(usbh_dev_t *hw)
 
 static inline void usb_ll_set_hbstlen(usbh_dev_t *hw, uint32_t burst_len)
 {
+    hw->gahbcfg_reg.ahbsingle = 0;
     hw->gahbcfg_reg.hbstlen = burst_len;
 }
 
diff --git a/components/hal/esp32s2/usbh_hal.c b/components/hal/esp32s2/usbh_hal.c
index 3d0a58518..b42ec554a 100644
--- a/components/hal/esp32s2/usbh_hal.c
+++ b/components/hal/esp32s2/usbh_hal.c
@@ -96,7 +96,9 @@ static void set_defaults(usbh_hal_context_t *hal)
     //GAHBCFG register
     usb_ll_en_dma_mode(hal->dev);
     //usb_ll_set_hbstlen(hal->dev, 0);    //INCR16 AHB burst length
-    usb_ll_set_hbstlen(hal->dev, 7);    //INCR16 AHB burst length
+    // uint32_t *AHBSignle = (uint32_t *)0x60080008;
+    // *AHBSignle = *AHBSignle | (1ULL << 23);
+    usb_ll_set_hbstlen(hal->dev, 1);    //INCR16 AHB burst length
     //GUSBCFG register
     usb_ll_dis_hnp_cap(hal->dev);       //Disable HNP
     usb_ll_dis_srp_cap(hal->dev);       //Disable SRP
diff --git a/components/hal/spi_hal.c b/components/hal/spi_hal.c
index b5b6e2168..5d518fd88 100644
--- a/components/hal/spi_hal.c
+++ b/components/hal/spi_hal.c
@@ -16,6 +16,7 @@
 
 #include "hal/spi_hal.h"
 #include "soc/soc_caps.h"
+#include "esp_rom_sys.h"
 
 //This GDMA related part will be introduced by GDMA dedicated APIs in the future. Here we temporarily use macros.
 #if SOC_GDMA_SUPPORTED
@@ -43,6 +44,8 @@ static void s_spi_hal_dma_init_config(const spi_hal_context_t *hal)
     spi_dma_ll_tx_enable_burst_data(hal->dma_out, hal->tx_dma_chan, 1);
     spi_dma_ll_rx_enable_burst_desc(hal->dma_in, hal->rx_dma_chan, 1);
     spi_dma_ll_tx_enable_burst_desc(hal->dma_out, hal->tx_dma_chan ,1);
+    esp_rom_printf("0x6002504C = 0x%x\n", *((uint32_t *)0x6002504C));
+    esp_rom_printf("0x6002404C = 0x%x\n", *((uint32_t *)0x6002404C));
 }
 
 void spi_hal_init(spi_hal_context_t *hal, uint32_t host_id, const spi_hal_config_t *config)
-- 
2.25.1

